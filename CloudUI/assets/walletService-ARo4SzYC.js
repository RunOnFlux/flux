const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/crypto-walletconnect-Nsddz84n.js","assets/event-utils-DGlX1gEp.js","assets/ansi-utils-ChIB8aIv.js","assets/lit-Ba94Z-Zv.js","assets/crypto-metamask-D6vz180a.js","assets/socketio-BDGyx5_k.js","assets/uuid-B49X2dQj.js","assets/crypto-viem-CJP2v0S5.js","assets/date-utils-Cx_iWJ70.js","assets/crypto-ox-C1hHNqF1.js","assets/unjs-utils-GcjLqAqW.js"])))=>i.map(i=>d[i]);
import{_ as v}from"./crypto-metamask-D6vz180a.js";let T=null,R=null,K=null,C=null,h=null,D=null;const P="__appkit_initialized__",b="__wagmi_adapter__";if(typeof window<"u"){const n=console.error;console.error=(...e)=>{const t=e[0],o=e[1];if(t&&typeof t=="object"&&t.context){const r=o?.message||o?.toString?.()||"";if(r.includes("No matching key. history:")||r.includes("emitting session_request:")&&r.includes("without any listeners"))return}const a=t?.message||t||"",i=typeof a=="string"?a:a.toString?.()||"";i.includes("<svg> attribute width:")||i.includes("<svg> attribute height:")||n.apply(console,e)}}async function O(){if(!T){const[n,e,t]=await Promise.all([v(()=>import("./crypto-walletconnect-Nsddz84n.js").then(o=>o.j),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10])),v(()=>import("./crypto-walletconnect-Nsddz84n.js").then(o=>o.l),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10])),v(()=>import("./crypto-walletconnect-Nsddz84n.js").then(o=>o.n),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]))]);T={createAppKit:n.createAppKit},R={WagmiAdapter:e.WagmiAdapter,mainnet:t.mainnet}}return{appKitModule:T,wagmiModule:R}}async function z(){const[n,e]=await Promise.all([v(()=>import("./crypto-viem-CJP2v0S5.js").then(t=>t.kM),__vite__mapDeps([7,0,1,2,3,4,5,6,8,9,10])),v(()=>import("./crypto-viem-CJP2v0S5.js").then(t=>t.kN),__vite__mapDeps([7,0,1,2,3,4,5,6,8,9,10]))]);return{getAccount:n.getAccount,watchAccount:n.watchAccount,injected:e.injected,coinbaseWallet:e.coinbaseWallet}}async function j(){return K||(K=await v(()=>import("./crypto-metamask-D6vz180a.js").then(e=>e.m),__vite__mapDeps([4,2,5,6]))),K}const F=typeof window<"u"&&window.location.hostname==="localhost",L="df787edc6839c7de49d527bba9199eaa",x={name:"Flux Cloud",description:"Flux, Your Gateway to a Decentralized World",url:F?typeof window<"u"?window.location.origin:"":"https://cloud.runonflux.com",icons:["https://cloud.runonflux.com/images/logo.png"]};async function k(){if(typeof window<"u"&&window[b])return window[b];if(!h){const{wagmiModule:n}=await O(),e=await z(),t=[e.injected({shimDisconnect:!0}),e.coinbaseWallet({appName:x.name,appLogoUrl:x.icons[0]})];h=new n.WagmiAdapter({projectId:L,networks:[n.mainnet],connectors:t}),console.log("[WagmiAdapter] Attempting to reconnect previous session...");try{await e.reconnect(h.wagmiConfig);const o=e.getAccount(h.wagmiConfig);o?.isConnected?console.log("[WagmiAdapter] âœ… Session restored:",o.address):console.log("[WagmiAdapter] No previous session to restore")}catch(o){console.log("[WagmiAdapter] Reconnect failed (expected if no previous session):",o.message)}typeof window<"u"&&(window[b]=h)}return h}async function M(){if(typeof window<"u"&&window[P])return window[P];if(!C){const{appKitModule:n,wagmiModule:e}=await O(),t=await k();C=n.createAppKit({adapters:[t],networks:[e.mainnet],metadata:x,projectId:L,sdkVersion:"1.8.9",features:{analytics:!0,email:!1,socials:[],emailShowWallets:!0},enableWallets:!0,enableCoinbase:!0,enableInjected:!0,enableEIP6963:!0}),typeof window<"u"&&(window[P]=C)}return C}const G=new Proxy({},{get(n,e){if(C){const t=C[e];return typeof t=="function"?t.bind(C):t}if(typeof window<"u"&&window[P]){const t=window[P],o=t[e];return typeof o=="function"?o.bind(t):o}return async(...t)=>{const o=await M(),a=o[e];return typeof a=="function"?a.apply(o,t):a}}});new Proxy({},{get(n,e){if(h){const t=h[e];return typeof t=="function"?t.bind(h):t}if(typeof window<"u"&&window[b]){const t=window[b],o=t[e];return typeof o=="function"?o.bind(t):o}if(e==="wagmiConfig"){console.warn("[WalletService] wagmiAdapter.wagmiConfig accessed before initialization. Use getWagmiAdapterAsync() instead.");return}return async(...t)=>{const o=await k(),a=o[e];return typeof a=="function"?a.apply(o,t):a}}});async function B(){const n=await M();return new Promise(async(e,t)=>{let o=null,a=!1;try{const i=n.getAccount?.();let r=!1;if(i?.address&&i?.isConnected)try{r=!!(await n.getWalletProvider())?.namespaces}catch{}if(i?.address&&i?.isConnected&&r){console.log("[WalletConnect] Reusing existing session"),e(i.address);return}if(i?.address||i?.isConnected)if(Object.keys(localStorage).some(s=>(s.startsWith("wc@2:")||s.startsWith("@w3m/")||s.startsWith("W3M_")||s.startsWith("@walletconnect/")||s.startsWith("@reown/")||s.startsWith("@appkit/")||s.startsWith("reown")||s.startsWith("wagmi.")||s.includes("walletconnect"))&&!s.includes("DEEPLINK_CHOICE"))){console.log("[WalletConnect] Stale session detected, clearing cache");try{const s=[];for(let w=0;w<localStorage.length;w++){const d=localStorage.key(w);d&&!d.includes("DEEPLINK_CHOICE")&&(d.startsWith("wc@2:")||d.startsWith("@w3m/")||d.startsWith("W3M_")||d.startsWith("@walletconnect/")||d.startsWith("@reown/")||d.startsWith("@appkit/")||d.startsWith("reown")||d.startsWith("wagmi.")||d.includes("walletconnect"))&&s.push(d)}s.forEach(w=>localStorage.removeItem(w)),console.log("[WalletConnect] Cleared",s.length,"cached items")}catch(s){console.warn("[WalletConnect] Failed to clear storage:",s)}await new Promise(s=>setTimeout(s,500))}else{console.log("[WalletConnect] Account state present but no storage, forcing disconnect...");try{await n.disconnect()}catch(s){console.log("[WalletConnect] Disconnect failed (expected):",s.message)}await new Promise(s=>setTimeout(s,500))}o=n.subscribeAccount(l=>{l?.address&&l?.isConnected&&!a&&(a=!0,typeof o=="function"&&o(),e(l.address))}),n.open()}catch(i){console.error("[WalletConnect] Error opening wallet:",i),typeof o=="function"&&o(),t(i)}})}async function J(n){console.log("[WalletConnect] ðŸ” Starting sign request...");const e=await M(),t=await k(),o=await z();try{let a=e.getAccount?.(),i=o.getAccount(t.wagmiConfig);console.log("[WalletConnect] Account states:",{appKit:{address:a?.address,isConnected:a?.isConnected},wagmi:{address:i?.address,isConnected:i?.isConnected}});const r=Object.keys(localStorage).some(c=>(c.startsWith("wc@2:client:")||c.startsWith("wc@2:core:"))&&localStorage.getItem("loginType")==="walletconnect"),l=i?.address||a?.address;if(r&&!l){console.log("[WalletConnect] Session in localStorage, waiting for reconnect() to complete...");let c=0,y=!1;for(;c<6;){await new Promise(m=>setTimeout(m,500));const A=o.getAccount(t.wagmiConfig),_=e.getAccount?.();if(A?.isConnected||_?.isConnected){console.log("[WalletConnect] âœ… Session restored from localStorage (not expired)"),i=A,a=_,y=!0;break}c++}y||console.log("[WalletConnect] âš ï¸ Session did not restore - likely expired or invalid")}let w=!1;const d=i?.isConnected&&i?.address,p=a?.isConnected&&a?.address;if(d||p)try{const c=await e.getWalletProvider();w=!!(c?.namespaces&&Object.keys(c.namespaces).length>0),w&&console.log("[WalletConnect] Valid session found via provider check")}catch(c){console.log("[WalletConnect] Session validation failed:",c.message)}if(!w){console.log("[WalletConnect] No valid session, establishing fresh connection...");let c=0;for(;c<2;){c++,await B();let A=!1,_=0;for(;!A&&_<6;){try{const m=await e.getWalletProvider();if(m?.namespaces&&Object.keys(m.namespaces).length>0){A=!0;break}}catch{}_++,await new Promise(m=>setTimeout(m,500))}if(A)break;if(c<2)try{await e.disconnect();const m=[];for(let W=0;W<localStorage.length;W++){const g=localStorage.key(W);g&&!g.includes("DEEPLINK_CHOICE")&&(g.startsWith("wc@2:")||g.startsWith("@w3m/")||g.startsWith("W3M_")||g.startsWith("@walletconnect/")||g.startsWith("@reown/")||g.startsWith("@appkit/")||g.startsWith("reown")||g.startsWith("wagmi.")||g.includes("walletconnect"))&&m.push(g)}m.forEach(W=>localStorage.removeItem(W)),await new Promise(W=>setTimeout(W,1e3))}catch{}}const y=await e.getWalletProvider();if(!y?.namespaces||Object.keys(y.namespaces).length===0)throw new Error("WalletConnect session failed to initialize. Please refresh and try again.")}const E=o.getAccount(t.wagmiConfig),u=e.getAccount?.(),S=E?.address||u?.address;if(!S)throw new Error("Wallet not connected - please reconnect via WalletConnect");console.log("[WalletConnect] Using address for signing:",S);const f=await e.getWalletProvider();if(!f||typeof f.request!="function")throw new Error("No signing provider available");if(!f.namespaces)throw new Error("Session expired, please reconnect");console.log("[WalletConnect] Requesting signature...");let I;const Z=f.request({method:"personal_sign",params:[n,S]}).then(c=>(clearTimeout(I),c)).catch(c=>{throw clearTimeout(I),c}),V=new Promise((c,y)=>{I=setTimeout(()=>{y(new Error("Signature request timed out after 2 minutes"))},12e4)}),$=await Promise.race([Z,V]);return console.log("[WalletConnect] âœ… Signature received"),$}catch(a){throw console.error("[WalletConnect] âŒ Sign error:",a.message),a}}async function X(){try{const n=await k(),e=await z(),t=await M(),o=e.getAccount(n.wagmiConfig),a=t.getAccount?.(),i=localStorage.getItem("loginType");return a?.isConnected&&a?.address?{address:a.address,isConnected:!0,status:"connected",connector:{name:"walletConnect"}}:o?.isConnected?o:null}catch(n){return console.warn("[WalletService] getConnectedAccount error:",n.message),null}}async function Q(){try{console.log("[WalletConnect] Starting disconnect...");const n=await M();try{await n.disconnect(),await new Promise(t=>setTimeout(t,500))}catch(t){console.warn("[WalletConnect] AppKit disconnect failed:",t.message)}const e=[];for(let t=0;t<localStorage.length;t++){const o=localStorage.key(t);o&&(o.startsWith("wc@2:")||o.startsWith("@w3m/")||o.startsWith("W3M_")||o.startsWith("@walletconnect/")||o.startsWith("@reown/")||o.startsWith("@appkit/")||o.startsWith("reown")||o.startsWith("wagmi.")||o.includes("walletconnect"))&&!o.includes("DEEPLINK_CHOICE")&&!o.includes("recent_wallet")&&e.push(o)}e.forEach(t=>localStorage.removeItem(t)),console.log("[WalletConnect] Cleared",e.length,"storage items"),await new Promise(t=>setTimeout(t,500)),console.log("[WalletConnect] Disconnect complete")}catch(n){console.error("[WalletConnect] Error disconnecting:",n);try{localStorage.removeItem("wc@2:client:0.3//session"),localStorage.removeItem("wagmi.store")}catch{}}}async function H(){if(!D){const n=await j();D=new n.MetaMaskSDK({checkInstallationImmediately:!1,enableAnalytics:!0,preferDesktop:!0,useDeeplink:!1,dappMetadata:{name:"Flux Cloud",url:F?typeof window<"u"?window.location.origin:"":"https://cloud.runonflux.com"}})}return D}async function N(){const n=await H();if(typeof window<"u"&&window.ethereum?.isMetaMask){let t=n.getProvider();if(t||(await n.init(),t=n.getProvider()),t)return t}let e=n.getProvider();if(e||(await n.init(),e=n.getProvider()),!e)throw new Error("MetaMask not installed. Please install MetaMask extension or mobile app.");return e}async function U(){const t=(await(await N()).request({method:"eth_requestAccounts"}))[0];if(!t)throw new Error("No MetaMask account found");return t}async function ee(n,e){const t=await N();e||(e=await U());const o=t.request({method:"personal_sign",params:[n,e]});let a;const i=new Promise((r,l)=>{a=setTimeout(()=>{l(new Error("Please unlock MetaMask extension and try again."))},2e4)});try{const r=await Promise.race([o,i]);return clearTimeout(a),{address:e,signature:r}}catch(r){throw clearTimeout(a),r}}function q(){return typeof window<"u"&&!!window.ssp}async function te(n){if(console.log("[SSP] ðŸ” Starting sign request..."),!q())throw new Error("SSP Wallet not installed");try{const e=await window.ssp.request("sspwid_sign_message",{message:n});if(e.status==="ERROR")throw new Error(e.data||e.result);return console.log("[SSP] âœ… Successfully signed message"),{signature:e.signature,address:e.address}}catch(e){throw console.error("[SSP] âŒ Sign error:",e.message),e}}async function oe(n){if(!q())throw new Error("SSP Wallet not found");const e=await window.ssp.request("pay",n);if(e.status==="ERROR")throw new Error(e.data||e.result);return e}function ne(){return typeof window<"u"&&!!window.ethereum}function ae(){return typeof window<"u"&&!!window.zelcore}async function ie(n,e,t=null,o="https%3A%2F%2Fraw.githubusercontent.com%2Frunonflux%2Fflux%2Fmaster%2FzelID.svg",a=!1){return console.log("[ZelCore] ðŸ” Starting sign request..."),new Promise(async(i,r)=>{try{let l=n;if(n.length>1800){console.log("[ZelCore] Message too long, uploading to Flux Storage...");try{const p=Math.floor(Math.random()*999999999999999).toString();if((await fetch("https://storage.runonflux.io/v1/public",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({publicid:p,public:n})})).ok)l=`FLUX_URL=https://storage.runonflux.io/v1/public/${p}`;else throw new Error("Storage upload failed")}catch{r(new Error("Message too long for ZelCore and Flux Storage is unavailable"));return}}const s=window.zelcore&&typeof window.zelcore.sign=="function",w=window.zelcore&&typeof window.zelcore.protocol=="function",d=!window.zelcore;if(s){try{const p=await window.zelcore.sign(l);console.log("[ZelCore] âœ… Successfully signed with Extension"),i({signature:p,address:e})}catch(p){r(new Error("ZelCore Extension signing failed: "+p.message))}return}if(w||d){if(t&&!a)try{const u=new WebSocket(t);u.onmessage=S=>{try{const f=JSON.parse(S.data);f.signature&&f.zelid&&(u.close(),i({signature:f.signature,address:f.zelid}))}catch(f){console.error("[ZelCore] WebSocket message parse error:",f)}},u.onerror=S=>{u.close(),r(new Error("WebSocket connection failed"))}}catch{r(new Error("Failed to establish WebSocket connection"));return}const p=t?`&callback=${encodeURIComponent(t)}`:"",E=`zel:?action=sign&message=${encodeURIComponent(l)}&icon=${o}${p}`;if(window.zelcore&&window.zelcore.protocol)window.zelcore.protocol(E);else{const u=document.createElement("a");u.href=E,u.style.display="none",document.body.appendChild(u),u.click(),document.body.removeChild(u)}t||i();return}r(new Error("ZelCore wallet not found"))}catch(l){r(l)}})}async function se({address:n,amount:e,message:t,coin:o="zelcash"}){try{const a=`zel:?action=pay&coin=${o}&address=${n}&amount=${e}&message=${t}`;if(window.zelcore&&typeof window.zelcore.protocol=="function")window.zelcore.protocol(a);else{const i=document.createElement("a");i.href=a,i.style.display="none",document.body.appendChild(i),i.click(),document.body.removeChild(i)}}catch(a){throw new Error(`Failed to open Zelcore: ${a.message}`)}}function re(n){return!n||typeof n!="string"?n:n.replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]/g,'"').replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]/g,"'").replace(/[\u2013\u2014\u2015\u2212]/g,"-").replace(/\u2026/g,"...").replace(/\u00A0/g," ").replace(/\u2022/g,"*").replace(/\u2122/g,"(TM)").replace(/\u00A9/g,"(C)").replace(/\u00AE/g,"(R)").replace(/\u00BC/g,"1/4").replace(/\u00BD/g,"1/2").replace(/\u00BE/g,"3/4").replace(/\u00B0/g," deg").replace(/\u00B1/g,"+/-").replace(/\u00D7/g,"x").replace(/\u00F7/g,"/")}export{G as a,ee as b,oe as c,Q as d,te as e,ie as f,X as g,ne as h,q as i,ae as j,re as k,B as o,se as p,J as s};
