import{_ as h}from"./crypto-metamask-D6vz180a.js";import{B as d}from"./crypto-walletconnect-Nsddz84n.js";import{a as w}from"./http-BZQDkn3h.js";function i(){if(!window.crypto||!window.crypto.subtle){const n=window.location.hostname==="localhost"||window.location.hostname==="127.0.0.1",t=window.location.protocol==="https:";let e="WebCrypto API is not available. ";throw!t&&!n?e+="Enterprise features require HTTPS. Please access this application using HTTPS instead of HTTP.":n?e+="This feature requires a modern browser with WebCrypto support.":e+="Please use localhost for development or HTTPS for production.",new Error(e)}}function b(){return!!(window.crypto&&window.crypto.subtle)}const a=window.crypto||window.msCrypto;async function E(n){i();const t=d.from(n,"base64");return await a.subtle.importKey("spki",t,{name:"RSA-OAEP",hash:"SHA-256"},!1,["encrypt"])}function f(n){const t=atob(n),e=t.length,r=new Uint8Array(e);for(let o=0;o<e;o+=1)r[o]=t.charCodeAt(o);return r}function y(n){const t=[],e=new Uint8Array(n),r=e.byteLength;for(let o=0;o<r;o+=1)t.push(String.fromCharCode(e[o]));return btoa(t.join(""))}async function P(n,t){i();const e=y(n),r=await a.subtle.encrypt({name:"RSA-OAEP"},t,d.from(e));return y(r)}async function K(n,t,e){i();const r=a.getRandomValues(new Uint8Array(12)),o=new TextEncoder().encode(n),s=f(e),p=await a.subtle.importKey("raw",t,"AES-GCM",!0,["encrypt","decrypt"]),l=await a.subtle.encrypt({name:"AES-GCM",iv:r},p,o),u=new Uint8Array(l),c=new Uint8Array(s.length+r.length+u.length);return c.set(s),c.set(r,s.byteLength),c.set(u,s.byteLength+r.length),y(c.buffer)}async function x(n,t){i();const e=f(n),r=e.slice(0,12),o=e.slice(12),s=await a.subtle.importKey("raw",t,"AES-GCM",!0,["encrypt","decrypt"]),p=await a.subtle.decrypt({name:"AES-GCM",iv:r},s,o);return new TextDecoder().decode(p)}async function C(n,t){try{if(!b())throw new Error("Enterprise features require HTTPS or localhost. Please access this application using a secure connection.");const e=await h(()=>import("./pgp-DhmimZHp.js"),[]),r=await Promise.all(t.map(s=>e.readKey({armoredKey:s})));return await e.encrypt({message:await e.createMessage({text:n}),encryptionKeys:r})}catch(e){throw console.error("PGP encryption error:",e),e}}async function S(n){const t=[];for(const e of n)try{let r;e.ip.includes(":")?r=`http://${e.ip}/flux/pgp`:r=`http://${e.ip}:16127/flux/pgp`;const o=await w.get(r);o.data.status==="success"?t.push(o.data.data):console.error(`Failed to fetch key for ${e.ip}:`,o.data.data)}catch(r){console.error(`Error fetching key for ${e.ip}:`,r)}if(t.length===0)throw new Error("Failed to fetch any enterprise node PGP keys");return t}export{E as a,K as b,C as c,x as d,P as e,S as g,b as i};
