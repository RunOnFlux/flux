const Lt=typeof window<"u"?window:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},Zr=Symbol("doneWritingPromise"),Oc=Symbol("doneWritingResolve"),Hc=Symbol("doneWritingReject"),wn=Symbol("readingIndex");class ie extends Array{constructor(){super(),Object.setPrototypeOf(this,ie.prototype),this[Zr]=new Promise(((t,r)=>{this[Oc]=t,this[Hc]=r})),this[Zr].catch((()=>{}))}}function gt(n){return n&&n.getReader&&Array.isArray(n)}function Un(n){if(!gt(n)){const t=n.getWriter(),r=t.releaseLock;return t.releaseLock=()=>{t.closed.catch((function(){})),r.call(t)},t}this.stream=n}function vt(n){if(gt(n))return"array";if(Lt.ReadableStream&&Lt.ReadableStream.prototype.isPrototypeOf(n))return"web";if(n&&!(Lt.ReadableStream&&n instanceof Lt.ReadableStream)&&typeof n._read=="function"&&typeof n._readableState=="object")throw Error("Native Node streams are no longer supported: please manually convert the stream to a WebStream, using e.g. `stream.Readable.toWeb`");return!(!n||!n.getReader)&&"web-like"}function Xi(n){return Uint8Array.prototype.isPrototypeOf(n)}function zc(n){if(n.length===1)return n[0];let t=0;for(let i=0;i<n.length;i++){if(!Xi(n[i]))throw Error("concatUint8Array: Data must be in the form of a Uint8Array");t+=n[i].length}const r=new Uint8Array(t);let e=0;return n.forEach((function(i){r.set(i,e),e+=i.length})),r}ie.prototype.getReader=function(){return this[wn]===void 0&&(this[wn]=0),{read:async()=>(await this[Zr],this[wn]===this.length?{value:void 0,done:!0}:{value:this[this[wn]++],done:!1})}},ie.prototype.readToEnd=async function(n){await this[Zr];const t=n(this.slice(this[wn]));return this.length=0,t},ie.prototype.clone=function(){const n=new ie;return n[Zr]=this[Zr].then((()=>{n.push(...this)})),n},Un.prototype.write=async function(n){this.stream.push(n)},Un.prototype.close=async function(){this.stream[Oc]()},Un.prototype.abort=async function(n){return this.stream[Hc](n),n},Un.prototype.releaseLock=function(){},typeof Lt.process=="object"&&Lt.process.versions;const ao=new WeakSet,ct=Symbol("externalBuffer");function me(n){if(this.stream=n,n[ct]&&(this[ct]=n[ct].slice()),gt(n)){const r=n.getReader();return this._read=r.read.bind(r),this._releaseLock=()=>{},void(this._cancel=()=>{})}if(vt(n)){const r=n.getReader();return this._read=r.read.bind(r),this._releaseLock=()=>{r.closed.catch((function(){})),r.releaseLock()},void(this._cancel=r.cancel.bind(r))}let t=!1;this._read=async()=>t||ao.has(n)?{value:void 0,done:!0}:(t=!0,{value:n,done:!1}),this._releaseLock=()=>{if(t)try{ao.add(n)}catch{}}}function Wn(n){return vt(n)?n:new ReadableStream({start(t){t.enqueue(n),t.close()}})}function Gc(n){const t=vt(n);if(t){if(t!=="array")throw Error("Can't convert Stream to ArrayStream here, call `readToEnd` first");return n}const r=new ie;return(async()=>{const e=te(r);await e.write(n),await e.close()})(),r}function Ft(n){return n.some((t=>vt(t)&&!gt(t)))?(function(t){t=t.map(Wn);const r=jc((async function(s){await Promise.all(i.map((a=>Ws(a,s))))}));let e=Promise.resolve();const i=t.map(((s,a)=>Ye(s,((o,c)=>(e=e.then((()=>xr(o,r.writable,{preventClose:a!==t.length-1}))),e)))));return r.readable})(n):n.some((t=>gt(t)))?(function(t){const r=new ie;let e=Promise.resolve();return t.forEach(((i,s)=>(e=e.then((()=>xr(i,r,{preventClose:s!==t.length-1}))),e))),r})(n):typeof n[0]=="string"?n.join(""):zc(n)}async function xr(n,t,{preventClose:r=!1,preventAbort:e=!1,preventCancel:i=!1}={}){if(vt(n)&&!gt(n)&&!gt(t)){n=Wn(n);try{if(n[ct]){const o=te(t);for(let c=0;c<n[ct].length;c++)await o.ready,await o.write(n[ct][c]);o.releaseLock()}await n.pipeTo(t,{preventClose:r,preventAbort:e,preventCancel:i})}catch{}return}vt(n)||(n=Gc(n));const s=pe(n),a=te(t);try{for(;;){await a.ready;const{done:o,value:c}=await s.read();if(o){r||await a.close();break}await a.write(c)}}catch(o){e||await a.abort(o)}finally{s.releaseLock(),a.releaseLock()}}function jc(n){let t,r,e,i=!1,s=!1;return{readable:new ReadableStream({start(a){e=a},pull(){t?t():i=!0},async cancel(a){s=!0,n&&await n(a),r&&r(a)}},{highWaterMark:0}),writable:new WritableStream({write:async function(a){if(s)throw Error("Stream is cancelled");e.enqueue(a),i?i=!1:(await new Promise(((o,c)=>{t=o,r=c})),t=null,r=null)},close:e.close.bind(e),abort:e.error.bind(e)})}}function Et(n,t=()=>{},r=()=>{},e={highWaterMark:0}){if(vt(n))return Vc(n,t,r,e);const i=t(n),s=r();return i!==void 0&&s!==void 0?Ft([i,s]):i!==void 0?i:s}async function Xs(n,t=async()=>{},r=async()=>{},e={highWaterMark:1}){if(vt(n))return Vc(n,t,r,e);const i=await t(n),s=await r();return i!==void 0&&s!==void 0?Ft([i,s]):i!==void 0?i:s}function Vc(n,t,r,e){if(gt(n)){const i=new ie;return(async()=>{const s=te(i);try{const a=await mt(n),o=await t(a),c=await r();let u;u=o!==void 0&&c!==void 0?Ft([o,c]):o!==void 0?o:c,await s.write(u),await s.close()}catch(a){await s.abort(a)}})(),i}if(vt(n)){let i,s=!1;return new ReadableStream({start(){i=n.getReader()},async pull(a){if(s)return a.close(),void n.releaseLock();try{for(;;){const{value:o,done:c}=await i.read();s=c;const u=await(c?r:t)(o);if(u!==void 0)return void a.enqueue(u);if(c)return a.close(),void n.releaseLock()}}catch(o){a.error(o)}},async cancel(a){await i.cancel(a)}},e)}throw Error("Unreachable")}function Ye(n,t){if(vt(n)&&!gt(n)){let e;const i=new TransformStream({start(o){e=o}}),s=xr(n,i.writable),a=jc((async function(o){e.error(o),await s,await new Promise((c=>setTimeout(c)))}));return t(i.readable,a.writable),a.readable}n=Gc(n);const r=new ie;return t(n,r),r}function Wi(n,t){let r;const e=Ye(n,((i,s)=>{const a=pe(i);a.remainder=()=>(a.releaseLock(),xr(i,s),e),r=t(a)}));return r}function Qr(n){if(gt(n))return n.clone();if(vt(n)){const t=(function(r){if(gt(r))throw Error("ArrayStream cannot be tee()d, use clone() instead");if(vt(r)){const e=Wn(r).tee();return e[0][ct]=e[1][ct]=r[ct],e}return[Qt(r),Qt(r)]})(n);return qc(n,t[0]),t[1]}return Qt(n)}function On(n){return gt(n)?Qr(n):vt(n)?new ReadableStream({start(t){const r=Ye(n,(async(e,i)=>{const s=pe(e),a=te(i);try{for(;;){await a.ready;const{done:o,value:c}=await s.read();if(o){try{t.close()}catch{}return void await a.close()}try{t.enqueue(c)}catch{}await a.write(c)}}catch(o){t.error(o),await a.abort(o)}}));qc(n,r)}}):Qt(n)}function qc(n,t){Object.entries(Object.getOwnPropertyDescriptors(n.constructor.prototype)).forEach((([r,e])=>{r!=="constructor"&&(e.value?e.value=e.value.bind(t):e.get=e.get.bind(t),Object.defineProperty(n,r,e))}))}function Qt(n,t=0,r=1/0){if(gt(n))throw Error("Not implemented");if(vt(n)){if(t>=0&&r>=0){let e,i=0;return new ReadableStream({start(){e=n.getReader()},async pull(s){try{for(;;){if(!(i<r))return s.close(),void n.releaseLock();{const{value:a,done:o}=await e.read();if(o)return s.close(),void n.releaseLock();let c;if(i+a.length>=t&&(c=Qt(a,Math.max(t-i,0),r-i)),i+=a.length,c)return void s.enqueue(c)}}}catch(a){s.error(a)}},async cancel(s){await e.cancel(s)}},{highWaterMark:0})}if(t<0&&(r<0||r===1/0)){let e=[];return Et(n,(i=>{i.length>=-t?e=[i]:e.push(i)}),(()=>Qt(Ft(e),t,r)))}if(t===0&&r<0){let e;return Et(n,(i=>{const s=e?Ft([e,i]):i;if(s.length>=-r)return e=Qt(s,r),Qt(s,t,r);e=s}))}return console.warn(`stream.slice(input, ${t}, ${r}) not implemented efficiently.`),wr((async()=>Qt(await mt(n),t,r)))}return n[ct]&&(n=Ft(n[ct].concat([n]))),Xi(n)?n.subarray(t,r===1/0?n.length:r):n.slice(t,r)}async function mt(n,t=Ft){return gt(n)?n.readToEnd(t):vt(n)?pe(n).readToEnd(t):n}async function Ws(n,t){if(vt(n)){if(n.cancel){const r=await n.cancel(t);return await new Promise((e=>setTimeout(e))),r}if(n.destroy)return n.destroy(t),await new Promise((r=>setTimeout(r))),t}}function wr(n){const t=new ie;return(async()=>{const r=te(t);try{await r.write(await n()),await r.close()}catch(e){await r.abort(e)}})(),t}function pe(n){return new me(n)}function te(n){return new Un(n)}me.prototype.read=async function(){return this[ct]&&this[ct].length?{done:!1,value:this[ct].shift()}:this._read()},me.prototype.releaseLock=function(){this[ct]&&(this.stream[ct]=this[ct]),this._releaseLock()},me.prototype.cancel=function(n){return this._cancel(n)},me.prototype.readLine=async function(){let n,t=[];for(;!n;){let{done:r,value:e}=await this.read();if(e+="",r)return t.length?Ft(t):void 0;const i=e.indexOf(`
`)+1;i&&(n=Ft(t.concat(e.substr(0,i))),t=[]),i!==e.length&&t.push(e.substr(i))}return this.unshift(...t),n},me.prototype.readByte=async function(){const{done:n,value:t}=await this.read();if(n)return;const r=t[0];return this.unshift(Qt(t,1)),r},me.prototype.readBytes=async function(n){const t=[];let r=0;for(;;){const{done:e,value:i}=await this.read();if(e)return t.length?Ft(t):void 0;if(t.push(i),r+=i.length,r>=n){const s=Ft(t);return this.unshift(Qt(s,n)),Qt(s,0,n)}}},me.prototype.peekBytes=async function(n){const t=await this.readBytes(n);return this.unshift(t),t},me.prototype.unshift=function(...n){this[ct]||(this[ct]=[]),n.length===1&&Xi(n[0])&&this[ct].length&&n[0].length&&this[ct][0].byteOffset>=n[0].length?this[ct][0]=new Uint8Array(this[ct][0].buffer,this[ct][0].byteOffset-n[0].length,this[ct][0].byteLength+n[0].length):this[ct].unshift(...n.filter((t=>t&&t.length)))},me.prototype.readToEnd=async function(n=Ft){const t=[];for(;;){const{done:r,value:e}=await this.read();if(r)break;t.push(e)}return n(t)};const mn=Symbol("byValue");var f={curve:{nistP256:"nistP256",p256:"nistP256",nistP384:"nistP384",p384:"nistP384",nistP521:"nistP521",p521:"nistP521",secp256k1:"secp256k1",ed25519Legacy:"ed25519Legacy",ed25519:"ed25519Legacy",curve25519Legacy:"curve25519Legacy",curve25519:"curve25519Legacy",brainpoolP256r1:"brainpoolP256r1",brainpoolP384r1:"brainpoolP384r1",brainpoolP512r1:"brainpoolP512r1"},s2k:{simple:0,salted:1,iterated:3,argon2:4,gnu:101},publicKey:{rsaEncryptSign:1,rsaEncrypt:2,rsaSign:3,elgamal:16,dsa:17,ecdh:18,ecdsa:19,eddsaLegacy:22,aedh:23,aedsa:24,x25519:25,x448:26,ed25519:27,ed448:28},symmetric:{idea:1,tripledes:2,cast5:3,blowfish:4,aes128:7,aes192:8,aes256:9,twofish:10},compression:{uncompressed:0,zip:1,zlib:2,bzip2:3},hash:{md5:1,sha1:2,ripemd:3,sha256:8,sha384:9,sha512:10,sha224:11,sha3_256:12,sha3_512:14},webHash:{"SHA-1":2,"SHA-256":8,"SHA-384":9,"SHA-512":10},aead:{eax:1,ocb:2,gcm:3,experimentalGCM:100},packet:{publicKeyEncryptedSessionKey:1,signature:2,symEncryptedSessionKey:3,onePassSignature:4,secretKey:5,publicKey:6,secretSubkey:7,compressedData:8,symmetricallyEncryptedData:9,marker:10,literalData:11,trust:12,userID:13,publicSubkey:14,userAttribute:17,symEncryptedIntegrityProtectedData:18,modificationDetectionCode:19,aeadEncryptedData:20,padding:21},literal:{binary:98,text:116,utf8:117,mime:109},signature:{binary:0,text:1,standalone:2,certGeneric:16,certPersona:17,certCasual:18,certPositive:19,certRevocation:48,subkeyBinding:24,keyBinding:25,key:31,keyRevocation:32,subkeyRevocation:40,timestamp:64,thirdParty:80},signatureSubpacket:{signatureCreationTime:2,signatureExpirationTime:3,exportableCertification:4,trustSignature:5,regularExpression:6,revocable:7,keyExpirationTime:9,placeholderBackwardsCompatibility:10,preferredSymmetricAlgorithms:11,revocationKey:12,issuerKeyID:16,notationData:20,preferredHashAlgorithms:21,preferredCompressionAlgorithms:22,keyServerPreferences:23,preferredKeyServer:24,primaryUserID:25,policyURI:26,keyFlags:27,signersUserID:28,reasonForRevocation:29,features:30,signatureTarget:31,embeddedSignature:32,issuerFingerprint:33,preferredAEADAlgorithms:34,preferredCipherSuites:39},keyFlags:{certifyKeys:1,signData:2,encryptCommunication:4,encryptStorage:8,splitPrivateKey:16,authentication:32,sharedPrivateKey:128},armor:{multipartSection:0,multipartLast:1,signed:2,message:3,publicKey:4,privateKey:5,signature:6},reasonForRevocation:{noReason:0,keySuperseded:1,keyCompromised:2,keyRetired:3,userIDInvalid:32},features:{modificationDetection:1,aead:2,v5Keys:4,seipdv2:8},write:function(n,t){if(typeof t=="number"&&(t=this.read(n,t)),n[t]!==void 0)return n[t];throw Error("Invalid enum value.")},read:function(n,t){if(n[mn]||(n[mn]=[],Object.entries(n).forEach((([r,e])=>{n[mn][e]=r}))),n[mn][t]!==void 0)return n[mn][t];throw Error("Invalid enum value.")}},G={preferredHashAlgorithm:f.hash.sha512,preferredSymmetricAlgorithm:f.symmetric.aes256,preferredCompressionAlgorithm:f.compression.uncompressed,aeadProtect:!1,parseAEADEncryptedV4KeysAsLegacy:!1,preferredAEADAlgorithm:f.aead.gcm,aeadChunkSizeByte:12,v6Keys:!1,enableParsingV5Entities:!1,s2kType:f.s2k.iterated,s2kIterationCountByte:224,s2kArgon2Params:{passes:3,parallelism:4,memoryExponent:16},allowUnauthenticatedMessages:!1,allowUnauthenticatedStream:!1,minRSABits:2047,passwordCollisionCheck:!1,allowInsecureDecryptionWithSigningKeys:!1,allowInsecureVerificationWithReformattedKeys:!1,allowMissingKeyFlags:!1,constantTimePKCS1Decryption:!1,constantTimePKCS1DecryptionSupportedSymmetricAlgorithms:new Set([f.symmetric.aes128,f.symmetric.aes192,f.symmetric.aes256]),ignoreUnsupportedPackets:!0,ignoreMalformedPackets:!1,enforceGrammar:!0,additionalAllowedPackets:[],showVersion:!1,showComment:!1,versionString:"OpenPGP.js 6.3.0",commentString:"https://openpgpjs.org",maxUserIDLength:5120,maxDecompressedMessageSize:1/0,knownNotations:[],nonDeterministicSignaturesViaNotation:!0,useEllipticFallback:!0,rejectHashAlgorithms:new Set([f.hash.md5,f.hash.ripemd]),rejectMessageHashAlgorithms:new Set([f.hash.md5,f.hash.ripemd,f.hash.sha1]),rejectPublicKeyAlgorithms:new Set([f.publicKey.elgamal,f.publicKey.dsa]),rejectCurves:new Set([f.curve.secp256k1])};const oo=(()=>{try{return!1}catch{}return!1})(),d={isString:function(n){return typeof n=="string"||n instanceof String},nodeRequire:()=>{},isArray:function(n){return n instanceof Array},isUint8Array:Xi,isStream:vt,getNobleCurve:async(n,t)=>{if(!G.useEllipticFallback)throw Error("This curve is only supported in the full build of OpenPGP.js");const{nobleCurves:r}=await Promise.resolve().then((function(){return qh}));switch(n){case f.publicKey.ecdh:case f.publicKey.ecdsa:{const e=r.get(t);if(!e)throw Error("Unsupported curve");return e}case f.publicKey.x448:return r.get("x448");case f.publicKey.ed448:return r.get("ed448");default:throw Error("Unsupported curve")}},readNumber:function(n){let t=0;for(let r=0;r<n.length;r++)t+=256**r*n[n.length-1-r];return t},writeNumber:function(n,t){const r=new Uint8Array(t);for(let e=0;e<t;e++)r[e]=n>>8*(t-e-1)&255;return r},readDate:function(n){const t=d.readNumber(n);return new Date(1e3*t)},writeDate:function(n){const t=Math.floor(n.getTime()/1e3);return d.writeNumber(t,4)},normalizeDate:function(n=Date.now()){return n===null||n===1/0?n:new Date(1e3*Math.floor(+n/1e3))},readMPI:function(n){const t=(n[0]<<8|n[1])+7>>>3;return d.readExactSubarray(n,2,2+t)},readExactSubarray:function(n,t,r){if(n.length<r-t)throw Error("Input array too short");return n.subarray(t,r)},leftPad(n,t){if(n.length>t)throw Error("Input array too long");const r=new Uint8Array(t),e=t-n.length;return r.set(n,e),r},uint8ArrayToMPI:function(n){const t=d.uint8ArrayBitLength(n);if(t===0)throw Error("Zero MPI");const r=n.subarray(n.length-Math.ceil(t/8)),e=new Uint8Array([(65280&t)>>8,255&t]);return d.concatUint8Array([e,r])},uint8ArrayBitLength:function(n){let t;for(t=0;t<n.length&&n[t]===0;t++);if(t===n.length)return 0;const r=n.subarray(t);return 8*(r.length-1)+d.nbits(r[0])},hexToUint8Array:function(n){const t=new Uint8Array(n.length>>1);for(let r=0;r<n.length>>1;r++)t[r]=parseInt(n.substr(r<<1,2),16);return t},uint8ArrayToHex:function(n){const t="0123456789abcdef";let r="";return n.forEach((e=>{r+=t[e>>4]+t[15&e]})),r},stringToUint8Array:function(n){return Et(n,(t=>{if(!d.isString(t))throw Error("stringToUint8Array: Data must be in the form of a string");const r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r}))},uint8ArrayToString:function(n){const t=[],e=(n=new Uint8Array(n)).length;for(let i=0;i<e;i+=16384)t.push(String.fromCharCode.apply(String,n.subarray(i,i+16384<e?i+16384:e)));return t.join("")},encodeUTF8:function(n){const t=new TextEncoder("utf-8");function r(e,i=!1){return t.encode(e,{stream:!i})}return Et(n,r,(()=>r("",!0)))},decodeUTF8:function(n){const t=new TextDecoder("utf-8");function r(e,i=!1){return t.decode(e,{stream:!i})}return Et(n,r,(()=>r(new Uint8Array,!0)))},concat:Ft,concatUint8Array:zc,equalsUint8Array:function(n,t){if(!d.isUint8Array(n)||!d.isUint8Array(t))throw Error("Data must be in the form of a Uint8Array");if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++)if(n[r]!==t[r])return!1;return!0},findLastIndex:function(n,t){for(let r=n.length;r>=0;r--)if(t(n[r],r,n))return r;return-1},writeChecksum:function(n){let t=0;for(let r=0;r<n.length;r++)t=t+n[r]&65535;return d.writeNumber(t,2)},printDebug:function(n){oo&&console.log("[OpenPGP.js debug]",n)},printDebugError:function(n){oo&&console.error("[OpenPGP.js debug]",n)},nbits:function(n){let t=1,r=n>>>16;return r!==0&&(n=r,t+=16),r=n>>8,r!==0&&(n=r,t+=8),r=n>>4,r!==0&&(n=r,t+=4),r=n>>2,r!==0&&(n=r,t+=2),r=n>>1,r!==0&&(n=r,t+=1),t},double:function(n){const t=new Uint8Array(n.length),r=n.length-1;for(let e=0;e<r;e++)t[e]=n[e]<<1^n[e+1]>>7;return t[r]=n[r]<<1^135*(n[0]>>7),t},shiftRight:function(n,t){if(t)for(let r=n.length-1;r>=0;r--)n[r]>>=t,r>0&&(n[r]|=n[r-1]<<8-t);return n},getWebCrypto:function(){const n=Lt!==void 0&&Lt.crypto&&Lt.crypto.subtle||this.getNodeCrypto()?.webcrypto.subtle;if(!n)throw Error("The WebCrypto API is not available");return n},getNodeCrypto:function(){return this.nodeRequire("crypto")},getNodeZlib:function(){return this.nodeRequire("zlib")},getNodeBuffer:function(){return(this.nodeRequire("buffer")||{}).Buffer},getHardwareConcurrency:function(){return typeof navigator<"u"?navigator.hardwareConcurrency||1:this.nodeRequire("os").cpus().length},isEmailAddress:function(n){return d.isString(n)?/^[^\p{C}\p{Z}@<>\\]+@[^\p{C}\p{Z}@<>\\]+[^\p{C}\p{Z}\p{P}]$/u.test(n):!1},canonicalizeEOL:function(n){let t=!1;return Et(n,(r=>{let e;t&&(r=d.concatUint8Array([new Uint8Array([13]),r])),r[r.length-1]===13?(t=!0,r=r.subarray(0,-1)):t=!1;const i=[];for(let o=0;e=r.indexOf(10,o)+1,e;o=e)r[e-2]!==13&&i.push(e);if(!i.length)return r;const s=new Uint8Array(r.length+i.length);let a=0;for(let o=0;o<i.length;o++){const c=r.subarray(i[o-1]||0,i[o]);s.set(c,a),a+=c.length,s[a-1]=13,s[a]=10,a++}return s.set(r.subarray(i[i.length-1]||0),a),s}),(()=>t?new Uint8Array([13]):void 0))},nativeEOL:function(n){let t=!1;return Et(n,(r=>{let e;(r=t&&r[0]!==10?d.concatUint8Array([new Uint8Array([13]),r]):new Uint8Array(r))[r.length-1]===13?(t=!0,r=r.subarray(0,-1)):t=!1;let i=0;for(let s=0;s!==r.length;s=e){e=r.indexOf(13,s)+1,e||(e=r.length);const a=e-(r[e]===10?1:0);s&&r.copyWithin(i,s,a),i+=a-s}return r.subarray(0,i)}),(()=>t?new Uint8Array([13]):void 0))},removeTrailingSpaces:function(n){return n.split(`
`).map((t=>{let r=t.length-1;for(;r>=0&&(t[r]===" "||t[r]==="	"||t[r]==="\r");r--);return t.substr(0,r+1)})).join(`
`)},wrapError:function(n,t){if(!t)return n instanceof Error?n:Error(n);if(n instanceof Error){try{n.message+=": "+t.message,n.cause=t}catch{}return n}return Error(n+": "+t.message,{cause:t})},constructAllowedPackets:function(n){const t={};return n.forEach((r=>{if(!r.tag)throw Error("Invalid input: expected a packet class");t[r.tag]=r})),t},anyPromise:function(n){return new Promise(((t,r)=>{let e;Promise.all(n.map((async i=>{try{t(await i)}catch(s){e=s}}))).then((()=>{r(e)}))}))},selectUint8Array:function(n,t,r){const e=Math.max(t.length,r.length),i=new Uint8Array(e);let s=0;for(let a=0;a<i.length;a++)i[a]=t[a]&256-n|r[a]&255+n,s+=n&a<t.length|1-n&a<r.length;return i.subarray(0,s)},selectUint8:function(n,t,r){return t&256-n|r&255+n},isAES:function(n){return n===f.symmetric.aes128||n===f.symmetric.aes192||n===f.symmetric.aes256}},Es=d.getNodeBuffer();let Di,xi;function Oe(n){let t=new Uint8Array;return Et(n,(r=>{t=d.concatUint8Array([t,r]);const e=[],i=Math.floor(t.length/45),s=45*i,a=Di(t.subarray(0,s));for(let o=0;o<i;o++)e.push(a.substr(60*o,60)),e.push(`
`);return t=t.subarray(s),e.join("")}),(()=>t.length?Di(t)+`
`:""))}function Yc(n){let t="";return Et(n,(r=>{t+=r;let e=0;const i=[" ","	","\r",`
`];for(let o=0;o<i.length;o++){const c=i[o];for(let u=t.indexOf(c);u!==-1;u=t.indexOf(c,u+1))e++}let s=t.length;for(;s>0&&(s-e)%4!=0;s--)i.includes(t[s])&&e--;const a=xi(t.substr(0,s));return t=t.substr(s),a}),(()=>xi(t)))}function qt(n){return Yc(n.replace(/-/g,"+").replace(/_/g,"/"))}function xt(n,t){let r=Oe(n).replace(/[\r\n]/g,"");return r=r.replace(/[+]/g,"-").replace(/[/]/g,"_").replace(/[=]/g,""),r}function t3(n){const t=n.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);if(!t)throw Error("Unknown ASCII armor type");return/MESSAGE, PART \d+\/\d+/.test(t[1])?f.armor.multipartSection:/MESSAGE, PART \d+/.test(t[1])?f.armor.multipartLast:/SIGNED MESSAGE/.test(t[1])?f.armor.signed:/MESSAGE/.test(t[1])?f.armor.message:/PUBLIC KEY BLOCK/.test(t[1])?f.armor.publicKey:/PRIVATE KEY BLOCK/.test(t[1])?f.armor.privateKey:/SIGNATURE/.test(t[1])?f.armor.signature:void 0}function mr(n,t){let r="";return t.showVersion&&(r+="Version: "+t.versionString+`
`),t.showComment&&(r+="Comment: "+t.commentString+`
`),n&&(r+="Comment: "+n+`
`),r+=`
`,r}function br(n){const t=(function(r){let e=13501623;return Et(r,(i=>{const s=e3?Math.floor(i.length/4):0,a=new Uint32Array(i.buffer,i.byteOffset,s);for(let o=0;o<s;o++)e^=a[o],e=Ut[0][e>>24&255]^Ut[1][e>>16&255]^Ut[2][e>>8&255]^Ut[3][255&e];for(let o=4*s;o<i.length;o++)e=e>>8^Ut[0][255&e^i[o]]}),(()=>new Uint8Array([e,e>>8,e>>16])))})(n);return Oe(t)}Es?(Di=n=>Es.from(n).toString("base64"),xi=n=>{const t=Es.from(n,"base64");return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}):(Di=n=>btoa(d.uint8ArrayToString(n)),xi=n=>d.stringToUint8Array(atob(n)));const Ut=[Array(255),Array(255),Array(255),Array(255)];for(let n=0;n<=255;n++){let t=n<<16;for(let r=0;r<8;r++)t=t<<1^(8388608&t?8801531:0);Ut[0][n]=(16711680&t)>>16|65280&t|(255&t)<<16}for(let n=0;n<=255;n++)Ut[1][n]=Ut[0][n]>>8^Ut[0][255&Ut[0][n]];for(let n=0;n<=255;n++)Ut[2][n]=Ut[1][n]>>8^Ut[0][255&Ut[1][n]];for(let n=0;n<=255;n++)Ut[3][n]=Ut[2][n]>>8^Ut[0][255&Ut[2][n]];const e3=(function(){const n=new ArrayBuffer(2);return new DataView(n).setInt16(0,255,!0),new Int16Array(n)[0]===255})();function co(n){for(let t=0;t<n.length;t++)/^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(n[t])||d.printDebugError(Error("Improperly formatted armor header: "+n[t])),/^(Version|Comment|MessageID|Hash|Charset): .+$/.test(n[t])||d.printDebugError(Error("Unknown header: "+n[t]))}function r3(n){let t=n;const r=n.lastIndexOf("=");return r>=0&&r!==n.length-1&&(t=n.slice(0,r)),t}function Ze(n){return new Promise(((t,r)=>{try{const e=/^-----[^-]+-----$/m,i=/^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;let s;const a=[];let o,c,u=a,h=[];const l=Yc(Ye(n,(async(y,g)=>{const p=pe(y);try{for(;;){let w=await p.readLine();if(w===void 0)throw Error("Misformed armored text");if(w=d.removeTrailingSpaces(w.replace(/[\r\n]/g,"")),s)if(o)c||s!==f.armor.signed||(e.test(w)?(h=h.join(`\r
`),c=!0,co(u),u=[],o=!1):h.push(w.replace(/^- /,"")));else if(e.test(w)&&r(Error("Mandatory blank line missing between armor headers and armor data")),i.test(w)){if(co(u),o=!0,c||s!==f.armor.signed){t({text:h,data:l,headers:a,type:s});break}}else u.push(w);else e.test(w)&&(s=t3(w))}}catch(w){return void r(w)}const A=te(g);try{for(;;){await A.ready;const{done:w,value:b}=await p.read();if(w)throw Error("Misformed armored text");const v=b+"";if(v.indexOf("=")!==-1||v.indexOf("-")!==-1){let k=await p.readToEnd();k.length||(k=""),k=v+k,k=d.removeTrailingSpaces(k.replace(/\r/g,""));const m=k.split(e);if(m.length===1)throw Error("Misformed armored text");const C=r3(m[0].slice(0,-1));await A.write(C);break}await A.write(v)}await A.ready,await A.close()}catch(w){await A.abort(w)}})))}catch(e){r(e)}})).then((async t=>(gt(t.data)&&(t.data=await mt(t.data)),t)))}function gn(n,t,r,e,i,s=!1,a=G){let o,c;n===f.armor.signed&&(o=t.text,c=t.hash,t=t.data);const u=s&&On(t),h=[];switch(n){case f.armor.multipartSection:h.push("-----BEGIN PGP MESSAGE, PART "+r+"/"+e+`-----
`),h.push(mr(i,a)),h.push(Oe(t)),u&&h.push("=",br(u)),h.push("-----END PGP MESSAGE, PART "+r+"/"+e+`-----
`);break;case f.armor.multipartLast:h.push("-----BEGIN PGP MESSAGE, PART "+r+`-----
`),h.push(mr(i,a)),h.push(Oe(t)),u&&h.push("=",br(u)),h.push("-----END PGP MESSAGE, PART "+r+`-----
`);break;case f.armor.signed:h.push(`-----BEGIN PGP SIGNED MESSAGE-----
`),h.push(c?`Hash: ${c}

`:`
`),h.push(o.replace(/^-/gm,"- -")),h.push(`
-----BEGIN PGP SIGNATURE-----
`),h.push(mr(i,a)),h.push(Oe(t)),u&&h.push("=",br(u)),h.push(`-----END PGP SIGNATURE-----
`);break;case f.armor.message:h.push(`-----BEGIN PGP MESSAGE-----
`),h.push(mr(i,a)),h.push(Oe(t)),u&&h.push("=",br(u)),h.push(`-----END PGP MESSAGE-----
`);break;case f.armor.publicKey:h.push(`-----BEGIN PGP PUBLIC KEY BLOCK-----
`),h.push(mr(i,a)),h.push(Oe(t)),u&&h.push("=",br(u)),h.push(`-----END PGP PUBLIC KEY BLOCK-----
`);break;case f.armor.privateKey:h.push(`-----BEGIN PGP PRIVATE KEY BLOCK-----
`),h.push(mr(i,a)),h.push(Oe(t)),u&&h.push("=",br(u)),h.push(`-----END PGP PRIVATE KEY BLOCK-----
`);break;case f.armor.signature:h.push(`-----BEGIN PGP SIGNATURE-----
`),h.push(mr(i,a)),h.push(Oe(t)),u&&h.push("=",br(u)),h.push(`-----END PGP SIGNATURE-----
`)}return d.concat(h)}const Zt=BigInt(0),en=BigInt(1);function Z(n){const t="0123456789ABCDEF";let r="";return n.forEach((e=>{r+=t[e>>4]+t[15&e]})),BigInt("0x0"+r)}function tt(n,t){const r=n%t;return r<Zt?r+t:r}function Pt(n,t,r){if(r===Zt)throw Error("Modulo cannot be zero");if(r===en)return BigInt(0);if(t<Zt)throw Error("Unsopported negative exponent");let e=t,i=n;i%=r;let s=BigInt(1);for(;e>Zt;){const a=e&en;e>>=en,s=a?s*i%r:s,i=i*i%r}return s}function uo(n){return n>=Zt?n:-n}function sn(n,t){const{gcd:r,x:e}=(function(i,s){let a=BigInt(0),o=BigInt(1),c=BigInt(1),u=BigInt(0),h=uo(i),l=uo(s);const y=i<Zt,g=s<Zt;for(;l!==Zt;){const p=h/l;let A=a;a=c-p*a,c=A,A=o,o=u-p*o,u=A,A=l,l=h%l,h=A}return{x:y?-c:c,y:g?-u:u,gcd:h}})(n,t);if(r!==en)throw Error("Inverse does not exist");return tt(e+t,t)}function _s(n){const t=Number(n);if(t>Number.MAX_SAFE_INTEGER)throw Error("Number can only safely store up to 53 bits");return t}function n3(n,t){return(n>>BigInt(t)&en)===Zt?0:1}function rn(n){const t=n<Zt?BigInt(-1):Zt;let r=1,e=n;for(;(e>>=en)!==t;)r++;return r}function Jt(n){const t=n<Zt?BigInt(-1):Zt,r=BigInt(8);let e=1,i=n;for(;(i>>=r)!==t;)e++;return e}function kt(n,t="be",r){let e=n.toString(16);e.length%2==1&&(e="0"+e);const i=e.length/2,s=new Uint8Array(r||i),a=r?r-i:0;let o=0;for(;o<i;)s[o+a]=parseInt(e.slice(2*o,2*o+2),16),o++;return t!=="be"&&s.reverse(),s}const i3=d.getNodeCrypto();function Dt(n){const t=typeof crypto<"u"?crypto:i3?.webcrypto;if(t?.getRandomValues){const r=new Uint8Array(n);return t.getRandomValues(r)}throw Error("No secure random number generator available.")}function lr(n,t){if(t<n)throw Error("Illegal parameter value: max <= min");const r=t-n;return tt(Z(Dt(Jt(r)+8)),r)+n}const ke=BigInt(1);function ho(n,t,r){const e=BigInt(30),i=ke<<BigInt(n-1),s=[1,6,5,4,3,2,1,4,3,2,1,2,1,4,3,2,1,2,1,4,3,2,1,6,5,4,3,2,1,2];let a=lr(i,i<<ke),o=_s(tt(a,e));do a+=BigInt(s[o]),o=(o+s[o])%s.length,rn(a)>n&&(a=tt(a,i<<ke),a+=i,o=_s(tt(a,e)));while(!Zc(a,t,r));return a}function Zc(n,t,r){return(!t||(function(e,i){let s=e,a=i;for(;a!==Zt;){const o=a;a=s%a,s=o}return s})(n-ke,t)===ke)&&!!(function(e){const i=BigInt(0);return s3.every((s=>tt(e,s)!==i))})(n)&&!!(function(e,i=BigInt(2)){return Pt(i,e-ke,e)===ke})(n)&&!!(function(e,i){const s=rn(e);i||(i=Math.max(1,s/48|0));const a=e-ke;let o=0;for(;!n3(a,o);)o++;const c=e>>BigInt(o);for(;i>0;i--){let u,h=Pt(lr(BigInt(2),a),c,e);if(h!==ke&&h!==a){for(u=1;u<o;u++){if(h=tt(h*h,e),h===ke)return!1;if(h===a)break}if(u===o)return!1}}return!0})(n,r)}const s3=[7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999].map((n=>BigInt(n))),fo=d.getWebCrypto(),Qi=d.getNodeCrypto(),a3=Qi&&Qi.getHashes();function Je(n){if(Qi&&a3.includes(n))return async function(t){const r=Qi.createHash(n);return Et(t,(e=>{r.update(e)}),(()=>new Uint8Array(r.digest())))}}function Xe(n,t){const r=async()=>{const{nobleHashes:e}=await Promise.resolve().then((function(){return o5})),i=e.get(n);if(!i)throw Error("Unsupported hash");return i};return async function(e){if(gt(e)&&(e=await mt(e)),d.isStream(e)){const i=(await r()).create();return Et(e,(s=>{i.update(s)}),(()=>i.digest()))}return fo&&t?new Uint8Array(await fo.digest(t,e)):(await r())(e)}}const o3=Je("md5")||Xe("md5"),c3=Je("sha1")||Xe("sha1","SHA-1"),u3=Je("sha224")||Xe("sha224"),h3=Je("sha256")||Xe("sha256","SHA-256"),f3=Je("sha384")||Xe("sha384","SHA-384"),l3=Je("sha512")||Xe("sha512","SHA-512"),y3=Je("ripemd160")||Xe("ripemd160"),g3=Je("sha3-256")||Xe("sha3_256"),p3=Je("sha3-512")||Xe("sha3_512");function Qe(n,t){switch(n){case f.hash.md5:return o3(t);case f.hash.sha1:return c3(t);case f.hash.ripemd:return y3(t);case f.hash.sha256:return h3(t);case f.hash.sha384:return f3(t);case f.hash.sha512:return l3(t);case f.hash.sha224:return u3(t);case f.hash.sha3_256:return g3(t);case f.hash.sha3_512:return p3(t);default:throw Error("Unsupported hash function")}}function It(n){switch(n){case f.hash.md5:return 16;case f.hash.sha1:case f.hash.ripemd:return 20;case f.hash.sha256:return 32;case f.hash.sha384:return 48;case f.hash.sha512:return 64;case f.hash.sha224:return 28;case f.hash.sha3_256:return 32;case f.hash.sha3_512:return 64;default:throw Error("Invalid hash algorithm.")}}const Ee=[];function Jc(n,t){const r=n.length;if(r>t-11)throw Error("Message too long");const e=(function(s){const a=new Uint8Array(s);let o=0;for(;o<s;){const c=Dt(s-o);for(let u=0;u<c.length;u++)c[u]!==0&&(a[o++]=c[u])}return a})(t-r-3),i=new Uint8Array(t);return i[1]=2,i.set(e,2),i.set(n,t-r),i}function Xc(n,t){let r=2,e=1;for(let o=r;o<n.length;o++)e&=n[o]!==0,r+=e;const i=r-2,s=n.subarray(r+1),a=n[0]===0&n[1]===2&i>=8&!e;if(t)return d.selectUint8Array(a,s,t);if(a)return s;throw Error("Decryption error")}function Wc(n,t,r){let e;if(t.length!==It(n))throw Error("Invalid hash length");const i=new Uint8Array(Ee[n].length);for(e=0;e<Ee[n].length;e++)i[e]=Ee[n][e];const s=i.length+t.length;if(r<s+11)throw Error("Intended encoded message length too short");const a=new Uint8Array(r-s-3).fill(255),o=new Uint8Array(r);return o[1]=1,o.set(a,2),o.set(i,r-s),o.set(t,r-t.length),o}Ee[1]=[48,32,48,12,6,8,42,134,72,134,247,13,2,5,5,0,4,16],Ee[2]=[48,33,48,9,6,5,43,14,3,2,26,5,0,4,20],Ee[3]=[48,33,48,9,6,5,43,36,3,2,1,5,0,4,20],Ee[8]=[48,49,48,13,6,9,96,134,72,1,101,3,4,2,1,5,0,4,32],Ee[9]=[48,65,48,13,6,9,96,134,72,1,101,3,4,2,2,5,0,4,48],Ee[10]=[48,81,48,13,6,9,96,134,72,1,101,3,4,2,3,5,0,4,64],Ee[11]=[48,45,48,13,6,9,96,134,72,1,101,3,4,2,4,5,0,4,28];const an=d.getWebCrypto(),Mr=d.getNodeCrypto(),gr=BigInt(1);async function d3(n,t,r,e,i,s,a,o,c){if(It(n)>=r.length)throw Error("Digest size cannot exceed key modulus size");if(t&&!d.isStream(t)){if(d.getWebCrypto())try{return await(async function(u,h,l,y,g,p,A,w){const b=$s(l,y,g,p,A,w),v={name:"RSASSA-PKCS1-v1_5",hash:{name:u}},k=await an.importKey("jwk",b,v,!1,["sign"]);return new Uint8Array(await an.sign("RSASSA-PKCS1-v1_5",k,h))})(f.read(f.webHash,n),t,r,e,i,s,a,o)}catch(u){d.printDebugError(u)}else if(d.getNodeCrypto())return(function(u,h,l,y,g,p,A,w){const b=Mr.createSign(f.read(f.hash,u));b.write(h),b.end();const v=$s(l,y,g,p,A,w);return new Uint8Array(b.sign({key:v,format:"jwk",type:"pkcs1"}))})(n,t,r,e,i,s,a,o)}return(function(u,h,l,y){h=Z(h);const g=Z(Wc(u,y,Jt(h)));return l=Z(l),kt(Pt(g,l,h),"be",Jt(h))})(n,r,i,c)}async function A3(n,t,r,e,i,s){if(t&&!d.isStream(t)){if(d.getWebCrypto())try{return await(async function(a,o,c,u,h){const l=ta(u,h),y=await an.importKey("jwk",l,{name:"RSASSA-PKCS1-v1_5",hash:{name:a}},!1,["verify"]);return an.verify("RSASSA-PKCS1-v1_5",y,c,o)})(f.read(f.webHash,n),t,r,e,i)}catch(a){d.printDebugError(a)}else if(d.getNodeCrypto())return(function(a,o,c,u,h){const l=ta(u,h),y={key:l,format:"jwk",type:"pkcs1"},g=Mr.createVerify(f.read(f.hash,a));g.write(o),g.end();try{return g.verify(y,c)}catch{return!1}})(n,t,r,e,i)}return(function(a,o,c,u,h){if(c=Z(c),o=Z(o),u=Z(u),o>=c)throw Error("Signature size cannot exceed modulus size");const l=kt(Pt(o,u,c),"be",Jt(c)),y=Wc(a,h,Jt(c));return d.equalsUint8Array(l,y)})(n,r,e,i,s)}async function w3(n,t,r){return d.getNodeCrypto()?(function(e,i,s){const a=ta(i,s),o={key:a,format:"jwk",type:"pkcs1",padding:Mr.constants.RSA_PKCS1_PADDING};return new Uint8Array(Mr.publicEncrypt(o,e))})(n,t,r):(function(e,i,s){if(i=Z(i),e=Z(Jc(e,Jt(i))),s=Z(s),e>=i)throw Error("Message size cannot exceed modulus size");return kt(Pt(e,s,i),"be",Jt(i))})(n,t,r)}async function m3(n,t,r,e,i,s,a,o){if(d.getNodeCrypto()&&!o)try{return(function(c,u,h,l,y,g,p){const A=$s(u,h,l,y,g,p),w={key:A,format:"jwk",type:"pkcs1",padding:Mr.constants.RSA_PKCS1_PADDING};try{return new Uint8Array(Mr.privateDecrypt(w,c))}catch{throw Error("Decryption error")}})(n,t,r,e,i,s,a)}catch(c){d.printDebugError(c)}return(function(c,u,h,l,y,g,p,A){if(c=Z(c),u=Z(u),h=Z(h),l=Z(l),y=Z(y),g=Z(g),p=Z(p),c>=u)throw Error("Data too large.");const w=tt(l,g-gr),b=tt(l,y-gr),v=lr(BigInt(2),u),k=Pt(sn(v,u),h,u);c=tt(c*k,u);const m=Pt(c,b,y),C=Pt(c,w,g);let P=tt(p*(C-m),g)*y+m;return P=tt(P*v,u),Xc(kt(P,"be",Jt(u)),A)})(n,t,r,e,i,s,a,o)}function $s(n,t,r,e,i,s){const a=Z(e),o=Z(i),c=Z(r);let u=tt(c,o-gr),h=tt(c,a-gr);return h=kt(h),u=kt(u),{kty:"RSA",n:xt(n),e:xt(t),d:xt(r),p:xt(i),q:xt(e),dp:xt(u),dq:xt(h),qi:xt(s),ext:!0}}function ta(n,t){return{kty:"RSA",n:xt(n),e:xt(t),ext:!0}}function lo(n,t){return{n:qt(n.n),e:kt(t),d:qt(n.d),p:qt(n.q),q:qt(n.p),u:qt(n.qi)}}const or=BigInt(1),b3={"2a8648ce3d030107":f.curve.nistP256,"2b81040022":f.curve.nistP384,"2b81040023":f.curve.nistP521,"2b8104000a":f.curve.secp256k1,"2b06010401da470f01":f.curve.ed25519Legacy,"2b060104019755010501":f.curve.curve25519Legacy,"2b2403030208010107":f.curve.brainpoolP256r1,"2b240303020801010b":f.curve.brainpoolP384r1,"2b240303020801010d":f.curve.brainpoolP512r1};class je{constructor(t){if(t instanceof je)this.oid=t.oid;else if(d.isArray(t)||d.isUint8Array(t)){if((t=new Uint8Array(t))[0]===6){if(t[1]!==t.length-2)throw Error("Length mismatch in DER encoded oid");t=t.subarray(2)}this.oid=t}else this.oid=""}read(t){if(t.length>=1){const r=t[0];if(t.length>=1+r)return this.oid=t.subarray(1,1+r),1+this.oid.length}throw Error("Invalid oid")}write(){return d.concatUint8Array([new Uint8Array([this.oid.length]),this.oid])}toHex(){return d.uint8ArrayToHex(this.oid)}getName(){const t=b3[this.toHex()];if(!t)throw Error("Unknown curve object identifier.");return t}}function _c(n){let t,r=0;const e=n[0];return e<192?([r]=n,t=1):e<255?(r=(n[0]-192<<8)+n[1]+192,t=2):e===255&&(r=d.readNumber(n.subarray(1,5)),t=5),{len:r,offset:t}}function _i(n){return n<192?new Uint8Array([n]):n>191&&n<8384?new Uint8Array([192+(n-192>>8),n-192&255]):d.concatUint8Array([new Uint8Array([255]),d.writeNumber(n,4)])}function k3(n){if(n<0||n>30)throw Error("Partial Length power must be between 1 and 30");return new Uint8Array([224+n])}function Mi(n){return new Uint8Array([192|n])}function yo(n,t){return d.concatUint8Array([Mi(n),_i(t)])}function mi(n){return[f.packet.literalData,f.packet.compressedData,f.packet.symmetricallyEncryptedData,f.packet.symEncryptedIntegrityProtectedData,f.packet.aeadEncryptedData].includes(n)}async function E3(n,t,r){let e,i;try{const s=await n.peekBytes(2);if(!s||s.length<2||!(128&s[0]))throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");const a=await n.readByte();let o,c,u=-1,h=-1;h=0,64&a&&(h=1),h?u=63&a:(u=(63&a)>>2,c=3&a);const l=mi(u);let y,g=null;if(t&&l){if(t==="array"){const p=new ie;e=te(p),g=p}else{const p=new TransformStream;e=te(p.writable),g=p.readable}i=r({tag:u,packet:g})}else g=[];do{if(h){const p=await n.readByte();if(y=!1,p<192)o=p;else if(p>=192&&p<224)o=(p-192<<8)+await n.readByte()+192;else if(p>223&&p<255){if(o=1<<(31&p),y=!0,!l)throw new TypeError("This packet type does not support partial lengths.")}else o=await n.readByte()<<24|await n.readByte()<<16|await n.readByte()<<8|await n.readByte()}else switch(c){case 0:o=await n.readByte();break;case 1:o=await n.readByte()<<8|await n.readByte();break;case 2:o=await n.readByte()<<24|await n.readByte()<<16|await n.readByte()<<8|await n.readByte();break;default:o=1/0}if(o>0){let p=0;for(;;){e&&await e.ready;const{done:A,value:w}=await n.read();if(A){if(o===1/0)break;throw Error("Unexpected end of packet")}const b=o===1/0?w:w.subarray(0,o-p);if(e?await e.write(b):g.push(b),p+=w.length,p>=o){n.unshift(w.subarray(o-p+w.length));break}}}}while(y);e?(await e.ready,await e.close()):(g=d.concatUint8Array(g),await r({tag:u,packet:g}))}catch(s){if(e)return await e.abort(s),!0;throw s}finally{e&&await i}}class it extends Error{constructor(...t){super(...t),Error.captureStackTrace&&Error.captureStackTrace(this,it),this.name="UnsupportedError"}}class bi extends it{constructor(...t){super(...t),Error.captureStackTrace&&Error.captureStackTrace(this,it),this.name="UnknownPacketError"}}class vs extends it{constructor(...t){super(...t),Error.captureStackTrace&&Error.captureStackTrace(this,it),this.name="MalformedPacketError"}}class ea{constructor(t,r){this.tag=t,this.rawContent=r}write(){return this.rawContent}}async function Ma(n){switch(n){case f.publicKey.ed25519:try{const t=d.getWebCrypto(),r=await t.generateKey("Ed25519",!0,["sign","verify"]).catch((s=>{if(s.name==="OperationError"){const a=Error("Unexpected key generation issue");throw a.name="NotSupportedError",a}throw s})),e=await t.exportKey("jwk",r.privateKey),i=await t.exportKey("jwk",r.publicKey);return{A:new Uint8Array(qt(i.x)),seed:qt(e.d)}}catch(t){if(t.name!=="NotSupportedError")throw t;const{default:r}=await Promise.resolve().then((function(){return Hr})),e=Dt($i(n)),{publicKey:i}=r.sign.keyPair.fromSeed(e);return{A:i,seed:e}}case f.publicKey.ed448:{const t=await d.getNobleCurve(f.publicKey.ed448),{secretKey:r,publicKey:e}=t.keygen();return{A:e,seed:r}}default:throw Error("Unsupported EdDSA algorithm")}}async function Ra(n,t,r,e,i,s){if(It(t)<It(ts(n)))throw Error("Hash algorithm too weak for EdDSA.");switch(n){case f.publicKey.ed25519:try{const a=d.getWebCrypto(),o=$c(n,e,i),c=await a.importKey("jwk",o,"Ed25519",!1,["sign"]);return{RS:new Uint8Array(await a.sign("Ed25519",c,s))}}catch(a){if(a.name!=="NotSupportedError")throw a;const{default:o}=await Promise.resolve().then((function(){return Hr})),c=d.concatUint8Array([i,e]);return{RS:o.sign.detached(s,c)}}case f.publicKey.ed448:return{RS:(await d.getNobleCurve(f.publicKey.ed448)).sign(s,i)};default:throw Error("Unsupported EdDSA algorithm")}}async function Ta(n,t,{RS:r},e,i,s){if(It(t)<It(ts(n)))throw Error("Hash algorithm too weak for EdDSA.");switch(n){case f.publicKey.ed25519:try{const a=d.getWebCrypto(),o=La(n,i),c=await a.importKey("jwk",o,"Ed25519",!1,["verify"]);return await a.verify("Ed25519",c,r,s)}catch(a){if(a.name!=="NotSupportedError")throw a;const{default:o}=await Promise.resolve().then((function(){return Hr}));return o.sign.detached.verify(s,r,i)}case f.publicKey.ed448:return(await d.getNobleCurve(f.publicKey.ed448)).verify(r,s,i);default:throw Error("Unsupported EdDSA algorithm")}}async function Fa(n,t,r){switch(n){case f.publicKey.ed25519:try{const e=d.getWebCrypto(),i=$c(n,t,r),s=La(n,t),a=await e.importKey("jwk",i,"Ed25519",!1,["sign"]),o=await e.importKey("jwk",s,"Ed25519",!1,["verify"]),c=Dt(8),u=new Uint8Array(await e.sign("Ed25519",a,c));return await e.verify("Ed25519",o,u,c)}catch(e){if(e.name!=="NotSupportedError")return!1;const{default:i}=await Promise.resolve().then((function(){return Hr})),{publicKey:s}=i.sign.keyPair.fromSeed(r);return d.equalsUint8Array(t,s)}case f.publicKey.ed448:{const e=(await d.getNobleCurve(f.publicKey.ed448)).getPublicKey(r);return d.equalsUint8Array(t,e)}default:return!1}}function $i(n){switch(n){case f.publicKey.ed25519:return 32;case f.publicKey.ed448:return 57;default:throw Error("Unsupported EdDSA algorithm")}}function ts(n){switch(n){case f.publicKey.ed25519:return f.hash.sha256;case f.publicKey.ed448:return f.hash.sha512;default:throw Error("Unknown EdDSA algo")}}const La=(n,t)=>{if(n===f.publicKey.ed25519)return{kty:"OKP",crv:"Ed25519",x:xt(t),ext:!0};throw Error("Unsupported EdDSA algorithm")},$c=(n,t,r)=>{if(n===f.publicKey.ed25519){const e=La(n,t);return e.d=xt(r),e}throw Error("Unsupported EdDSA algorithm")};var v3=Object.freeze({__proto__:null,generate:Ma,getPayloadSize:$i,getPreferredHashAlgo:ts,sign:Ra,validateParams:Fa,verify:Ta});function t1(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function yt(n,...t){if(!t1(n))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw Error("Uint8Array expected of length "+t+", got length="+n.length)}function Ri(n,t=!0){if(n.destroyed)throw Error("Hash instance has been destroyed");if(t&&n.finished)throw Error("Hash#digest() has already been called")}function e1(n,t){yt(n);const r=t.outputLen;if(n.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}function Na(n){return new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}function ut(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function Nt(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function es(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}const I3=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function zn(n){if(typeof n=="string")n=(function(t){if(typeof t!="string")throw Error("string expected");return new Uint8Array(new TextEncoder().encode(t))})(n);else{if(!t1(n))throw Error("Uint8Array expected, got "+typeof n);n=Yt(n)}return n}function r1(n,t){return n.buffer===t.buffer&&n.byteOffset<t.byteOffset+t.byteLength&&t.byteOffset<n.byteOffset+n.byteLength}function ra(n,t){if(r1(n,t)&&n.byteOffset<t.byteOffset)throw Error("complex overlap of input and output is not supported")}function n1(n,t){if(n.length!==t.length)return!1;let r=0;for(let e=0;e<n.length;e++)r|=n[e]^t[e];return r===0}const _n=(n,t)=>{function r(e,...i){if(yt(e),!I3)throw Error("Non little-endian hardware is not yet supported");if(n.nonceLength!==void 0){const u=i[0];if(!u)throw Error("nonce / iv required");n.varSizeNonce?yt(u):yt(u,n.nonceLength)}const s=n.tagLength;s&&i[1]!==void 0&&yt(i[1]);const a=t(e,...i),o=(u,h)=>{if(h!==void 0){if(u!==2)throw Error("cipher output not supported");yt(h)}};let c=!1;return{encrypt(u,h){if(c)throw Error("cannot encrypt() twice with same key + nonce");return c=!0,yt(u),o(a.encrypt.length,h),a.encrypt(u,h)},decrypt(u,h){if(yt(u),s&&u.length<s)throw Error("invalid ciphertext length: smaller than tagLength="+s);return o(a.decrypt.length,h),a.decrypt(u,h)}}}return Object.assign(r,n),r};function Gn(n,t,r=!0){if(t===void 0)return new Uint8Array(n);if(t.length!==n)throw Error("invalid output length, expected "+n+", got: "+t.length);if(r&&!se(t))throw Error("invalid output, must be aligned");return t}function na(n,t,r,e){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,r,e);const i=BigInt(32),s=BigInt(4294967295),a=Number(r>>i&s),o=Number(r&s);n.setUint32(t+0,a,e),n.setUint32(t+4,o,e)}function se(n){return n.byteOffset%4==0}function Yt(n){return Uint8Array.from(n)}const He=16,Oa=new Uint8Array(16),Ie=ut(Oa),re=n=>(n>>>0&255)<<24|(n>>>8&255)<<16|(n>>>16&255)<<8|n>>>24&255;class i1{constructor(t,r){this.blockLen=He,this.outputLen=He,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,yt(t=zn(t),16);const e=es(t);let i=e.getUint32(0,!1),s=e.getUint32(4,!1),a=e.getUint32(8,!1),o=e.getUint32(12,!1);const c=[];for(let v=0;v<128;v++)c.push({s0:re(i),s1:re(s),s2:re(a),s3:re(o)}),{s0:i,s1:s,s2:a,s3:o}={s3:(l=a)<<31|(y=o)>>>1,s2:(h=s)<<31|l>>>1,s1:(u=i)<<31|h>>>1,s0:u>>>1^225<<24&-(1&y)};var u,h,l,y;const g=(p=r||1024)>65536?8:p>1024?4:2;var p;if(![1,2,4,8].includes(g))throw Error("ghash: invalid window size, expected 2, 4 or 8");this.W=g;const A=128/g,w=this.windowSize=2**g,b=[];for(let v=0;v<A;v++)for(let k=0;k<w;k++){let m=0,C=0,D=0,P=0;for(let S=0;S<g;S++){if(!(k>>>g-S-1&1))continue;const{s0:E,s1:K,s2:I,s3:B}=c[g*v+S];m^=E,C^=K,D^=I,P^=B}b.push({s0:m,s1:C,s2:D,s3:P})}this.t=b}_updateBlock(t,r,e,i){t^=this.s0,r^=this.s1,e^=this.s2,i^=this.s3;const{W:s,t:a,windowSize:o}=this;let c=0,u=0,h=0,l=0;const y=(1<<s)-1;let g=0;for(const p of[t,r,e,i])for(let A=0;A<4;A++){const w=p>>>8*A&255;for(let b=8/s-1;b>=0;b--){const v=w>>>s*b&y,{s0:k,s1:m,s2:C,s3:D}=a[g*o+v];c^=k,u^=m,h^=C,l^=D,g+=1}}this.s0=c,this.s1=u,this.s2=h,this.s3=l}update(t){Ri(this),yt(t=zn(t));const r=ut(t),e=Math.floor(t.length/He),i=t.length%He;for(let s=0;s<e;s++)this._updateBlock(r[4*s+0],r[4*s+1],r[4*s+2],r[4*s+3]);return i&&(Oa.set(t.subarray(e*He)),this._updateBlock(Ie[0],Ie[1],Ie[2],Ie[3]),Nt(Ie)),this}destroy(){const{t}=this;for(const r of t)r.s0=0,r.s1=0,r.s2=0,r.s3=0}digestInto(t){Ri(this),e1(t,this),this.finished=!0;const{s0:r,s1:e,s2:i,s3:s}=this,a=ut(t);return a[0]=r,a[1]=e,a[2]=i,a[3]=s,t}digest(){const t=new Uint8Array(He);return this.digestInto(t),this.destroy(),t}}class S3 extends i1{constructor(t,r){yt(t=zn(t));const e=(function(i){i.reverse();const s=1&i[15];let a=0;for(let o=0;o<i.length;o++){const c=i[o];i[o]=c>>>1|a,a=(1&c)<<7}return i[0]^=225&-s,i})(Yt(t));super(e,r),Nt(e)}update(t){t=zn(t),Ri(this);const r=ut(t),e=t.length%He,i=Math.floor(t.length/He);for(let s=0;s<i;s++)this._updateBlock(re(r[4*s+3]),re(r[4*s+2]),re(r[4*s+1]),re(r[4*s+0]));return e&&(Oa.set(t.subarray(i*He)),this._updateBlock(re(Ie[3]),re(Ie[2]),re(Ie[1]),re(Ie[0])),Nt(Ie)),this}digestInto(t){Ri(this),e1(t,this),this.finished=!0;const{s0:r,s1:e,s2:i,s3:s}=this,a=ut(t);return a[0]=r,a[1]=e,a[2]=i,a[3]=s,t.reverse()}}function s1(n){const t=(e,i)=>n(i,e.length).update(zn(e)).digest(),r=n(new Uint8Array(16),0);return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=(e,i)=>n(e,i),t}const go=s1(((n,t)=>new i1(n,t)));s1(((n,t)=>new S3(n,t)));const _t=16,si=new Uint8Array(_t);function Ha(n){return n<<1^283&-(n>>7)}function Jr(n,t){let r=0;for(;t>0;t>>=1)r^=n&-(1&t),n=Ha(n);return r}const ia=(()=>{const n=new Uint8Array(256);for(let r=0,e=1;r<256;r++,e^=Ha(e))n[r]=e;const t=new Uint8Array(256);t[0]=99;for(let r=0;r<255;r++){let e=n[255-r];e|=e<<8,t[n[r]]=255&(e^e>>4^e>>5^e>>6^e>>7^99)}return Nt(n),t})(),B3=ia.map(((n,t)=>ia.indexOf(t))),Is=n=>n<<8|n>>>24,po=n=>n<<24&4278190080|n<<8&16711680|n>>>8&65280|n>>>24&255;function a1(n,t){if(n.length!==256)throw Error("Wrong sbox length");const r=new Uint32Array(256).map(((u,h)=>t(n[h]))),e=r.map(Is),i=e.map(Is),s=i.map(Is),a=new Uint32Array(65536),o=new Uint32Array(65536),c=new Uint16Array(65536);for(let u=0;u<256;u++)for(let h=0;h<256;h++){const l=256*u+h;a[l]=r[u]^e[h],o[l]=i[u]^s[h],c[l]=n[u]<<8|n[h]}return{sbox:n,sbox2:c,T0:r,T1:e,T2:i,T3:s,T01:a,T23:o}}const za=a1(ia,(n=>Jr(n,3)<<24|n<<16|n<<8|Jr(n,2))),o1=a1(B3,(n=>Jr(n,11)<<24|Jr(n,13)<<16|Jr(n,9)<<8|Jr(n,14))),K3=(()=>{const n=new Uint8Array(16);for(let t=0,r=1;t<16;t++,r=Ha(r))n[t]=r;return n})();function Lr(n){yt(n);const t=n.length;if(![16,24,32].includes(t))throw Error("aes: invalid key size, should be 16, 24 or 32, got "+t);const{sbox2:r}=za,e=[];se(n)||e.push(n=Yt(n));const i=ut(n),s=i.length,a=u=>Be(r,u,u,u,u),o=new Uint32Array(t+28);o.set(i);for(let u=s;u<o.length;u++){let h=o[u-1];u%s==0?h=a((c=h)<<24|c>>>8)^K3[u/s-1]:s>6&&u%s==4&&(h=a(h)),o[u]=o[u-s]^h}var c;return Nt(...e),o}function Ga(n){const t=Lr(n),r=t.slice(),e=t.length,{sbox2:i}=za,{T0:s,T1:a,T2:o,T3:c}=o1;for(let u=0;u<e;u+=4)for(let h=0;h<4;h++)r[u+h]=t[e-u-4+h];Nt(t);for(let u=4;u<e-4;u++){const h=r[u],l=Be(i,h,h,h,h);r[u]=s[255&l]^a[l>>>8&255]^o[l>>>16&255]^c[l>>>24]}return r}function ur(n,t,r,e,i,s){return n[r<<8&65280|e>>>8&255]^t[i>>>8&65280|s>>>24&255]}function Be(n,t,r,e,i){return n[255&t|65280&r]|n[e>>>16&255|i>>>16&65280]<<16}function de(n,t,r,e,i){const{sbox2:s,T01:a,T23:o}=za;let c=0;t^=n[c++],r^=n[c++],e^=n[c++],i^=n[c++];const u=n.length/4-2;for(let h=0;h<u;h++){const l=n[c++]^ur(a,o,t,r,e,i),y=n[c++]^ur(a,o,r,e,i,t),g=n[c++]^ur(a,o,e,i,t,r),p=n[c++]^ur(a,o,i,t,r,e);t=l,r=y,e=g,i=p}return{s0:n[c++]^Be(s,t,r,e,i),s1:n[c++]^Be(s,r,e,i,t),s2:n[c++]^Be(s,e,i,t,r),s3:n[c++]^Be(s,i,t,r,e)}}function rs(n,t,r,e,i){const{sbox2:s,T01:a,T23:o}=o1;let c=0;t^=n[c++],r^=n[c++],e^=n[c++],i^=n[c++];const u=n.length/4-2;for(let h=0;h<u;h++){const l=n[c++]^ur(a,o,t,i,e,r),y=n[c++]^ur(a,o,r,t,i,e),g=n[c++]^ur(a,o,e,r,t,i),p=n[c++]^ur(a,o,i,e,r,t);t=l,r=y,e=g,i=p}return{s0:n[c++]^Be(s,t,i,e,r),s1:n[c++]^Be(s,r,t,i,e),s2:n[c++]^Be(s,e,r,t,i),s3:n[c++]^Be(s,i,e,r,t)}}function c1(n,t,r,e){yt(t,_t),yt(r);const i=r.length;ra(r,e=Gn(i,e));const s=t,a=ut(s);let{s0:o,s1:c,s2:u,s3:h}=de(n,a[0],a[1],a[2],a[3]);const l=ut(r),y=ut(e);for(let p=0;p+4<=l.length;p+=4){y[p+0]=l[p+0]^o,y[p+1]=l[p+1]^c,y[p+2]=l[p+2]^u,y[p+3]=l[p+3]^h;let A=1;for(let w=s.length-1;w>=0;w--)A=A+(255&s[w])|0,s[w]=255&A,A>>>=8;({s0:o,s1:c,s2:u,s3:h}=de(n,a[0],a[1],a[2],a[3]))}const g=_t*Math.floor(l.length/4);if(g<i){const p=new Uint32Array([o,c,u,h]),A=Na(p);for(let w=g,b=0;w<i;w++,b++)e[w]=r[w]^A[b];Nt(p)}return e}function Pn(n,t,r,e,i){yt(r,_t),yt(e),i=Gn(e.length,i);const s=r,a=ut(s),o=es(s),c=ut(e),u=ut(i),h=t?0:12,l=e.length;let y=o.getUint32(h,t),{s0:g,s1:p,s2:A,s3:w}=de(n,a[0],a[1],a[2],a[3]);for(let v=0;v+4<=c.length;v+=4)u[v+0]=c[v+0]^g,u[v+1]=c[v+1]^p,u[v+2]=c[v+2]^A,u[v+3]=c[v+3]^w,y=y+1>>>0,o.setUint32(h,y,t),{s0:g,s1:p,s2:A,s3:w}=de(n,a[0],a[1],a[2],a[3]);const b=_t*Math.floor(c.length/4);if(b<l){const v=new Uint32Array([g,p,A,w]),k=Na(v);for(let m=b,C=0;m<l;m++,C++)i[m]=e[m]^k[C];Nt(v)}return i}const C3=_n({blockSize:16,nonceLength:16},(function(n,t){function r(e,i){if(yt(e),i!==void 0&&(yt(i),!se(i)))throw Error("unaligned destination");const s=Lr(n),a=Yt(t),o=[s,a];se(e)||o.push(e=Yt(e));const c=c1(s,a,e,i);return Nt(...o),c}return{encrypt:(e,i)=>r(e,i),decrypt:(e,i)=>r(e,i)}})),sa=_n({blockSize:16,nonceLength:16},(function(n,t,r={}){const e=!r.disablePadding;return{encrypt(i,s){const a=Lr(n),{b:o,o:c,out:u}=(function(v,k,m){yt(v);let C=v.length;const D=C%_t;if(!k&&D!==0)throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");se(v)||(v=Yt(v));const P=ut(v);if(k){let S=_t-D;S||(S=_t),C+=S}return ra(v,m=Gn(C,m)),{b:P,o:ut(m),out:m}})(i,e,s);let h=t;const l=[a];se(h)||l.push(h=Yt(h));const y=ut(h);let g=y[0],p=y[1],A=y[2],w=y[3],b=0;for(;b+4<=o.length;)g^=o[b+0],p^=o[b+1],A^=o[b+2],w^=o[b+3],{s0:g,s1:p,s2:A,s3:w}=de(a,g,p,A,w),c[b++]=g,c[b++]=p,c[b++]=A,c[b++]=w;if(e){const v=(function(k){const m=new Uint8Array(16),C=ut(m);m.set(k);const D=_t-k.length;for(let P=_t-D;P<_t;P++)m[P]=D;return C})(i.subarray(4*b));g^=v[0],p^=v[1],A^=v[2],w^=v[3],{s0:g,s1:p,s2:A,s3:w}=de(a,g,p,A,w),c[b++]=g,c[b++]=p,c[b++]=A,c[b++]=w}return Nt(...l),u},decrypt(i,s){(function(w){if(yt(w),w.length%_t!=0)throw Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size 16")})(i);const a=Ga(n);let o=t;const c=[a];se(o)||c.push(o=Yt(o));const u=ut(o);s=Gn(i.length,s),se(i)||c.push(i=Yt(i)),ra(i,s);const h=ut(i),l=ut(s);let y=u[0],g=u[1],p=u[2],A=u[3];for(let w=0;w+4<=h.length;){const b=y,v=g,k=p,m=A;y=h[w+0],g=h[w+1],p=h[w+2],A=h[w+3];const{s0:C,s1:D,s2:P,s3:S}=rs(a,y,g,p,A);l[w++]=C^b,l[w++]=D^v,l[w++]=P^k,l[w++]=S^m}return Nt(...c),(function(w,b){if(!b)return w;const v=w.length;if(!v)throw Error("aes/pcks5: empty ciphertext not allowed");const k=w[v-1];if(k<=0||k>16)throw Error("aes/pcks5: wrong padding");const m=w.subarray(0,-k);for(let C=0;C<k;C++)if(w[v-C-1]!==k)throw Error("aes/pcks5: wrong padding");return m})(s,e)}}})),u1=_n({blockSize:16,nonceLength:16},(function(n,t){function r(e,i,s){yt(e);const a=e.length;if(r1(e,s=Gn(a,s)))throw Error("overlapping src and dst not supported.");const o=Lr(n);let c=t;const u=[o];se(c)||u.push(c=Yt(c)),se(e)||u.push(e=Yt(e));const h=ut(e),l=ut(s),y=i?l:h,g=ut(c);let p=g[0],A=g[1],w=g[2],b=g[3];for(let k=0;k+4<=h.length;){const{s0:m,s1:C,s2:D,s3:P}=de(o,p,A,w,b);l[k+0]=h[k+0]^m,l[k+1]=h[k+1]^C,l[k+2]=h[k+2]^D,l[k+3]=h[k+3]^P,p=y[k++],A=y[k++],w=y[k++],b=y[k++]}const v=_t*Math.floor(h.length/4);if(v<a){({s0:p,s1:A,s2:w,s3:b}=de(o,p,A,w,b));const k=Na(new Uint32Array([p,A,w,b]));for(let m=v,C=0;m<a;m++,C++)s[m]=e[m]^k[C];Nt(k)}return Nt(...u),s}return{encrypt:(e,i)=>r(e,!0,i),decrypt:(e,i)=>r(e,!1,i)}}));function U3(n,t,r,e,i){const s=i?i.length:0,a=n.create(r,e.length+s);i&&a.update(i);const o=(function(u,h,l){const y=new Uint8Array(16),g=es(y);return na(g,0,BigInt(h),l),na(g,8,BigInt(u),l),y})(8*e.length,8*s,t);a.update(e),a.update(o);const c=a.digest();return Nt(o),c}const ai=_n({blockSize:16,nonceLength:12,tagLength:16,varSizeNonce:!0},(function(n,t,r){if(t.length<8)throw Error("aes/gcm: invalid nonce length");function e(s,a,o){const c=U3(go,!1,s,o,r);for(let u=0;u<a.length;u++)c[u]^=a[u];return c}function i(){const s=Lr(n),a=si.slice(),o=si.slice();if(Pn(s,!1,o,o,a),t.length===12)o.set(t);else{const c=si.slice();na(es(c),8,BigInt(8*t.length),!1);const u=go.create(a).update(t).update(c);u.digestInto(o),u.destroy()}return{xk:s,authKey:a,counter:o,tagMask:Pn(s,!1,o,si)}}return{encrypt(s){const{xk:a,authKey:o,counter:c,tagMask:u}=i(),h=new Uint8Array(s.length+16),l=[a,o,c,u];se(s)||l.push(s=Yt(s)),Pn(a,!1,c,s,h.subarray(0,s.length));const y=e(o,u,h.subarray(0,h.length-16));return l.push(y),h.set(y,s.length),Nt(...l),h},decrypt(s){const{xk:a,authKey:o,counter:c,tagMask:u}=i(),h=[a,o,u,c];se(s)||h.push(s=Yt(s));const l=s.subarray(0,-16),y=s.subarray(-16),g=e(o,u,l);if(h.push(g),!n1(g,y))throw Error("aes/gcm: invalid ghash tag");const p=Pn(a,!1,c,l);return Nt(...h),p}}}));function h1(n){return n instanceof Uint32Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint32Array"}function f1(n,t){if(yt(t,16),!h1(n))throw Error("_encryptBlock accepts result of expandKeyLE");const r=ut(t);let{s0:e,s1:i,s2:s,s3:a}=de(n,r[0],r[1],r[2],r[3]);return r[0]=e,r[1]=i,r[2]=s,r[3]=a,t}function l1(n,t){if(yt(t,16),!h1(n))throw Error("_decryptBlock accepts result of expandKeyLE");const r=ut(t);let{s0:e,s1:i,s2:s,s3:a}=rs(n,r[0],r[1],r[2],r[3]);return r[0]=e,r[1]=i,r[2]=s,r[3]=a,t}const Ao={encrypt(n,t){if(t.length>=2**32)throw Error("plaintext should be less than 4gb");const r=Lr(n);if(t.length===16)f1(r,t);else{const e=ut(t);let i=e[0],s=e[1];for(let a=0,o=1;a<6;a++)for(let c=2;c<e.length;c+=2,o++){const{s0:u,s1:h,s2:l,s3:y}=de(r,i,s,e[c],e[c+1]);i=u,s=h^po(o),e[c]=l,e[c+1]=y}e[0]=i,e[1]=s}r.fill(0)},decrypt(n,t){if(t.length-8>=2**32)throw Error("ciphertext should be less than 4gb");const r=Ga(n),e=t.length/8-1;if(e===1)l1(r,t);else{const i=ut(t);let s=i[0],a=i[1];for(let o=0,c=6*e;o<6;o++)for(let u=2*e;u>=1;u-=2,c--){a^=po(c);const{s0:h,s1:l,s2:y,s3:g}=rs(r,s,a,i[u],i[u+1]);s=h,a=l,i[u]=y,i[u+1]=g}i[0]=s,i[1]=a}r.fill(0)}},wo=new Uint8Array(8).fill(166),y1=_n({blockSize:8},(n=>({encrypt(t){if(!t.length||t.length%8!=0)throw Error("invalid plaintext length");if(t.length===8)throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");const r=(function(...e){let i=0;for(let a=0;a<e.length;a++){const o=e[a];yt(o),i+=o.length}const s=new Uint8Array(i);for(let a=0,o=0;a<e.length;a++){const c=e[a];s.set(c,o),o+=c.length}return s})(wo,t);return Ao.encrypt(n,r),r},decrypt(t){if(t.length%8!=0||t.length<24)throw Error("invalid ciphertext length");const r=Yt(t);if(Ao.decrypt(n,r),!n1(r.subarray(0,8),wo))throw Error("integrity check failed");return r.subarray(0,8).fill(0),r.subarray(8)}}))),mo={expandKeyLE:Lr,expandKeyDecLE:Ga,encrypt:de,decrypt:rs,encryptBlock:f1,decryptBlock:l1,ctrCounter:c1,ctr32:Pn};async function g1(n){switch(n){case f.symmetric.aes128:case f.symmetric.aes192:case f.symmetric.aes256:throw Error("Not a legacy cipher");case f.symmetric.cast5:case f.symmetric.blowfish:case f.symmetric.twofish:case f.symmetric.tripledes:{const{legacyCiphers:t}=await Promise.resolve().then((function(){return p5})),r=f.read(f.symmetric,n),e=t.get(r);if(!e)throw Error("Unsupported cipher algorithm");return e}default:throw Error("Unsupported cipher algorithm")}}function P3(n){switch(n){case f.symmetric.aes128:case f.symmetric.aes192:case f.symmetric.aes256:case f.symmetric.twofish:return 16;case f.symmetric.blowfish:case f.symmetric.cast5:case f.symmetric.tripledes:return 8;default:throw Error("Unsupported cipher")}}function D3(n){switch(n){case f.symmetric.aes128:case f.symmetric.blowfish:case f.symmetric.cast5:return 16;case f.symmetric.aes192:case f.symmetric.tripledes:return 24;case f.symmetric.aes256:case f.symmetric.twofish:return 32;default:throw Error("Unsupported cipher")}}function ot(n){return{keySize:D3(n),blockSize:P3(n)}}const nn=d.getWebCrypto();async function aa(n,t,r){const{keySize:e}=ot(n);if(!d.isAES(n)||t.length!==e)throw Error("Unexpected algorithm or key size");try{const i=await nn.importKey("raw",t,{name:"AES-KW"},!1,["wrapKey"]),s=await nn.importKey("raw",r,{name:"HMAC",hash:"SHA-256"},!0,["sign"]),a=await nn.wrapKey("raw",s,i,{name:"AES-KW"});return new Uint8Array(a)}catch(i){if(i.name!=="NotSupportedError"&&(t.length!==24||i.name!=="OperationError"))throw i;d.printDebugError("Browser did not support operation: "+i.message)}return y1(t).encrypt(r)}async function oa(n,t,r){const{keySize:e}=ot(n);if(!d.isAES(n)||t.length!==e)throw Error("Unexpected algorithm or key size");let i;try{i=await nn.importKey("raw",t,{name:"AES-KW"},!1,["unwrapKey"])}catch(s){if(s.name!=="NotSupportedError"&&(t.length!==24||s.name!=="OperationError"))throw s;return d.printDebugError("Browser did not support operation: "+s.message),y1(t).decrypt(r)}try{const s=await nn.unwrapKey("raw",r,i,{name:"AES-KW"},{name:"HMAC",hash:"SHA-256"},!0,["sign"]);return new Uint8Array(await nn.exportKey("raw",s))}catch(s){throw s.name==="OperationError"?Error("Key Data Integrity failed"):s}}async function pr(n,t,r,e,i){const s=d.getWebCrypto(),a=f.read(f.webHash,n);if(!a)throw Error("Hash algo not supported with HKDF");const o=await s.importKey("raw",t,"HKDF",!1,["deriveBits"]),c=await s.deriveBits({name:"HKDF",hash:a,salt:r,info:e},o,8*i);return new Uint8Array(c)}const Ti={x25519:d.encodeUTF8("OpenPGP X25519"),x448:d.encodeUTF8("OpenPGP X448")};async function ja(n){switch(n){case f.publicKey.x25519:try{const t=d.getWebCrypto(),r=await t.generateKey("X25519",!0,["deriveKey","deriveBits"]).catch((s=>{if(s.name==="OperationError"){const a=Error("Unexpected key generation issue");throw a.name="NotSupportedError",a}throw s})),e=await t.exportKey("jwk",r.privateKey),i=await t.exportKey("jwk",r.publicKey);if(e.x!==i.x){const s=Error("Unexpected mismatching public point");throw s.name="NotSupportedError",s}return{A:new Uint8Array(qt(i.x)),k:qt(e.d)}}catch(t){if(t.name!=="NotSupportedError")throw t;const{default:r}=await Promise.resolve().then((function(){return Hr})),{secretKey:e,publicKey:i}=r.box.keyPair();return{A:i,k:e}}case f.publicKey.x448:{const t=await d.getNobleCurve(f.publicKey.x448),{secretKey:r,publicKey:e}=t.keygen();return{A:e,k:r}}default:throw Error("Unsupported ECDH algorithm")}}async function Va(n,t,r){switch(n){case f.publicKey.x25519:try{const{ephemeralPublicKey:e,sharedSecret:i}=await is(n,t),s=await ss(n,e,t,r);return d.equalsUint8Array(i,s)}catch{return!1}case f.publicKey.x448:{const e=(await d.getNobleCurve(f.publicKey.x448)).getPublicKey(r);return d.equalsUint8Array(t,e)}default:return!1}}async function p1(n,t,r){const{ephemeralPublicKey:e,sharedSecret:i}=await is(n,r),s=d.concatUint8Array([e,r,i]);switch(n){case f.publicKey.x25519:{const a=f.symmetric.aes128,{keySize:o}=ot(a),c=await pr(f.hash.sha256,s,new Uint8Array,Ti.x25519,o);return{ephemeralPublicKey:e,wrappedKey:await aa(a,c,t)}}case f.publicKey.x448:{const a=f.symmetric.aes256,{keySize:o}=ot(f.symmetric.aes256),c=await pr(f.hash.sha512,s,new Uint8Array,Ti.x448,o);return{ephemeralPublicKey:e,wrappedKey:await aa(a,c,t)}}default:throw Error("Unsupported ECDH algorithm")}}async function d1(n,t,r,e,i){const s=await ss(n,t,e,i),a=d.concatUint8Array([t,e,s]);switch(n){case f.publicKey.x25519:{const o=f.symmetric.aes128,{keySize:c}=ot(o);return oa(o,await pr(f.hash.sha256,a,new Uint8Array,Ti.x25519,c),r)}case f.publicKey.x448:{const o=f.symmetric.aes256,{keySize:c}=ot(f.symmetric.aes256);return oa(o,await pr(f.hash.sha512,a,new Uint8Array,Ti.x448,c),r)}default:throw Error("Unsupported ECDH algorithm")}}function ns(n){switch(n){case f.publicKey.x25519:return 32;case f.publicKey.x448:return 56;default:throw Error("Unsupported ECDH algorithm")}}async function is(n,t){switch(n){case f.publicKey.x25519:try{const r=d.getWebCrypto(),e=await r.generateKey("X25519",!0,["deriveKey","deriveBits"]).catch((c=>{if(c.name==="OperationError"){const u=Error("Unexpected key generation issue");throw u.name="NotSupportedError",u}throw c})),i=await r.exportKey("jwk",e.publicKey);if((await r.exportKey("jwk",e.privateKey)).x!==i.x){const c=Error("Unexpected mismatching public point");throw c.name="NotSupportedError",c}const s=ca(n,t),a=await r.importKey("jwk",s,"X25519",!1,[]),o=await r.deriveBits({name:"X25519",public:a},e.privateKey,8*ns(n));return{sharedSecret:new Uint8Array(o),ephemeralPublicKey:new Uint8Array(qt(i.x))}}catch(r){if(r.name!=="NotSupportedError")throw r;const{default:e}=await Promise.resolve().then((function(){return Hr})),{secretKey:i,publicKey:s}=e.box.keyPair(),a=e.scalarMult(i,t);return Fi(a),{ephemeralPublicKey:s,sharedSecret:a}}case f.publicKey.x448:{const r=await d.getNobleCurve(f.publicKey.x448),{secretKey:e,publicKey:i}=r.keygen(),s=r.getSharedSecret(e,t);return Fi(s),{ephemeralPublicKey:i,sharedSecret:s}}default:throw Error("Unsupported ECDH algorithm")}}async function ss(n,t,r,e){switch(n){case f.publicKey.x25519:try{const i=d.getWebCrypto(),s=(function(h,l,y){if(h===f.publicKey.x25519){const g=ca(h,l);return g.d=xt(y),g}throw Error("Unsupported ECDH algorithm")})(n,r,e),a=ca(n,t),o=await i.importKey("jwk",s,"X25519",!1,["deriveKey","deriveBits"]),c=await i.importKey("jwk",a,"X25519",!1,[]),u=await i.deriveBits({name:"X25519",public:c},o,8*ns(n));return new Uint8Array(u)}catch(i){if(i.name!=="NotSupportedError")throw i;const{default:s}=await Promise.resolve().then((function(){return Hr})),a=s.scalarMult(e,t);return Fi(a),a}case f.publicKey.x448:{const i=(await d.getNobleCurve(f.publicKey.x448)).getSharedSecret(e,t);return Fi(i),i}default:throw Error("Unsupported ECDH algorithm")}}function Fi(n){let t=0;for(let r=0;r<n.length;r++)t|=n[r];if(t===0)throw Error("Unexpected low order point")}function ca(n,t){if(n===f.publicKey.x25519)return{kty:"OKP",crv:"X25519",x:xt(t),ext:!0};throw Error("Unsupported ECDH algorithm")}var x3=Object.freeze({__proto__:null,decrypt:d1,encrypt:p1,generate:ja,generateEphemeralEncryptionMaterial:is,getPayloadSize:ns,recomputeSharedSecret:ss,validateParams:Va});const Ss=d.getWebCrypto(),Li=d.getNodeCrypto(),Ue={[f.curve.nistP256]:"P-256",[f.curve.nistP384]:"P-384",[f.curve.nistP521]:"P-521"},Re=Li?Li.getCurves():[],ve=Li?{[f.curve.secp256k1]:Re.includes("secp256k1")?"secp256k1":void 0,[f.curve.nistP256]:Re.includes("prime256v1")?"prime256v1":void 0,[f.curve.nistP384]:Re.includes("secp384r1")?"secp384r1":void 0,[f.curve.nistP521]:Re.includes("secp521r1")?"secp521r1":void 0,[f.curve.ed25519Legacy]:Re.includes("ED25519")?"ED25519":void 0,[f.curve.curve25519Legacy]:Re.includes("X25519")?"X25519":void 0,[f.curve.brainpoolP256r1]:Re.includes("brainpoolP256r1")?"brainpoolP256r1":void 0,[f.curve.brainpoolP384r1]:Re.includes("brainpoolP384r1")?"brainpoolP384r1":void 0,[f.curve.brainpoolP512r1]:Re.includes("brainpoolP512r1")?"brainpoolP512r1":void 0}:{},A1={[f.curve.nistP256]:{oid:[6,8,42,134,72,206,61,3,1,7],keyType:f.publicKey.ecdsa,hash:f.hash.sha256,cipher:f.symmetric.aes128,node:ve[f.curve.nistP256],web:Ue[f.curve.nistP256],payloadSize:32,sharedSize:256,wireFormatLeadingByte:4},[f.curve.nistP384]:{oid:[6,5,43,129,4,0,34],keyType:f.publicKey.ecdsa,hash:f.hash.sha384,cipher:f.symmetric.aes192,node:ve[f.curve.nistP384],web:Ue[f.curve.nistP384],payloadSize:48,sharedSize:384,wireFormatLeadingByte:4},[f.curve.nistP521]:{oid:[6,5,43,129,4,0,35],keyType:f.publicKey.ecdsa,hash:f.hash.sha512,cipher:f.symmetric.aes256,node:ve[f.curve.nistP521],web:Ue[f.curve.nistP521],payloadSize:66,sharedSize:528,wireFormatLeadingByte:4},[f.curve.secp256k1]:{oid:[6,5,43,129,4,0,10],keyType:f.publicKey.ecdsa,hash:f.hash.sha256,cipher:f.symmetric.aes128,node:ve[f.curve.secp256k1],payloadSize:32,wireFormatLeadingByte:4},[f.curve.ed25519Legacy]:{oid:[6,9,43,6,1,4,1,218,71,15,1],keyType:f.publicKey.eddsaLegacy,hash:f.hash.sha512,node:!1,payloadSize:32,wireFormatLeadingByte:64},[f.curve.curve25519Legacy]:{oid:[6,10,43,6,1,4,1,151,85,1,5,1],keyType:f.publicKey.ecdh,hash:f.hash.sha256,cipher:f.symmetric.aes128,node:!1,payloadSize:32,wireFormatLeadingByte:64},[f.curve.brainpoolP256r1]:{oid:[6,9,43,36,3,3,2,8,1,1,7],keyType:f.publicKey.ecdsa,hash:f.hash.sha256,cipher:f.symmetric.aes128,node:ve[f.curve.brainpoolP256r1],payloadSize:32,wireFormatLeadingByte:4},[f.curve.brainpoolP384r1]:{oid:[6,9,43,36,3,3,2,8,1,1,11],keyType:f.publicKey.ecdsa,hash:f.hash.sha384,cipher:f.symmetric.aes192,node:ve[f.curve.brainpoolP384r1],payloadSize:48,wireFormatLeadingByte:4},[f.curve.brainpoolP512r1]:{oid:[6,9,43,36,3,3,2,8,1,1,13],keyType:f.publicKey.ecdsa,hash:f.hash.sha512,cipher:f.symmetric.aes256,node:ve[f.curve.brainpoolP512r1],payloadSize:64,wireFormatLeadingByte:4}};class oe{constructor(t){try{this.name=t instanceof je?t.getName():f.write(f.curve,t)}catch{throw new it("Unknown curve")}const r=A1[this.name];this.keyType=r.keyType,this.oid=r.oid,this.hash=r.hash,this.cipher=r.cipher,this.node=r.node,this.web=r.web,this.payloadSize=r.payloadSize,this.sharedSize=r.sharedSize,this.wireFormatLeadingByte=r.wireFormatLeadingByte,this.web&&d.getWebCrypto()?this.type="web":this.node&&d.getNodeCrypto()?this.type="node":this.name===f.curve.curve25519Legacy?this.type="curve25519Legacy":this.name===f.curve.ed25519Legacy&&(this.type="ed25519Legacy")}async genKeyPair(){switch(this.type){case"web":try{return await(async function(t,r){const e=await Ss.generateKey({name:"ECDSA",namedCurve:Ue[t]},!0,["sign","verify"]),i=await Ss.exportKey("jwk",e.privateKey);return{publicKey:b1(await Ss.exportKey("jwk",e.publicKey),r),privateKey:qt(i.d)}})(this.name,this.wireFormatLeadingByte)}catch(t){return d.printDebugError("Browser did not support generating ec key "+t.message),bo(this.name)}case"node":return(function(t){const r=Li.createECDH(ve[t]);return r.generateKeys(),{publicKey:new Uint8Array(r.getPublicKey()),privateKey:new Uint8Array(r.getPrivateKey())}})(this.name);case"curve25519Legacy":{const{k:t,A:r}=await ja(f.publicKey.x25519),e=t.slice().reverse();return e[0]=127&e[0]|64,e[31]&=248,{publicKey:d.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),r]),privateKey:e}}case"ed25519Legacy":{const{seed:t,A:r}=await Ma(f.publicKey.ed25519);return{publicKey:d.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),r]),privateKey:t}}default:return bo(this.name)}}}async function ki(n){const t=new oe(n),{oid:r,hash:e,cipher:i}=t,s=await t.genKeyPair();return{oid:r,Q:s.publicKey,secret:d.leftPad(s.privateKey,t.payloadSize),hash:e,cipher:i}}function w1(n){return A1[n.getName()].hash}async function m1(n,t,r,e){const i={[f.curve.nistP256]:!0,[f.curve.nistP384]:!0,[f.curve.nistP521]:!0,[f.curve.secp256k1]:!0,[f.curve.curve25519Legacy]:n===f.publicKey.ecdh,[f.curve.brainpoolP256r1]:!0,[f.curve.brainpoolP384r1]:!0,[f.curve.brainpoolP512r1]:!0},s=t.getName();if(!i[s])return!1;if(s===f.curve.curve25519Legacy){const o=e.slice().reverse();return!(r.length<1||r[0]!==64)&&Va(f.publicKey.x25519,r.subarray(1),o)}const a=(await d.getNobleCurve(f.publicKey.ecdsa,s)).getPublicKey(e,!1);return!!d.equalsUint8Array(a,r)}function Rr(n,t){const{payloadSize:r,wireFormatLeadingByte:e,name:i}=n,s=i===f.curve.curve25519Legacy||i===f.curve.ed25519Legacy?r:2*r;if(t[0]!==e||t.length!==s+1)throw Error("Invalid point encoding")}async function bo(n){const t=await d.getNobleCurve(f.publicKey.ecdsa,n),{secretKey:r}=t.keygen();return{publicKey:t.getPublicKey(r,!1),privateKey:r}}function b1(n,t){const r=qt(n.x),e=qt(n.y),i=new Uint8Array(r.length+e.length+1);return i[0]=t,i.set(r,1),i.set(e,r.length+1),i}function as(n,t,r){const e=n,i=r.slice(1,e+1),s=r.slice(e+1,2*e+1);return{kty:"EC",crv:t,x:xt(i),y:xt(s),ext:!0}}function k1(n,t,r,e){const i=as(n,t,r);return i.d=xt(e),i}const Ni=d.getWebCrypto(),E1=d.getNodeCrypto();async function ua(n,t,r,e,i,s){const a=new oe(n);if(Rr(a,e),r&&!d.isStream(r)){const c={publicKey:e,privateKey:i};switch(a.type){case"web":try{return await(async function(u,h,l,y){const g=u.payloadSize,p=k1(u.payloadSize,Ue[u.name],y.publicKey,y.privateKey),A=await Ni.importKey("jwk",p,{name:"ECDSA",namedCurve:Ue[u.name],hash:{name:f.read(f.webHash,u.hash)}},!1,["sign"]),w=new Uint8Array(await Ni.sign({name:"ECDSA",namedCurve:Ue[u.name],hash:{name:f.read(f.webHash,h)}},A,l));return{r:w.slice(0,g),s:w.slice(g,g<<1)}})(a,t,r,c)}catch(u){if(a.name!=="nistP521"&&(u.name==="DataError"||u.name==="OperationError"))throw u;d.printDebugError("Browser did not support signing: "+u.message)}break;case"node":return(function(u,h,l,y){const g=d.nodeRequire("eckey-utils"),p=d.getNodeBuffer(),{privateKey:A}=g.generateDer({curveName:ve[u.name],privateKey:p.from(y)}),w=E1.createSign(f.read(f.hash,h));w.write(l),w.end();const b=new Uint8Array(w.sign({key:A,format:"der",type:"sec1",dsaEncoding:"ieee-p1363"})),v=u.payloadSize;return{r:b.subarray(0,v),s:b.subarray(v,v<<1)}})(a,t,r,i)}}const o=(await d.getNobleCurve(f.publicKey.ecdsa,a.name)).sign(s,i,{lowS:!1});return{r:kt(o.r,"be",a.payloadSize),s:kt(o.s,"be",a.payloadSize)}}async function ha(n,t,r,e,i,s){const a=new oe(n);Rr(a,i);const o=async()=>s[0]===0&&ko(a,r,s.subarray(1),i);if(e&&!d.isStream(e))switch(a.type){case"web":try{return await(async function(u,h,{r:l,s:y},g,p){const A=as(u.payloadSize,Ue[u.name],p),w=await Ni.importKey("jwk",A,{name:"ECDSA",namedCurve:Ue[u.name],hash:{name:f.read(f.webHash,u.hash)}},!1,["verify"]),b=d.concatUint8Array([l,y]).buffer;return Ni.verify({name:"ECDSA",namedCurve:Ue[u.name],hash:{name:f.read(f.webHash,h)}},w,b,g)})(a,t,r,e,i)||o()}catch(c){if(a.name!=="nistP521"&&(c.name==="DataError"||c.name==="OperationError"))throw c;d.printDebugError("Browser did not support verifying: "+c.message)}break;case"node":return(function(u,h,{r:l,s:y},g,p){const A=d.nodeRequire("eckey-utils"),w=d.getNodeBuffer(),{publicKey:b}=A.generateDer({curveName:ve[u.name],publicKey:w.from(p)}),v=E1.createVerify(f.read(f.hash,h));v.write(g),v.end();const k=d.concatUint8Array([l,y]);try{return v.verify({key:b,format:"der",type:"spki",dsaEncoding:"ieee-p1363"},k)}catch{return!1}})(a,t,r,e,i)||o()}return await ko(a,r,s,i)||o()}async function ko(n,t,r,e){return(await d.getNobleCurve(f.publicKey.ecdsa,n.name)).verify(d.concatUint8Array([t.r,t.s]),r,e,{lowS:!1})}var Q3=Object.freeze({__proto__:null,sign:ua,validateParams:async function(n,t,r){const e=new oe(n);if(e.keyType!==f.publicKey.ecdsa)return!1;switch(e.type){case"web":case"node":{const i=Dt(8),s=f.hash.sha256,a=await Qe(s,i);try{const o=await ua(n,s,i,t,r,a);return await ha(n,s,o,i,t,a)}catch{return!1}}default:return m1(f.publicKey.ecdsa,n,t,r)}},verify:ha});async function v1(n,t,r,e,i,s){if(Rr(new oe(n),e),It(t)<It(f.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const{RS:a}=await Ra(f.publicKey.ed25519,t,0,e.subarray(1),i,s);return{r:a.subarray(0,32),s:a.subarray(32)}}async function I1(n,t,{r,s:e},i,s,a){if(Rr(new oe(n),s),It(t)<It(f.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const o=d.concatUint8Array([r,e]);return Ta(f.publicKey.ed25519,t,{RS:o},0,s.subarray(1),a)}async function S1(n,t,r){return n.getName()===f.curve.ed25519Legacy&&!(t.length<1||t[0]!==64)&&Fa(f.publicKey.ed25519,t.subarray(1),r)}var M3=Object.freeze({__proto__:null,sign:v1,validateParams:S1,verify:I1});function R3(n){const t=n.length;if(t>0){const r=n[t-1];if(r>=1){const e=n.subarray(t-r),i=new Uint8Array(r).fill(r);if(d.equalsUint8Array(e,i))return n.subarray(0,t-r)}}throw Error("Invalid padding")}function B1(n,t,r,e){return d.concatUint8Array([t.write(),new Uint8Array([n]),r.write(),d.stringToUint8Array("Anonymous Sender    "),e])}async function K1(n,t,r,e,i=!1,s=!1){let a;if(i){for(a=0;a<t.length&&t[a]===0;a++);t=t.subarray(a)}if(s){for(a=t.length-1;a>=0&&t[a]===0;a--);t=t.subarray(0,a+1)}return(await Qe(n,d.concatUint8Array([new Uint8Array([0,0,0,1]),t,e]))).subarray(0,r)}async function T3(n,t){switch(n.type){case"curve25519Legacy":{const{sharedSecret:r,ephemeralPublicKey:e}=await is(f.publicKey.x25519,t.subarray(1));return{publicKey:d.concatUint8Array([new Uint8Array([n.wireFormatLeadingByte]),e]),sharedKey:r}}case"web":if(n.web&&d.getWebCrypto())try{return await(async function(r,e){const i=d.getWebCrypto(),s=as(r.payloadSize,r.web,e);let a=i.generateKey({name:"ECDH",namedCurve:r.web},!0,["deriveKey","deriveBits"]),o=i.importKey("jwk",s,{name:"ECDH",namedCurve:r.web},!1,[]);[a,o]=await Promise.all([a,o]);let c=i.deriveBits({name:"ECDH",namedCurve:r.web,public:o},a.privateKey,r.sharedSize),u=i.exportKey("jwk",a.publicKey);[c,u]=await Promise.all([c,u]);const h=new Uint8Array(c);return{publicKey:new Uint8Array(b1(u,r.wireFormatLeadingByte)),sharedKey:h}})(n,t)}catch(r){return d.printDebugError(r),vo(n,t)}break;case"node":return(function(r,e){const i=d.getNodeCrypto(),s=i.createECDH(r.node);s.generateKeys();const a=new Uint8Array(s.computeSecret(e));return{publicKey:new Uint8Array(s.getPublicKey()),sharedKey:a}})(n,t);default:return vo(n,t)}}async function C1(n,t,r,e,i){const s=(function(y){const g=8-y.length%8,p=new Uint8Array(y.length+g).fill(g);return p.set(y),p})(r),a=new oe(n);Rr(a,e);const{publicKey:o,sharedKey:c}=await T3(a,e),u=B1(f.publicKey.ecdh,n,t,i),{keySize:h}=ot(t.cipher),l=await K1(t.hash,c,h,u);return{publicKey:o,wrappedKey:await aa(t.cipher,l,s)}}async function F3(n,t,r,e){if(e.length!==n.payloadSize){const i=new Uint8Array(n.payloadSize);i.set(e,n.payloadSize-e.length),e=i}switch(n.type){case"curve25519Legacy":{const i=e.slice().reverse();return{secretKey:i,sharedKey:await ss(f.publicKey.x25519,t.subarray(1),r.subarray(1),i)}}case"web":if(n.web&&d.getWebCrypto())try{return await(async function(i,s,a,o){const c=d.getWebCrypto(),u=k1(i.payloadSize,i.web,a,o);let h=c.importKey("jwk",u,{name:"ECDH",namedCurve:i.web},!0,["deriveKey","deriveBits"]);const l=as(i.payloadSize,i.web,s);let y=c.importKey("jwk",l,{name:"ECDH",namedCurve:i.web},!0,[]);[h,y]=await Promise.all([h,y]);let g=c.deriveBits({name:"ECDH",namedCurve:i.web,public:y},h,i.sharedSize),p=c.exportKey("jwk",h);[g,p]=await Promise.all([g,p]);const A=new Uint8Array(g);return{secretKey:qt(p.d),sharedKey:A}})(n,t,r,e)}catch(i){return d.printDebugError(i),Eo(n,t,e)}break;case"node":return(function(i,s,a){const o=d.getNodeCrypto(),c=o.createECDH(i.node);c.setPrivateKey(a);const u=new Uint8Array(c.computeSecret(s));return{secretKey:new Uint8Array(c.getPrivateKey()),sharedKey:u}})(n,t,e);default:return Eo(n,t,e)}}async function U1(n,t,r,e,i,s,a){const o=new oe(n);Rr(o,i),Rr(o,r);const{sharedKey:c}=await F3(o,r,i,s),u=B1(f.publicKey.ecdh,n,t,a),{keySize:h}=ot(t.cipher);let l;for(let y=0;y<3;y++)try{const g=await K1(t.hash,c,h,u,y===1,y===2);return R3(await oa(t.cipher,g,e))}catch(g){l=g}throw l}async function Eo(n,t,r){return{secretKey:r,sharedKey:(await d.getNobleCurve(f.publicKey.ecdh,n.name)).getSharedSecret(r,t).subarray(1)}}async function vo(n,t){const r=await d.getNobleCurve(f.publicKey.ecdh,n.name),{publicKey:e,privateKey:i}=await n.genKeyPair();return{publicKey:e,sharedKey:r.getSharedSecret(i,t).subarray(1)}}var L3=Object.freeze({__proto__:null,CurveWithOID:oe,ecdh:Object.freeze({__proto__:null,decrypt:U1,encrypt:C1,validateParams:async function(n,t,r){return m1(f.publicKey.ecdh,n,t,r)}}),ecdhX:x3,ecdsa:Q3,eddsa:v3,eddsaLegacy:M3,generate:ki,getPreferredHashAlgo:w1});const Ei=BigInt(0),Dn=BigInt(1);class P1{constructor(t){t&&(this.data=t)}read(t){if(t.length>=1){const r=t[0];if(t.length>=1+r)return this.data=t.subarray(1,1+r),1+this.data.length}throw Error("Invalid symmetric key")}write(){return d.concatUint8Array([new Uint8Array([this.data.length]),this.data])}}class D1{constructor(t){if(t){const{hash:r,cipher:e}=t;this.hash=r,this.cipher=e}else this.hash=null,this.cipher=null}read(t){if(t.length<4||t[0]!==3||t[1]!==1)throw new it("Cannot read KDFParams");return this.hash=t[2],this.cipher=t[3],4}write(){return new Uint8Array([3,1,this.hash,this.cipher])}}class os{static fromObject({wrappedKey:t,algorithm:r}){const e=new os;return e.wrappedKey=t,e.algorithm=r,e}read(t){let r=0,e=t[r++];this.algorithm=e%2?t[r++]:null,e-=e%2,this.wrappedKey=d.readExactSubarray(t,r,r+e),r+=e}write(){return d.concatUint8Array([this.algorithm?new Uint8Array([this.wrappedKey.length+1,this.algorithm]):new Uint8Array([this.wrappedKey.length]),this.wrappedKey])}}async function N3(n,t,r,e,i){switch(n){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:{const{n:s,e:a}=r;return{c:await w3(e,s,a)}}case f.publicKey.elgamal:{const{p:s,g:a,y:o}=r;return(async function(c,u,h,l){u=Z(u),h=Z(h),l=Z(l);const y=Z(Jc(c,Jt(u))),g=lr(or,u-or);return{c1:kt(Pt(h,g,u)),c2:kt(tt(Pt(l,g,u)*y,u))}})(e,s,a,o)}case f.publicKey.ecdh:{const{oid:s,Q:a,kdfParams:o}=r,{publicKey:c,wrappedKey:u}=await C1(s,o,e,a,i);return{V:c,C:new P1(u)}}case f.publicKey.x25519:case f.publicKey.x448:{if(t&&!d.isAES(t))throw Error("X25519 and X448 keys can only encrypt AES session keys");const{A:s}=r,{ephemeralPublicKey:a,wrappedKey:o}=await p1(n,e,s);return{ephemeralPublicKey:a,C:os.fromObject({algorithm:t,wrappedKey:o})}}default:return[]}}async function O3(n,t,r,e,i,s){switch(n){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaEncrypt:{const{c:a}=e,{n:o,e:c}=t,{d:u,p:h,q:l,u:y}=r;return m3(a,o,c,u,h,l,y,s)}case f.publicKey.elgamal:{const{c1:a,c2:o}=e;return(async function(c,u,h,l,y){return c=Z(c),u=Z(u),h=Z(h),Xc(kt(tt(sn(Pt(c,l=Z(l),h),h)*u,h),"be",Jt(h)),y)})(a,o,t.p,r.x,s)}case f.publicKey.ecdh:{const{oid:a,Q:o,kdfParams:c}=t,{d:u}=r,{V:h,C:l}=e;return U1(a,c,h,l.data,o,u,i)}case f.publicKey.x25519:case f.publicKey.x448:{const{A:a}=t,{k:o}=r,{ephemeralPublicKey:c,C:u}=e;if(u.algorithm!==null&&!d.isAES(u.algorithm))throw Error("AES session key expected");return d1(n,c,u.wrappedKey,a,o)}default:throw Error("Unknown public key encryption algorithm.")}}function Io(n,t,r){let e=0;switch(n){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:case f.publicKey.rsaSign:{const i=d.readMPI(t.subarray(e));e+=i.length+2;const s=d.readMPI(t.subarray(e));e+=s.length+2;const a=d.readMPI(t.subarray(e));e+=a.length+2;const o=d.readMPI(t.subarray(e));return e+=o.length+2,{read:e,privateParams:{d:i,p:s,q:a,u:o}}}case f.publicKey.dsa:case f.publicKey.elgamal:{const i=d.readMPI(t.subarray(e));return e+=i.length+2,{read:e,privateParams:{x:i}}}case f.publicKey.ecdsa:case f.publicKey.ecdh:{const i=Xr(n,r.oid);let s=d.readMPI(t.subarray(e));return e+=s.length+2,s=d.leftPad(s,i),{read:e,privateParams:{d:s}}}case f.publicKey.eddsaLegacy:{const i=Xr(n,r.oid);if(r.oid.getName()!==f.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let s=d.readMPI(t.subarray(e));return e+=s.length+2,s=d.leftPad(s,i),{read:e,privateParams:{seed:s}}}case f.publicKey.ed25519:case f.publicKey.ed448:{const i=Xr(n),s=d.readExactSubarray(t,e,e+i);return e+=s.length,{read:e,privateParams:{seed:s}}}case f.publicKey.x25519:case f.publicKey.x448:{const i=Xr(n),s=d.readExactSubarray(t,e,e+i);return e+=s.length,{read:e,privateParams:{k:s}}}default:throw new it("Unknown public key encryption algorithm.")}}function on(n,t){const r=new Set([f.publicKey.ed25519,f.publicKey.x25519,f.publicKey.ed448,f.publicKey.x448]),e=Object.keys(t).map((i=>{const s=t[i];return d.isUint8Array(s)?r.has(n)?s:d.uint8ArrayToMPI(s):s.write()}));return d.concatUint8Array(e)}function H3(n,t,r){switch(n){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:case f.publicKey.rsaSign:return(async function(e,i){if(i=BigInt(i),d.getWebCrypto()){const u={name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:kt(i),hash:{name:"SHA-1"}},h=await an.generateKey(u,!0,["sign","verify"]);return lo(await an.exportKey("jwk",h.privateKey),i)}if(d.getNodeCrypto()){const u={modulusLength:e,publicExponent:_s(i),publicKeyEncoding:{type:"pkcs1",format:"jwk"},privateKeyEncoding:{type:"pkcs1",format:"jwk"}},h=await new Promise(((l,y)=>{Mr.generateKeyPair("rsa",u,((g,p,A)=>{g?y(g):l(A)}))}));return lo(h,i)}let s,a,o;do a=ho(e-(e>>1),i,40),s=ho(e>>1,i,40),o=s*a;while(rn(o)!==e);const c=(s-gr)*(a-gr);return a<s&&([s,a]=[a,s]),{n:kt(o),e:kt(i),d:kt(sn(i,c)),p:kt(s),q:kt(a),u:kt(sn(s,a))}})(t,65537).then((({n:e,e:i,d:s,p:a,q:o,u:c})=>({privateParams:{d:s,p:a,q:o,u:c},publicParams:{n:e,e:i}})));case f.publicKey.ecdsa:return ki(r).then((({oid:e,Q:i,secret:s})=>({privateParams:{d:s},publicParams:{oid:new je(e),Q:i}})));case f.publicKey.eddsaLegacy:return ki(r).then((({oid:e,Q:i,secret:s})=>({privateParams:{seed:s},publicParams:{oid:new je(e),Q:i}})));case f.publicKey.ecdh:return ki(r).then((({oid:e,Q:i,secret:s,hash:a,cipher:o})=>({privateParams:{d:s},publicParams:{oid:new je(e),Q:i,kdfParams:new D1({hash:a,cipher:o})}})));case f.publicKey.ed25519:case f.publicKey.ed448:return Ma(n).then((({A:e,seed:i})=>({privateParams:{seed:i},publicParams:{A:e}})));case f.publicKey.x25519:case f.publicKey.x448:return ja(n).then((({A:e,k:i})=>({privateParams:{k:i},publicParams:{A:e}})));case f.publicKey.dsa:case f.publicKey.elgamal:throw Error("Unsupported algorithm for key generation.");default:throw Error("Unknown public key algorithm.")}}async function z3(n,t,r){if(!t||!r)throw Error("Missing key parameters");switch(n){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:case f.publicKey.rsaSign:{const{n:e,e:i}=t,{d:s,p:a,q:o,u:c}=r;return(async function(u,h,l,y,g,p){if(u=Z(u),(y=Z(y))*(g=Z(g))!==u)return!1;const A=BigInt(2);if(tt(y*(p=Z(p)),g)!==BigInt(1))return!1;h=Z(h),l=Z(l);const w=lr(A,A<<BigInt(Math.floor(rn(u)/3))),b=w*l*h;return!(tt(b,y-gr)!==w||tt(b,g-gr)!==w)})(e,i,s,a,o,c)}case f.publicKey.dsa:{const{p:e,q:i,g:s,y:a}=t,{x:o}=r;return(async function(c,u,h,l,y){const g=Z(c),p=Z(u),A=Z(h),w=Z(l);if(A<=Dn||A>=g||tt(g-Dn,p)!==Ei||Pt(A,p,g)!==Dn)return!1;const b=BigInt(rn(p));if(b<BigInt(150)||!Zc(p,null,32))return!1;const v=Z(y),k=BigInt(2);return w===Pt(A,p*lr(k<<b-Dn,k<<b)+v,g)})(e,i,s,a,o)}case f.publicKey.elgamal:{const{p:e,g:i,y:s}=t,{x:a}=r;return(async function(o,c,u,h){const l=Z(o),y=Z(c),g=Z(u);if(y<=or||y>=l)return!1;const p=BigInt(rn(l));if(p<BigInt(1023)||Pt(y,l-or,l)!==or)return!1;let A=y,w=BigInt(1);const b=BigInt(2),v=b<<BigInt(17);for(;w<v;){if(A=tt(A*y,l),A===or)return!1;w++}const k=Z(h),m=lr(b<<p-or,b<<p);return g===Pt(y,(l-or)*m+k,l)})(e,i,s,a)}case f.publicKey.ecdsa:case f.publicKey.ecdh:{const e=L3[f.read(f.publicKey,n)],{oid:i,Q:s}=t,{d:a}=r;return e.validateParams(i,s,a)}case f.publicKey.eddsaLegacy:{const{Q:e,oid:i}=t,{seed:s}=r;return S1(i,e,s)}case f.publicKey.ed25519:case f.publicKey.ed448:{const{A:e}=t,{seed:i}=r;return Fa(n,e,i)}case f.publicKey.x25519:case f.publicKey.x448:{const{A:e}=t,{k:i}=r;return Va(n,e,i)}default:throw Error("Unknown public key algorithm.")}}function fa(n){const{keySize:t}=ot(n);return Dt(t)}function Bs(n){try{n.getName()}catch{throw new it("Unknown curve OID")}}function Xr(n,t){switch(n){case f.publicKey.ecdsa:case f.publicKey.ecdh:case f.publicKey.eddsaLegacy:return new oe(t).payloadSize;case f.publicKey.ed25519:case f.publicKey.ed448:return $i(n);case f.publicKey.x25519:case f.publicKey.x448:return ns(n);default:throw Error("Unknown elliptic algo")}}const vi=d.getWebCrypto(),jn=d.getNodeCrypto(),kr=jn?jn.getCiphers():[],Oi={idea:kr.includes("idea-cfb")?"idea-cfb":void 0,tripledes:kr.includes("des-ede3-cfb")?"des-ede3-cfb":void 0,cast5:kr.includes("cast5-cfb")?"cast5-cfb":void 0,blowfish:kr.includes("bf-cfb")?"bf-cfb":void 0,aes128:kr.includes("aes-128-cfb")?"aes-128-cfb":void 0,aes192:kr.includes("aes-192-cfb")?"aes-192-cfb":void 0,aes256:kr.includes("aes-256-cfb")?"aes-256-cfb":void 0};function x1(n){const{blockSize:t}=ot(n),r=Dt(t),e=new Uint8Array([r[r.length-2],r[r.length-1]]);return d.concat([r,e])}async function Vn(n,t,r,e,i){const s=f.read(f.symmetric,n);if(d.getNodeCrypto()&&Oi[s])return(function(l,y,g,p){const A=f.read(f.symmetric,l),w=new jn.createCipheriv(Oi[A],y,p);return Et(g,(b=>new Uint8Array(w.update(b))))})(n,t,r,e);if(d.isAES(n))return(async function(l,y,g,p){if(vi&&await So.isSupported(l)){const A=new So(l,y,p);return d.isStream(g)?Xs(g,(w=>A.encryptChunk(w)),(()=>A.finish())):A.encrypt(g)}if(d.isStream(g)){const A=new Q1(!0,l,y,p);return Xs(g,(w=>A.processChunk(w)),(()=>A.finish()))}return u1(y,p).encrypt(g)})(n,t,r,e);const a=new(await g1(n))(t),o=a.blockSize,c=e.slice();let u=new Uint8Array;const h=l=>{l&&(u=d.concatUint8Array([u,l]));const y=new Uint8Array(u.length);let g,p=0;for(;l?u.length>=o:u.length;){const A=a.encrypt(c);for(g=0;g<o;g++)c[g]=u[g]^A[g],y[p++]=c[g];u=u.subarray(o)}return y.subarray(0,p)};return Et(r,h,h)}async function cs(n,t,r,e){const i=f.read(f.symmetric,n);if(jn&&Oi[i])return(function(h,l,y,g){const p=f.read(f.symmetric,h),A=new jn.createDecipheriv(Oi[p],l,g);return Et(y,(w=>new Uint8Array(A.update(w))))})(n,t,r,e);if(d.isAES(n))return(function(h,l,y,g){if(d.isStream(y)){const p=new Q1(!1,h,l,g);return Xs(y,(A=>p.processChunk(A)),(()=>p.finish()))}return u1(l,g).decrypt(y)})(n,t,r,e);const s=new(await g1(n))(t),a=s.blockSize;let o=e,c=new Uint8Array;const u=h=>{h&&(c=d.concatUint8Array([c,h]));const l=new Uint8Array(c.length);let y,g=0;for(;h?c.length>=a:c.length;){const p=s.encrypt(o);for(o=c.subarray(0,a),y=0;y<a;y++)l[g++]=o[y]^p[y];c=c.subarray(a)}return l.subarray(0,g)};return Et(r,u,u)}class So{constructor(t,r,e){const{blockSize:i}=ot(t);this.key=r,this.prevBlock=e,this.nextBlock=new Uint8Array(i),this.i=0,this.blockSize=i,this.zeroBlock=new Uint8Array(this.blockSize)}static isSupported(t){const{keySize:r}=ot(t);return vi.importKey("raw",new Uint8Array(r),"aes-cbc",!1,["encrypt"]).then((()=>!0),(()=>!1))}async _runCBC(t,r){const e="AES-CBC";this.keyRef=this.keyRef||await vi.importKey("raw",this.key,e,!1,["encrypt"]);const i=await vi.encrypt({name:e,iv:r||this.zeroBlock},this.keyRef,t);return new Uint8Array(i).subarray(0,t.length)}async encryptChunk(t){const r=this.nextBlock.length-this.i,e=t.subarray(0,r);if(this.nextBlock.set(e,this.i),this.i+t.length>=2*this.blockSize){const s=(t.length-r)%this.blockSize,a=d.concatUint8Array([this.nextBlock,t.subarray(r,t.length-s)]),o=d.concatUint8Array([this.prevBlock,a.subarray(0,a.length-this.blockSize)]),c=await this._runCBC(o);return oi(c,a),this.prevBlock=c.slice(-this.blockSize),s>0&&this.nextBlock.set(t.subarray(-s)),this.i=s,c}let i;if(this.i+=e.length,this.i===this.nextBlock.length){const s=this.nextBlock;i=await this._runCBC(this.prevBlock),oi(i,s),this.prevBlock=i.slice(),this.i=0;const a=t.subarray(e.length);this.nextBlock.set(a,this.i),this.i+=a.length}else i=new Uint8Array;return i}async finish(){let t;if(this.i===0)t=new Uint8Array;else{this.nextBlock=this.nextBlock.subarray(0,this.i);const r=this.nextBlock,e=await this._runCBC(this.prevBlock);oi(e,r),t=e.subarray(0,r.length)}return this.clearSensitiveData(),t}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.keyRef=null,this.key=null}async encrypt(t){const r=(await this._runCBC(d.concatUint8Array([new Uint8Array(this.blockSize),t]),this.iv)).subarray(0,t.length);return oi(r,t),this.clearSensitiveData(),r}}class Q1{constructor(t,r,e,i){this.forEncryption=t;const{blockSize:s}=ot(r);this.key=mo.expandKeyLE(e),i.byteOffset%4!=0&&(i=i.slice()),this.prevBlock=Ks(i),this.nextBlock=new Uint8Array(s),this.i=0,this.blockSize=s}_runCFB(t){const r=Ks(t),e=new Uint8Array(t.length),i=Ks(e);for(let s=0;s+4<=i.length;s+=4){const{s0:a,s1:o,s2:c,s3:u}=mo.encrypt(this.key,this.prevBlock[0],this.prevBlock[1],this.prevBlock[2],this.prevBlock[3]);i[s+0]=r[s+0]^a,i[s+1]=r[s+1]^o,i[s+2]=r[s+2]^c,i[s+3]=r[s+3]^u,this.prevBlock=(this.forEncryption?i:r).slice(s,s+4)}return e}async processChunk(t){const r=this.nextBlock.length-this.i,e=t.subarray(0,r);if(this.nextBlock.set(e,this.i),this.i+t.length>=2*this.blockSize){const s=(t.length-r)%this.blockSize,a=d.concatUint8Array([this.nextBlock,t.subarray(r,t.length-s)]),o=this._runCFB(a);return s>0&&this.nextBlock.set(t.subarray(-s)),this.i=s,o}let i;if(this.i+=e.length,this.i===this.nextBlock.length){i=this._runCFB(this.nextBlock),this.i=0;const s=t.subarray(e.length);this.nextBlock.set(s,this.i),this.i+=s.length}else i=new Uint8Array;return i}async finish(){let t;return this.i===0?t=new Uint8Array:t=this._runCFB(this.nextBlock).subarray(0,this.i),this.clearSensitiveData(),t}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.key.fill(0)}}function oi(n,t){const r=Math.min(n.length,t.length);for(let e=0;e<r;e++)n[e]=n[e]^t[e]}const Ks=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),Bo=d.getWebCrypto(),G3=d.getNodeCrypto(),Cr=16;function Ko(n,t){const r=n.length-Cr;for(let e=0;e<Cr;e++)n[e+r]^=t[e];return n}const Ii=new Uint8Array(Cr);async function j3(n){const t=await V3(n),r=d.double(await t(Ii)),e=d.double(r);return async function(i){return(await t((function(s,a,o){if(s.length&&s.length%Cr==0)return Ko(s,a);const c=new Uint8Array(s.length+(Cr-s.length%Cr));return c.set(s),c[s.length]=128,Ko(c,o)})(i,r,e))).subarray(-16)}}async function V3(n){if(d.getNodeCrypto())return async function(t){const r=new G3.createCipheriv("aes-"+8*n.length+"-cbc",n,Ii).update(t);return new Uint8Array(r)};if(d.getWebCrypto())try{return n=await Bo.importKey("raw",n,{name:"AES-CBC",length:8*n.length},!1,["encrypt"]),async function(t){const r=await Bo.encrypt({name:"AES-CBC",iv:Ii,length:128},n,t);return new Uint8Array(r).subarray(0,r.byteLength-Cr)}}catch(t){if(t.name!=="NotSupportedError"&&(n.length!==24||t.name!=="OperationError"))throw t;d.printDebugError("Browser did not support operation: "+t.message)}return async function(t){return sa(n,Ii,{disablePadding:!0}).encrypt(t)}}const Co=d.getWebCrypto(),q3=d.getNodeCrypto(),Y3=d.getNodeBuffer(),$n=16,Si=$n,Uo=new Uint8Array($n),la=new Uint8Array($n);la[15]=1;const ya=new Uint8Array($n);async function Z3(n){const t=await j3(n);return function(r,e){return t(d.concatUint8Array([r,e]))}}async function J3(n){if(d.getNodeCrypto())return async function(t,r){const e=new q3.createCipheriv("aes-"+8*n.length+"-ctr",n,r),i=Y3.concat([e.update(t),e.final()]);return new Uint8Array(i)};if(d.getWebCrypto())try{const t=await Co.importKey("raw",n,{name:"AES-CTR",length:8*n.length},!1,["encrypt"]);return async function(r,e){const i=await Co.encrypt({name:"AES-CTR",counter:e,length:128},t,r);return new Uint8Array(i)}}catch(t){if(t.name!=="NotSupportedError"&&(n.length!==24||t.name!=="OperationError"))throw t;d.printDebugError("Browser did not support operation: "+t.message)}return async function(t,r){return C3(n,r).encrypt(t)}}async function xn(n,t){if(n!==f.symmetric.aes128&&n!==f.symmetric.aes192&&n!==f.symmetric.aes256)throw Error("EAX mode supports only AES cipher");const[r,e]=await Promise.all([Z3(t),J3(t)]);return{encrypt:async function(i,s,a){const[o,c]=await Promise.all([r(Uo,s),r(la,a)]),u=await e(i,o),h=await r(ya,u);for(let l=0;l<Si;l++)h[l]^=c[l]^o[l];return d.concatUint8Array([u,h])},decrypt:async function(i,s,a){if(i.length<Si)throw Error("Invalid EAX ciphertext");const o=i.subarray(0,-16),c=i.subarray(-16),[u,h,l]=await Promise.all([r(Uo,s),r(la,a),r(ya,o)]),y=l;for(let g=0;g<Si;g++)y[g]^=h[g]^u[g];if(!d.equalsUint8Array(c,y))throw Error("Authentication tag mismatch");return await e(o,u)}}}ya[15]=2,xn.getNonce=function(n,t){const r=n.slice();for(let e=0;e<t.length;e++)r[8+e]^=t[e];return r},xn.blockLength=$n,xn.ivLength=16,xn.tagLength=Si;const Wt=16,ga=16;function Po(n){let t=0;for(let r=1;!(n&r);r<<=1)t++;return t}function zt(n,t){for(let r=0;r<n.length;r++)n[r]^=t[r];return n}function ci(n,t){return zt(n.slice(),t)}const bn=new Uint8Array(Wt),X3=new Uint8Array([1]);async function Qn(n,t){const{keySize:r}=ot(n);if(!d.isAES(n)||t.length!==r)throw Error("Unexpected algorithm or key size");let e=0;const i=c=>sa(t,bn,{disablePadding:!0}).encrypt(c),s=c=>sa(t,bn,{disablePadding:!0}).decrypt(c);let a;function o(c,u,h,l){const y=u.length/Wt|0;(function(P,S){const E=d.nbits(Math.max(P.length,S.length)/Wt|0)-1;for(let K=e+1;K<=E;K++)a[K]=d.double(a[K-1]);e=E})(u,l);const g=d.concatUint8Array([bn.subarray(0,15-h.length),X3,h]),p=63&g[15];g[15]&=192;const A=i(g),w=d.concatUint8Array([A,ci(A.subarray(0,8),A.subarray(1,9))]),b=d.shiftRight(w.subarray(0+(p>>3),17+(p>>3)),8-(7&p)).subarray(1),v=new Uint8Array(Wt),k=new Uint8Array(u.length+ga);let m,C=0;for(m=0;m<y;m++)zt(b,a[Po(m+1)]),k.set(zt(c(ci(b,u)),b),C),zt(v,c===i?u:k.subarray(C)),u=u.subarray(Wt),C+=Wt;if(u.length){zt(b,a.x);const P=i(b);k.set(ci(u,P),C);const S=new Uint8Array(Wt);S.set(c===i?u:k.subarray(C,-16),0),S[u.length]=128,zt(v,S),C+=u.length}const D=zt(i(zt(zt(v,b),a.$)),(function(P){if(!P.length)return bn;const S=P.length/Wt|0,E=new Uint8Array(Wt),K=new Uint8Array(Wt);for(let I=0;I<S;I++)zt(E,a[Po(I+1)]),zt(K,i(ci(E,P))),P=P.subarray(Wt);if(P.length){zt(E,a.x);const I=new Uint8Array(Wt);I.set(P,0),I[P.length]=128,zt(I,E),zt(K,i(I))}return K})(l));return k.set(D,C),k}return(function(){const c=i(bn),u=d.double(c);a=[],a[0]=d.double(u),a.x=c,a.$=u})(),{encrypt:async function(c,u,h){return o(i,c,u,h)},decrypt:async function(c,u,h){if(c.length<ga)throw Error("Invalid OCB ciphertext");const l=c.subarray(-16);c=c.subarray(0,-16);const y=o(s,c,u,h);if(d.equalsUint8Array(l,y.subarray(-16)))return y.subarray(0,-16);throw Error("Authentication tag mismatch")}}}Qn.getNonce=function(n,t){const r=n.slice();for(let e=0;e<t.length;e++)r[7+e]^=t[e];return r},Qn.blockLength=Wt,Qn.ivLength=15,Qn.tagLength=ga;const Cs=d.getWebCrypto(),Do=d.getNodeCrypto(),xo=d.getNodeBuffer(),Bi=16,Us="AES-GCM";async function Wr(n,t){if(n!==f.symmetric.aes128&&n!==f.symmetric.aes192&&n!==f.symmetric.aes256)throw Error("GCM mode supports only AES cipher");if(d.getNodeCrypto())return{encrypt:async function(r,e,i=new Uint8Array){const s=new Do.createCipheriv("aes-"+8*t.length+"-gcm",t,e);s.setAAD(i);const a=xo.concat([s.update(r),s.final(),s.getAuthTag()]);return new Uint8Array(a)},decrypt:async function(r,e,i=new Uint8Array){const s=new Do.createDecipheriv("aes-"+8*t.length+"-gcm",t,e);s.setAAD(i),s.setAuthTag(r.slice(r.length-Bi,r.length));const a=xo.concat([s.update(r.slice(0,r.length-Bi)),s.final()]);return new Uint8Array(a)}};if(d.getWebCrypto())try{const r=await Cs.importKey("raw",t,{name:Us},!1,["encrypt","decrypt"]),e=navigator.userAgent.match(/Version\/13\.\d(\.\d)* Safari/)||navigator.userAgent.match(/Version\/(13|14)\.\d(\.\d)* Mobile\/\S* Safari/);return{encrypt:async function(i,s,a=new Uint8Array){if(e&&!i.length)return ai(t,s,a).encrypt(i);const o=await Cs.encrypt({name:Us,iv:s,additionalData:a,tagLength:128},r,i);return new Uint8Array(o)},decrypt:async function(i,s,a=new Uint8Array){if(e&&i.length===Bi)return ai(t,s,a).decrypt(i);try{const o=await Cs.decrypt({name:Us,iv:s,additionalData:a,tagLength:128},r,i);return new Uint8Array(o)}catch(o){if(o.name==="OperationError")throw Error("Authentication tag mismatch")}}}}catch(r){if(r.name!=="NotSupportedError"&&(t.length!==24||r.name!=="OperationError"))throw r;d.printDebugError("Browser did not support operation: "+r.message)}return{encrypt:async function(r,e,i){return ai(t,e,i).encrypt(r)},decrypt:async function(r,e,i){return ai(t,e,i).decrypt(r)}}}function Ve(n,t=!1){switch(n){case f.aead.eax:return xn;case f.aead.ocb:return Qn;case f.aead.gcm:return Wr;case f.aead.experimentalGCM:if(!t)throw Error("Unexpected non-standard `experimentalGCM` AEAD algorithm provided in `config.preferredAEADAlgorithm`: use `gcm` instead");return Wr;default:throw Error("Unsupported AEAD mode")}}async function W3(n,t,r,e,i,s){switch(n){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaEncrypt:case f.publicKey.rsaSign:{const{n:a,e:o}=e;return A3(t,i,d.leftPad(r.s,a.length),a,o,s)}case f.publicKey.dsa:{const{g:a,p:o,q:c,y:u}=e,{r:h,s:l}=r;return(async function(y,g,p,A,w,b,v,k){if(g=Z(g),p=Z(p),b=Z(b),v=Z(v),w=Z(w),k=Z(k),g<=Ei||g>=v||p<=Ei||p>=v)return d.printDebug("invalid DSA Signature"),!1;const m=tt(Z(A.subarray(0,Jt(v))),v),C=sn(p,v);if(C===Ei)return d.printDebug("invalid DSA Signature"),!1;w=tt(w,b),k=tt(k,b);const D=tt(m*C,v),P=tt(g*C,v);return tt(tt(Pt(w,D,b)*Pt(k,P,b),b),v)===g})(0,h,l,s,a,o,c,u)}case f.publicKey.ecdsa:{const{oid:a,Q:o}=e,c=new oe(a).payloadSize;return ha(a,t,{r:d.leftPad(r.r,c),s:d.leftPad(r.s,c)},i,o,s)}case f.publicKey.eddsaLegacy:{const{oid:a,Q:o}=e,c=new oe(a).payloadSize;return I1(a,t,{r:d.leftPad(r.r,c),s:d.leftPad(r.s,c)},0,o,s)}case f.publicKey.ed25519:case f.publicKey.ed448:{const{A:a}=e;return Ta(n,t,r,0,a,s)}default:throw Error("Unknown signature algorithm.")}}async function _3(n,t,r,e,i,s){if(!r||!e)throw Error("Missing key parameters");switch(n){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaEncrypt:case f.publicKey.rsaSign:{const{n:a,e:o}=r,{d:c,p:u,q:h,u:l}=e;return{s:await d3(t,i,a,o,c,u,h,l,s)}}case f.publicKey.dsa:{const{g:a,p:o,q:c}=r,{x:u}=e;return(async function(h,l,y,g,p,A){const w=BigInt(0);let b,v,k,m;g=Z(g),p=Z(p),y=Z(y),A=Z(A),y=tt(y,g),A=tt(A,p);const C=tt(Z(l.subarray(0,Jt(p))),p);for(;;){if(b=lr(Dn,p),v=tt(Pt(y,b,g),p),v===w)continue;const D=tt(A*v,p);if(m=tt(C+D,p),k=tt(sn(b,p)*m,p),k!==w)break}return{r:kt(v,"be",Jt(g)),s:kt(k,"be",Jt(g))}})(0,s,a,o,c,u)}case f.publicKey.elgamal:throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");case f.publicKey.ecdsa:{const{oid:a,Q:o}=r,{d:c}=e;return ua(a,t,i,o,c,s)}case f.publicKey.eddsaLegacy:{const{oid:a,Q:o}=r,{seed:c}=e;return v1(a,t,0,o,c,s)}case f.publicKey.ed25519:case f.publicKey.ed448:{const{A:a}=r,{seed:o}=e;return Ra(n,t,0,a,o,s)}default:throw Error("Unknown signature algorithm.")}}Wr.getNonce=function(n,t){const r=n.slice();for(let e=0;e<t.length;e++)r[4+e]^=t[e];return r},Wr.blockLength=16,Wr.ivLength=12,Wr.tagLength=Bi;class us extends Error{constructor(...t){super(...t),Error.captureStackTrace&&Error.captureStackTrace(this,us),this.name="Argon2OutOfMemoryError"}}let ui,kn;class $3{constructor(t=G){const{passes:r,parallelism:e,memoryExponent:i}=t.s2kArgon2Params;this.type="argon2",this.salt=null,this.t=r,this.p=e,this.encodedM=i}generateSalt(){this.salt=Dt(16)}read(t){let r=0;return this.salt=t.subarray(r,r+16),r+=16,this.t=t[r++],this.p=t[r++],this.encodedM=t[r++],r}write(){const t=[new Uint8Array([f.write(f.s2k,this.type)]),this.salt,new Uint8Array([this.t,this.p,this.encodedM])];return d.concatUint8Array(t)}async produceKey(t,r){const e=2<<this.encodedM-1;try{ui=ui||(await Promise.resolve().then((function(){return v5}))).default,kn=kn||ui();const i=await kn,s=i({version:19,type:2,password:d.encodeUTF8(t),salt:this.salt,tagLength:r,memorySize:e,parallelism:this.p,passes:this.t});return e>1048576&&(kn=ui(),kn.catch((()=>{}))),s}catch(i){throw i.message&&(i.message.includes("Unable to grow instance memory")||i.message.includes("failed to grow memory")||i.message.includes("WebAssembly.Memory.grow")||i.message.includes("Out of memory"))?new us("Could not allocate required memory for Argon2"):i}}}class tu{constructor(t,r=G){this.algorithm=f.hash.sha256,this.type=f.read(f.s2k,t),this.c=r.s2kIterationCountByte,this.salt=null}generateSalt(){switch(this.type){case"salted":case"iterated":this.salt=Dt(8)}}getCount(){return 16+(15&this.c)<<6+(this.c>>4)}read(t){let r=0;switch(this.algorithm=t[r++],this.type){case"simple":break;case"salted":this.salt=t.subarray(r,r+8),r+=8;break;case"iterated":this.salt=t.subarray(r,r+8),r+=8,this.c=t[r++];break;case"gnu":if(d.uint8ArrayToString(t.subarray(r,r+3))!=="GNU")throw new it("Unknown s2k type.");if(r+=3,1e3+t[r++]!==1001)throw new it("Unknown s2k gnu protection mode.");this.type="gnu-dummy";break;default:throw new it("Unknown s2k type.")}return r}write(){if(this.type==="gnu-dummy")return new Uint8Array([101,0,...d.stringToUint8Array("GNU"),1]);const t=[new Uint8Array([f.write(f.s2k,this.type),this.algorithm])];switch(this.type){case"simple":break;case"salted":t.push(this.salt);break;case"iterated":t.push(this.salt),t.push(new Uint8Array([this.c]));break;case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}return d.concatUint8Array(t)}async produceKey(t,r){t=d.encodeUTF8(t);const e=[];let i=0,s=0;for(;i<r;){let a;switch(this.type){case"simple":a=d.concatUint8Array([new Uint8Array(s),t]);break;case"salted":a=d.concatUint8Array([new Uint8Array(s),this.salt,t]);break;case"iterated":{const c=d.concatUint8Array([this.salt,t]);let u=c.length;const h=Math.max(this.getCount(),u);a=new Uint8Array(s+h),a.set(c,s);for(let l=s+u;l<h;l+=u,u*=2)a.copyWithin(l,s,l);break}case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}const o=await Qe(this.algorithm,a);e.push(o),i+=o.length,s++}return d.concatUint8Array(e).subarray(0,r)}}const eu=new Set([f.s2k.argon2,f.s2k.iterated]);function Hi(n,t=G){switch(n){case f.s2k.argon2:return new $3(t);case f.s2k.iterated:case f.s2k.gnu:case f.s2k.salted:case f.s2k.simple:return new tu(n,t);default:throw new it("Unsupported S2K type")}}function M1(n){const{s2kType:t}=n;if(!eu.has(t))throw Error("The provided `config.s2kType` value is not allowed");return Hi(t,n)}var bt=Uint8Array,$t=Uint16Array,qa=Int32Array,hs=new bt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),fs=new bt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),pa=new bt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),R1=function(n,t){for(var r=new $t(31),e=0;e<31;++e)r[e]=t+=1<<n[e-1];var i=new qa(r[30]);for(e=1;e<30;++e)for(var s=r[e];s<r[e+1];++s)i[s]=s-r[e]<<5|e;return{b:r,r:i}},T1=R1(hs,2),F1=T1.b,da=T1.r;F1[28]=258,da[258]=28;for(var Qo=R1(fs,0),ru=Qo.b,Mo=Qo.r,Aa=new $t(32768),ht=0;ht<32768;++ht){var Er=(43690&ht)>>1|(21845&ht)<<1;Er=(61680&(Er=(52428&Er)>>2|(13107&Er)<<2))>>4|(3855&Er)<<4,Aa[ht]=((65280&Er)>>8|(255&Er)<<8)>>1}var Pe=function(n,t,r){for(var e=n.length,i=0,s=new $t(t);i<e;++i)n[i]&&++s[n[i]-1];var a,o=new $t(t);for(i=1;i<t;++i)o[i]=o[i-1]+s[i-1]<<1;if(r){a=new $t(1<<t);var c=15-t;for(i=0;i<e;++i)if(n[i])for(var u=i<<4|n[i],h=t-n[i],l=o[n[i]-1]++<<h,y=l|(1<<h)-1;l<=y;++l)a[Aa[l]>>c]=u}else for(a=new $t(e),i=0;i<e;++i)n[i]&&(a[i]=Aa[o[n[i]-1]++]>>15-n[i]);return a},dr=new bt(288);for(ht=0;ht<144;++ht)dr[ht]=8;for(ht=144;ht<256;++ht)dr[ht]=9;for(ht=256;ht<280;++ht)dr[ht]=7;for(ht=280;ht<288;++ht)dr[ht]=8;var qn=new bt(32);for(ht=0;ht<32;++ht)qn[ht]=5;var nu=Pe(dr,9,0),iu=Pe(dr,9,1),su=Pe(qn,5,0),au=Pe(qn,5,1),Ps=function(n){for(var t=n[0],r=1;r<n.length;++r)n[r]>t&&(t=n[r]);return t},he=function(n,t,r){var e=t/8|0;return(n[e]|n[e+1]<<8)>>(7&t)&r},Ds=function(n,t){var r=t/8|0;return(n[r]|n[r+1]<<8|n[r+2]<<16)>>(7&t)},Ya=function(n){return(n+7)/8|0},Mn=function(n,t,r){return(t==null||t<0)&&(t=0),(r==null||r>n.length)&&(r=n.length),new bt(n.subarray(t,r))},ou=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Ct=function(n,t,r){var e=Error(t||ou[n]);if(e.code=n,Error.captureStackTrace&&Error.captureStackTrace(e,Ct),!r)throw e;return e},Te=function(n,t,r){r<<=7&t;var e=t/8|0;n[e]|=r,n[e+1]|=r>>8},En=function(n,t,r){r<<=7&t;var e=t/8|0;n[e]|=r,n[e+1]|=r>>8,n[e+2]|=r>>16},xs=function(n,t){for(var r=[],e=0;e<n.length;++e)n[e]&&r.push({s:e,f:n[e]});var i=r.length,s=r.slice();if(!i)return{t:N1,l:0};if(i==1){var a=new bt(r[0].s+1);return a[r[0].s]=1,{t:a,l:1}}r.sort((function(C,D){return C.f-D.f})),r.push({s:-1,f:25001});var o=r[0],c=r[1],u=0,h=1,l=2;for(r[0]={s:-1,f:o.f+c.f,l:o,r:c};h!=i-1;)o=r[r[u].f<r[l].f?u++:l++],c=r[u!=h&&r[u].f<r[l].f?u++:l++],r[h++]={s:-1,f:o.f+c.f,l:o,r:c};var y=s[0].s;for(e=1;e<i;++e)s[e].s>y&&(y=s[e].s);var g=new $t(y+1),p=wa(r[h-1],g,0);if(p>t){e=0;var A=0,w=p-t,b=1<<w;for(s.sort((function(C,D){return g[D.s]-g[C.s]||C.f-D.f}));e<i;++e){var v=s[e].s;if(!(g[v]>t))break;A+=b-(1<<p-g[v]),g[v]=t}for(A>>=w;A>0;){var k=s[e].s;g[k]<t?A-=1<<t-g[k]++-1:++e}for(;e>=0&&A;--e){var m=s[e].s;g[m]==t&&(--g[m],++A)}p=t}return{t:new bt(g),l:p}},wa=function(n,t,r){return n.s==-1?Math.max(wa(n.l,t,r+1),wa(n.r,t,r+1)):t[n.s]=r},Ro=function(n){for(var t=n.length;t&&!n[--t];);for(var r=new $t(++t),e=0,i=n[0],s=1,a=function(c){r[e++]=c},o=1;o<=t;++o)if(n[o]==i&&o!=t)++s;else{if(!i&&s>2){for(;s>138;s-=138)a(32754);s>2&&(a(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(a(i),--s;s>6;s-=6)a(8304);s>2&&(a(s-3<<5|8208),s=0)}for(;s--;)a(i);s=1,i=n[o]}return{c:r.subarray(0,e),n:t}},vn=function(n,t){for(var r=0,e=0;e<t.length;++e)r+=n[e]*t[e];return r},L1=function(n,t,r){var e=r.length,i=Ya(t+2);n[i]=255&e,n[i+1]=e>>8,n[i+2]=255^n[i],n[i+3]=255^n[i+1];for(var s=0;s<e;++s)n[i+s+4]=r[s];return 8*(i+4+e)},To=function(n,t,r,e,i,s,a,o,c,u,h){Te(t,h++,r),++i[256];for(var l=xs(i,15),y=l.t,g=l.l,p=xs(s,15),A=p.t,w=p.l,b=Ro(y),v=b.c,k=b.n,m=Ro(A),C=m.c,D=m.n,P=new $t(19),S=0;S<v.length;++S)++P[31&v[S]];for(S=0;S<C.length;++S)++P[31&C[S]];for(var E=xs(P,7),K=E.t,I=E.l,B=19;B>4&&!K[pa[B-1]];--B);var U,x,M,Q,R=u+5<<3,N=vn(i,dr)+vn(s,qn)+a,T=vn(i,y)+vn(s,A)+a+14+3*B+vn(P,K)+2*P[16]+3*P[17]+7*P[18];if(c>=0&&R<=N&&R<=T)return L1(t,h,n.subarray(c,c+u));if(Te(t,h,1+(T<N)),h+=2,T<N){U=Pe(y,g,0),x=y,M=Pe(A,w,0),Q=A;var F=Pe(K,I,0);for(Te(t,h,k-257),Te(t,h+5,D-1),Te(t,h+10,B-4),h+=14,S=0;S<B;++S)Te(t,h+3*S,K[pa[S]]);h+=3*B;for(var z=[v,C],L=0;L<2;++L){var O=z[L];for(S=0;S<O.length;++S){var H=31&O[S];Te(t,h,F[H]),h+=K[H],H>15&&(Te(t,h,O[S]>>5&127),h+=O[S]>>12)}}}else U=nu,x=dr,M=su,Q=qn;for(S=0;S<o;++S){var j=e[S];if(j>255){En(t,h,U[(H=j>>18&31)+257]),h+=x[H+257],H>7&&(Te(t,h,j>>23&31),h+=hs[H]);var V=31&j;En(t,h,M[V]),h+=Q[V],V>3&&(En(t,h,j>>5&8191),h+=fs[V])}else En(t,h,U[j]),h+=x[j]}return En(t,h,U[256]),h+x[256]},cu=new qa([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),N1=new bt(0),Fo=function(){var n=1,t=0;return{p:function(r){for(var e=n,i=t,s=0|r.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=e+=r[a];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}n=e,t=i},d:function(){return(255&(n%=65521))<<24|(65280&n)<<8|(255&(t%=65521))<<8|t>>8}}},O1=function(n,t,r,e,i){if(!i&&(i={l:1},t.dictionary)){var s=t.dictionary.subarray(-32768),a=new bt(s.length+n.length);a.set(s),a.set(n,s.length),n=a,i.w=s.length}return(function(o,c,u,h,l,y){var g=y.z||o.length,p=new bt(h+g+5*(1+Math.ceil(g/7e3))+l),A=p.subarray(h,p.length-l),w=y.l,b=7&(y.r||0);if(c){b&&(A[0]=y.r>>3);for(var v=cu[c-1],k=v>>13,m=8191&v,C=(1<<u)-1,D=y.p||new $t(32768),P=y.h||new $t(C+1),S=Math.ceil(u/3),E=2*S,K=function(ks){return(o[ks]^o[ks+1]<<S^o[ks+2]<<E)&C},I=new qa(25e3),B=new $t(288),U=new $t(32),x=0,M=0,Q=y.i||0,R=0,N=y.w||0,T=0;Q+2<g;++Q){var F=K(Q),z=32767&Q,L=P[F];if(D[z]=L,P[F]=z,N<=Q){var O=g-Q;if((x>7e3||R>24576)&&(O>423||!w)){b=To(o,A,0,I,B,U,M,R,T,Q-T,b),R=x=M=0,T=Q;for(var H=0;H<286;++H)B[H]=0;for(H=0;H<30;++H)U[H]=0}var j=2,V=0,J=m,q=z-L&32767;if(O>2&&F==K(Q-q))for(var $=Math.min(k,O)-1,_=Math.min(32767,Q),nt=Math.min(258,O);q<=_&&--J&&z!=L;){if(o[Q+j]==o[Q+j-q]){for(var W=0;W<nt&&o[Q+W]==o[Q+W-q];++W);if(W>j){if(j=W,V=q,W>$)break;var pt=Math.min(q,W-2),At=0;for(H=0;H<pt;++H){var dt=Q-q+H&32767,An=dt-D[dt]&32767;An>At&&(At=An,L=dt)}}}q+=(z=L)-(L=D[z])&32767}if(V){I[R++]=268435456|da[j]<<18|Mo[V];var io=31&da[j],so=31&Mo[V];M+=hs[io]+fs[so],++B[257+io],++U[so],N=Q+j,++x}else I[R++]=o[Q],++B[o[Q]]}}for(Q=Math.max(Q,N);Q<g;++Q)I[R++]=o[Q],++B[o[Q]];b=To(o,A,w,I,B,U,M,R,T,Q-T,b),w||(y.r=7&b|A[b/8|0]<<3,b-=7,y.h=P,y.p=D,y.i=Q,y.w=N)}else{for(Q=y.w||0;Q<g+w;Q+=65535){var bs=Q+65535;bs>=g&&(A[b/8|0]=w,bs=g),b=L1(A,b+1,o.subarray(Q,bs))}y.i=g}return Mn(p,0,h+Ya(b)+l)})(n,t.level==null?6:t.level,t.mem==null?i.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(n.length)))):20:12+t.mem,r,e,i)},Lo=function(n,t,r){for(;r;++t)n[t]=r,r>>>=8},Ki=(function(){function n(t,r){if(typeof t=="function"&&(r=t,t={}),this.ondata=r,this.o=t||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new bt(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,r){this.ondata(O1(t,this.o,0,0,this.s),r)},n.prototype.push=function(t,r){this.ondata||Ct(5),this.s.l&&Ct(4);var e=t.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new bt(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var s=this.b.length-this.s.z;this.b.set(t.subarray(0,s),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(t.subarray(s),32768),this.s.z=t.length-s+32768,this.s.i=32766,this.s.w=32768}else this.b.set(t,this.s.z),this.s.z+=t.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n.prototype.flush=function(){this.ondata||Ct(5),this.s.l&&Ct(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},n})(),Ci=(function(){function n(t,r){typeof t=="function"&&(r=t,t={}),this.ondata=r;var e=t&&t.dictionary&&t.dictionary.subarray(-32768);this.s={i:0,b:e?e.length:0},this.o=new bt(32768),this.p=new bt(0),e&&this.o.set(e)}return n.prototype.e=function(t){if(this.ondata||Ct(5),this.d&&Ct(4),this.p.length){if(t.length){var r=new bt(this.p.length+t.length);r.set(this.p),r.set(t,this.p.length),this.p=r}}else this.p=t},n.prototype.c=function(t){this.s.i=+(this.d=t||!1);var r=this.s.b,e=(function(i,s,a,o){var c=i.length;if(!c||s.f&&!s.l)return a||new bt(0);var u=!a,h=u||s.i!=2,l=s.i;u&&(a=new bt(3*c));var y=function(At){var dt=a.length;if(At>dt){var An=new bt(Math.max(2*dt,At));An.set(a),a=An}},g=s.f||0,p=s.p||0,A=s.b||0,w=s.l,b=s.d,v=s.m,k=s.n,m=8*c;do{if(!w){g=he(i,p,1);var C=he(i,p+1,3);if(p+=3,!C){var D=i[(R=Ya(p)+4)-4]|i[R-3]<<8,P=R+D;if(P>c){l&&Ct(0);break}h&&y(A+D),a.set(i.subarray(R,P),A),s.b=A+=D,s.p=p=8*P,s.f=g;continue}if(C==1)w=iu,b=au,v=9,k=5;else if(C==2){var S=he(i,p,31)+257,E=he(i,p+10,15)+4,K=S+he(i,p+5,31)+1;p+=14;for(var I=new bt(K),B=new bt(19),U=0;U<E;++U)B[pa[U]]=he(i,p+3*U,7);p+=3*E;var x=Ps(B),M=(1<<x)-1,Q=Pe(B,x,1);for(U=0;U<K;){var R,N=Q[he(i,p,M)];if(p+=15&N,(R=N>>4)<16)I[U++]=R;else{var T=0,F=0;for(R==16?(F=3+he(i,p,3),p+=2,T=I[U-1]):R==17?(F=3+he(i,p,7),p+=3):R==18&&(F=11+he(i,p,127),p+=7);F--;)I[U++]=T}}var z=I.subarray(0,S),L=I.subarray(S);v=Ps(z),k=Ps(L),w=Pe(z,v,1),b=Pe(L,k,1)}else Ct(1);if(p>m){l&&Ct(0);break}}h&&y(A+131072);for(var O=(1<<v)-1,H=(1<<k)-1,j=p;;j=p){var V=(T=w[Ds(i,p)&O])>>4;if((p+=15&T)>m){l&&Ct(0);break}if(T||Ct(2),V<256)a[A++]=V;else{if(V==256){j=p,w=null;break}var J=V-254;if(V>264){var q=hs[U=V-257];J=he(i,p,(1<<q)-1)+F1[U],p+=q}var $=b[Ds(i,p)&H],_=$>>4;if($||Ct(3),p+=15&$,L=ru[_],_>3&&(q=fs[_],L+=Ds(i,p)&(1<<q)-1,p+=q),p>m){l&&Ct(0);break}h&&y(A+131072);var nt=A+J;if(A<L){var W=0-L,pt=Math.min(L,nt);for(W+A<0&&Ct(3);A<pt;++A)a[A]=o[W+A]}for(;A<nt;++A)a[A]=a[A-L]}}s.l=w,s.p=j,s.b=A,s.f=g,w&&(g=1,s.m=v,s.d=b,s.n=k)}while(!g);return A!=a.length&&u?Mn(a,0,A):a.subarray(0,A)})(this.p,this.s,this.o);this.ondata(Mn(e,r,this.s.b),this.d),this.o=Mn(e,this.s.b-32768),this.s.b=this.o.length,this.p=Mn(this.p,this.s.p/8|0),this.s.p&=7},n.prototype.push=function(t,r){this.e(t),this.c(r)},n})(),uu=(function(){function n(t,r){this.c=Fo(),this.v=1,Ki.call(this,t,r)}return n.prototype.push=function(t,r){this.c.p(t),Ki.prototype.push.call(this,t,r)},n.prototype.p=function(t,r){var e=O1(t,this.o,this.v&&(this.o.dictionary?6:2),r&&4,this.s);this.v&&((function(i,s){var a=s.level,o=a==0?0:a<6?1:a==9?3:2;if(i[0]=120,i[1]=o<<6|(s.dictionary&&32),i[1]|=31-(i[0]<<8|i[1])%31,s.dictionary){var c=Fo();c.p(s.dictionary),Lo(i,2,c.d())}})(e,this.o),this.v=0),r&&Lo(e,e.length-4,this.c.d()),this.ondata(e,r)},n.prototype.flush=function(){Ki.prototype.flush.call(this)},n})(),hu=(function(){function n(t,r){Ci.call(this,t,r),this.v=t&&t.dictionary?2:1}return n.prototype.push=function(t,r){if(Ci.prototype.e.call(this,t),this.v){if(this.p.length<6&&!r)return;this.p=this.p.subarray((e=this.p,i=this.v-1,((15&e[0])!=8||e[0]>>4>7||(e[0]<<8|e[1])%31)&&Ct(6,"invalid zlib data"),(e[1]>>5&1)==+!i&&Ct(6,"invalid zlib data: "+(32&e[1]?"need":"unexpected")+" dictionary"),2+(e[1]>>3&4))),this.v=0}var e,i;r&&(this.p.length<4&&Ct(6,"invalid zlib data"),this.p=this.p.subarray(0,-4)),Ci.prototype.c.call(this,r)},n})(),fu=typeof TextDecoder<"u"&&new TextDecoder;try{fu.decode(N1,{stream:!0})}catch{}class Ar{static get tag(){return f.packet.literalData}constructor(t=new Date){this.format=f.literal.utf8,this.date=d.normalizeDate(t),this.text=null,this.data=null,this.filename=""}setText(t,r=f.literal.utf8){this.format=r,this.text=t,this.data=null}getText(t=!1){return(this.text===null||d.isStream(this.text))&&(this.text=d.decodeUTF8(d.nativeEOL(this.getBytes(t)))),this.text}setBytes(t,r){this.format=r,this.data=t,this.text=null}getBytes(t=!1){return this.data===null&&(this.data=d.canonicalizeEOL(d.encodeUTF8(this.text))),t?On(this.data):this.data}setFilename(t){this.filename=t}getFilename(){return this.filename}async read(t){await Wi(t,(async r=>{const e=await r.readByte(),i=await r.readByte();this.filename=d.decodeUTF8(await r.readBytes(i)),this.date=d.readDate(await r.readBytes(4));let s=r.remainder();gt(s)&&(s=await mt(s)),this.setBytes(s,e)}))}writeHeader(){const t=d.encodeUTF8(this.filename),r=new Uint8Array([t.length]),e=new Uint8Array([this.format]),i=d.writeDate(this.date);return d.concatUint8Array([e,r,t,i])}write(){const t=this.writeHeader(),r=this.getBytes();return d.concat([t,r])}}class De{constructor(){this.bytes=""}read(t){return this.bytes=d.uint8ArrayToString(t.subarray(0,8)),this.bytes.length}write(){return d.stringToUint8Array(this.bytes)}toHex(){return d.uint8ArrayToHex(d.stringToUint8Array(this.bytes))}equals(t,r=!1){return r&&(t.isWildcard()||this.isWildcard())||this.bytes===t.bytes}isNull(){return this.bytes===""}isWildcard(){return/^0+$/.test(this.toHex())}static mapToHex(t){return t.toHex()}static fromID(t){const r=new De;return r.read(d.hexToUint8Array(t)),r}static wildcard(){const t=new De;return t.read(new Uint8Array(8)),t}}const In=Symbol("verified"),No="salt@notations.openpgpjs.org",lu=new Set([f.signatureSubpacket.issuerKeyID,f.signatureSubpacket.issuerFingerprint,f.signatureSubpacket.embeddedSignature]);class Bt{static get tag(){return f.packet.signature}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.signatureData=null,this.unhashedSubpackets=[],this.unknownSubpackets=[],this.signedHashValue=null,this.salt=null,this.created=null,this.signatureExpirationTime=null,this.signatureNeverExpires=!0,this.exportable=null,this.trustLevel=null,this.trustAmount=null,this.regularExpression=null,this.revocable=null,this.keyExpirationTime=null,this.keyNeverExpires=null,this.preferredSymmetricAlgorithms=null,this.revocationKeyClass=null,this.revocationKeyAlgorithm=null,this.revocationKeyFingerprint=null,this.issuerKeyID=new De,this.rawNotations=[],this.notations={},this.preferredHashAlgorithms=null,this.preferredCompressionAlgorithms=null,this.keyServerPreferences=null,this.preferredKeyServer=null,this.isPrimaryUserID=null,this.policyURI=null,this.keyFlags=null,this.signersUserID=null,this.reasonForRevocationFlag=null,this.reasonForRevocationString=null,this.features=null,this.signatureTargetPublicKeyAlgorithm=null,this.signatureTargetHashAlgorithm=null,this.signatureTargetHash=null,this.embeddedSignature=null,this.issuerKeyVersion=null,this.issuerFingerprint=null,this.preferredAEADAlgorithms=null,this.preferredCipherSuites=null,this.revoked=null,this[In]=null}read(t,r=G){let e=0;if(this.version=t[e++],this.version===5&&!r.enableParsingV5Entities)throw new it("Support for v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(this.version!==4&&this.version!==5&&this.version!==6)throw new it(`Version ${this.version} of the signature packet is unsupported.`);if(this.signatureType=t[e++],this.publicKeyAlgorithm=t[e++],this.hashAlgorithm=t[e++],e+=this.readSubPackets(t.subarray(e,t.length),!0),!this.created)throw Error("Missing signature creation time subpacket.");if(this.signatureData=t.subarray(0,e),e+=this.readSubPackets(t.subarray(e,t.length),!1),this.signedHashValue=t.subarray(e,e+2),e+=2,this.version===6){const o=t[e++];this.salt=t.subarray(e,e+o),e+=o}const i=t.subarray(e,t.length),{read:s,signatureParams:a}=(function(o,c){let u=0;switch(o){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaEncrypt:case f.publicKey.rsaSign:{const h=d.readMPI(c.subarray(u));return u+=h.length+2,{read:u,signatureParams:{s:h}}}case f.publicKey.dsa:case f.publicKey.ecdsa:{const h=d.readMPI(c.subarray(u));u+=h.length+2;const l=d.readMPI(c.subarray(u));return u+=l.length+2,{read:u,signatureParams:{r:h,s:l}}}case f.publicKey.eddsaLegacy:{const h=d.readMPI(c.subarray(u));u+=h.length+2;const l=d.readMPI(c.subarray(u));return u+=l.length+2,{read:u,signatureParams:{r:h,s:l}}}case f.publicKey.ed25519:case f.publicKey.ed448:{const h=2*$i(o),l=d.readExactSubarray(c,u,u+h);return u+=l.length,{read:u,signatureParams:{RS:l}}}default:throw new it("Unknown signature algorithm.")}})(this.publicKeyAlgorithm,i);if(s<i.length)throw Error("Error reading MPIs");this.params=a}writeParams(){return this.params instanceof Promise?wr((async()=>on(this.publicKeyAlgorithm,await this.params))):on(this.publicKeyAlgorithm,this.params)}write(){const t=[];return t.push(this.signatureData),t.push(this.writeUnhashedSubPackets()),t.push(this.signedHashValue),this.version===6&&(t.push(new Uint8Array([this.salt.length])),t.push(this.salt)),t.push(this.writeParams()),d.concat(t)}async sign(t,r,e=new Date,i=!1,s){this.version=t.version,this.created=d.normalizeDate(e),this.issuerKeyVersion=t.version,this.issuerFingerprint=t.getFingerprintBytes(),this.issuerKeyID=t.getKeyID();const a=[new Uint8Array([this.version,this.signatureType,this.publicKeyAlgorithm,this.hashAlgorithm])];if(this.version===6){const h=Qs(this.hashAlgorithm);if(this.salt===null)this.salt=Dt(h);else if(h!==this.salt.length)throw Error("Provided salt does not have the required length")}else if(s.nonDeterministicSignaturesViaNotation){if(this.rawNotations.filter((({name:h})=>h===No)).length!==0)throw Error("Unexpected existing salt notation");{const h=Dt(Qs(this.hashAlgorithm));this.rawNotations.push({name:No,value:h,humanReadable:!1,critical:!1})}}a.push(this.writeHashedSubPackets()),this.unhashedSubpackets=[],this.signatureData=d.concat(a);const o=this.toHash(this.signatureType,r,i),c=await this.hash(this.signatureType,r,o,i);this.signedHashValue=Qt(Qr(c),0,2);const u=async()=>_3(this.publicKeyAlgorithm,this.hashAlgorithm,t.publicParams,t.privateParams,o,await mt(c));d.isStream(c)?this.params=u():(this.params=await u(),this[In]=!0)}writeHashedSubPackets(){const t=f.signatureSubpacket,r=[];let e;if(this.created===null)throw Error("Missing signature creation time");r.push(at(t.signatureCreationTime,!0,d.writeDate(this.created))),this.signatureExpirationTime!==null&&r.push(at(t.signatureExpirationTime,!0,d.writeNumber(this.signatureExpirationTime,4))),this.exportable!==null&&r.push(at(t.exportableCertification,!0,new Uint8Array([this.exportable?1:0]))),this.trustLevel!==null&&(e=new Uint8Array([this.trustLevel,this.trustAmount]),r.push(at(t.trustSignature,!0,e))),this.regularExpression!==null&&r.push(at(t.regularExpression,!0,this.regularExpression)),this.revocable!==null&&r.push(at(t.revocable,!0,new Uint8Array([this.revocable?1:0]))),this.keyExpirationTime!==null&&r.push(at(t.keyExpirationTime,!0,d.writeNumber(this.keyExpirationTime,4))),this.preferredSymmetricAlgorithms!==null&&(e=d.stringToUint8Array(d.uint8ArrayToString(this.preferredSymmetricAlgorithms)),r.push(at(t.preferredSymmetricAlgorithms,!1,e))),this.revocationKeyClass!==null&&(e=new Uint8Array([this.revocationKeyClass,this.revocationKeyAlgorithm]),e=d.concat([e,this.revocationKeyFingerprint]),r.push(at(t.revocationKey,!1,e))),!this.issuerKeyID.isNull()&&this.issuerKeyVersion<5&&r.push(at(t.issuerKeyID,!1,this.issuerKeyID.write())),this.rawNotations.forEach((({name:a,value:o,humanReadable:c,critical:u})=>{e=[new Uint8Array([c?128:0,0,0,0])];const h=d.encodeUTF8(a);e.push(d.writeNumber(h.length,2)),e.push(d.writeNumber(o.length,2)),e.push(h),e.push(o),e=d.concat(e),r.push(at(t.notationData,u,e))})),this.preferredHashAlgorithms!==null&&(e=d.stringToUint8Array(d.uint8ArrayToString(this.preferredHashAlgorithms)),r.push(at(t.preferredHashAlgorithms,!1,e))),this.preferredCompressionAlgorithms!==null&&(e=d.stringToUint8Array(d.uint8ArrayToString(this.preferredCompressionAlgorithms)),r.push(at(t.preferredCompressionAlgorithms,!1,e))),this.keyServerPreferences!==null&&(e=d.stringToUint8Array(d.uint8ArrayToString(this.keyServerPreferences)),r.push(at(t.keyServerPreferences,!1,e))),this.preferredKeyServer!==null&&r.push(at(t.preferredKeyServer,!1,d.encodeUTF8(this.preferredKeyServer))),this.isPrimaryUserID!==null&&r.push(at(t.primaryUserID,!1,new Uint8Array([this.isPrimaryUserID?1:0]))),this.policyURI!==null&&r.push(at(t.policyURI,!1,d.encodeUTF8(this.policyURI))),this.keyFlags!==null&&(e=d.stringToUint8Array(d.uint8ArrayToString(this.keyFlags)),r.push(at(t.keyFlags,!0,e))),this.signersUserID!==null&&r.push(at(t.signersUserID,!1,d.encodeUTF8(this.signersUserID))),this.reasonForRevocationFlag!==null&&(e=d.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag)+this.reasonForRevocationString),r.push(at(t.reasonForRevocation,!0,e))),this.features!==null&&(e=d.stringToUint8Array(d.uint8ArrayToString(this.features)),r.push(at(t.features,!1,e))),this.signatureTargetPublicKeyAlgorithm!==null&&(e=[new Uint8Array([this.signatureTargetPublicKeyAlgorithm,this.signatureTargetHashAlgorithm])],e.push(d.stringToUint8Array(this.signatureTargetHash)),e=d.concat(e),r.push(at(t.signatureTarget,!0,e))),this.embeddedSignature!==null&&r.push(at(t.embeddedSignature,!0,this.embeddedSignature.write())),this.issuerFingerprint!==null&&(e=[new Uint8Array([this.issuerKeyVersion]),this.issuerFingerprint],e=d.concat(e),r.push(at(t.issuerFingerprint,this.version>=5,e))),this.preferredAEADAlgorithms!==null&&(e=d.stringToUint8Array(d.uint8ArrayToString(this.preferredAEADAlgorithms)),r.push(at(t.preferredAEADAlgorithms,!1,e))),this.preferredCipherSuites!==null&&(e=new Uint8Array([].concat(...this.preferredCipherSuites)),r.push(at(t.preferredCipherSuites,!1,e)));const i=d.concat(r),s=d.writeNumber(i.length,this.version===6?4:2);return d.concat([s,i])}writeUnhashedSubPackets(){const t=this.unhashedSubpackets.map((({type:i,critical:s,body:a})=>at(i,s,a))),r=d.concat(t),e=d.writeNumber(r.length,this.version===6?4:2);return d.concat([e,r])}readSubPacket(t,r=!0){let e=0;const i=!!(128&t[e]),s=127&t[e];if(e++,r||(this.unhashedSubpackets.push({type:s,critical:i,body:t.subarray(e,t.length)}),lu.has(s)))switch(s){case f.signatureSubpacket.signatureCreationTime:this.created=d.readDate(t.subarray(e,t.length));break;case f.signatureSubpacket.signatureExpirationTime:{const a=d.readNumber(t.subarray(e,t.length));this.signatureNeverExpires=a===0,this.signatureExpirationTime=a;break}case f.signatureSubpacket.exportableCertification:this.exportable=t[e++]===1;break;case f.signatureSubpacket.trustSignature:this.trustLevel=t[e++],this.trustAmount=t[e++];break;case f.signatureSubpacket.regularExpression:this.regularExpression=t[e];break;case f.signatureSubpacket.revocable:this.revocable=t[e++]===1;break;case f.signatureSubpacket.keyExpirationTime:{const a=d.readNumber(t.subarray(e,t.length));this.keyExpirationTime=a,this.keyNeverExpires=a===0;break}case f.signatureSubpacket.preferredSymmetricAlgorithms:this.preferredSymmetricAlgorithms=[...t.subarray(e,t.length)];break;case f.signatureSubpacket.revocationKey:this.revocationKeyClass=t[e++],this.revocationKeyAlgorithm=t[e++],this.revocationKeyFingerprint=t.subarray(e,e+20);break;case f.signatureSubpacket.issuerKeyID:if(this.version===4)this.issuerKeyID.read(t.subarray(e,t.length));else if(r)throw Error("Unexpected Issuer Key ID subpacket");break;case f.signatureSubpacket.notationData:{const a=!!(128&t[e]);e+=4;const o=d.readNumber(t.subarray(e,e+2));e+=2;const c=d.readNumber(t.subarray(e,e+2));e+=2;const u=d.decodeUTF8(t.subarray(e,e+o)),h=t.subarray(e+o,e+o+c);this.rawNotations.push({name:u,humanReadable:a,value:h,critical:i}),a&&(this.notations[u]=d.decodeUTF8(h));break}case f.signatureSubpacket.preferredHashAlgorithms:this.preferredHashAlgorithms=[...t.subarray(e,t.length)];break;case f.signatureSubpacket.preferredCompressionAlgorithms:this.preferredCompressionAlgorithms=[...t.subarray(e,t.length)];break;case f.signatureSubpacket.keyServerPreferences:this.keyServerPreferences=[...t.subarray(e,t.length)];break;case f.signatureSubpacket.preferredKeyServer:this.preferredKeyServer=d.decodeUTF8(t.subarray(e,t.length));break;case f.signatureSubpacket.primaryUserID:this.isPrimaryUserID=t[e++]!==0;break;case f.signatureSubpacket.policyURI:this.policyURI=d.decodeUTF8(t.subarray(e,t.length));break;case f.signatureSubpacket.keyFlags:this.keyFlags=[...t.subarray(e,t.length)];break;case f.signatureSubpacket.signersUserID:this.signersUserID=d.decodeUTF8(t.subarray(e,t.length));break;case f.signatureSubpacket.reasonForRevocation:this.reasonForRevocationFlag=t[e++],this.reasonForRevocationString=d.decodeUTF8(t.subarray(e,t.length));break;case f.signatureSubpacket.features:this.features=[...t.subarray(e,t.length)];break;case f.signatureSubpacket.signatureTarget:{this.signatureTargetPublicKeyAlgorithm=t[e++],this.signatureTargetHashAlgorithm=t[e++];const a=It(this.signatureTargetHashAlgorithm);this.signatureTargetHash=d.uint8ArrayToString(t.subarray(e,e+a));break}case f.signatureSubpacket.embeddedSignature:this.embeddedSignature=new Bt,this.embeddedSignature.read(t.subarray(e,t.length));break;case f.signatureSubpacket.issuerFingerprint:this.issuerKeyVersion=t[e++],this.issuerFingerprint=t.subarray(e,t.length),this.issuerKeyVersion>=5?this.issuerKeyID.read(this.issuerFingerprint):this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));break;case f.signatureSubpacket.preferredAEADAlgorithms:this.preferredAEADAlgorithms=[...t.subarray(e,t.length)];break;case f.signatureSubpacket.preferredCipherSuites:this.preferredCipherSuites=[];for(let a=e;a<t.length;a+=2)this.preferredCipherSuites.push([t[a],t[a+1]]);break;default:this.unknownSubpackets.push({type:s,critical:i,body:t.subarray(e,t.length)})}}readSubPackets(t,r=!0,e){const i=this.version===6?4:2,s=d.readNumber(t.subarray(0,i));let a=i;for(;a<2+s;){const o=_c(t.subarray(a,t.length));a+=o.offset,this.readSubPacket(t.subarray(a,a+o.len),r,e),a+=o.len}return a}toSign(t,r){const e=f.signature;switch(t){case e.binary:return r.text!==null?d.encodeUTF8(r.getText(!0)):r.getBytes(!0);case e.text:{const i=r.getBytes(!0);return d.canonicalizeEOL(i)}case e.standalone:return new Uint8Array(0);case e.certGeneric:case e.certPersona:case e.certCasual:case e.certPositive:case e.certRevocation:{let i,s;if(r.userID)s=180,i=r.userID;else{if(!r.userAttribute)throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");s=209,i=r.userAttribute}const a=i.write();return d.concat([this.toSign(e.key,r),new Uint8Array([s]),d.writeNumber(a.length,4),a])}case e.subkeyBinding:case e.subkeyRevocation:case e.keyBinding:return d.concat([this.toSign(e.key,r),this.toSign(e.key,{key:r.bind})]);case e.key:if(r.key===void 0)throw Error("Key packet is required for this signature.");return r.key.writeForHash(this.version);case e.keyRevocation:return this.toSign(e.key,r);case e.timestamp:return new Uint8Array(0);case e.thirdParty:throw Error("Not implemented");default:throw Error("Unknown signature type.")}}calculateTrailer(t,r){let e=0;return Et(Qr(this.signatureData),(i=>{e+=i.length}),(()=>{const i=[];return this.version!==5||this.signatureType!==f.signature.binary&&this.signatureType!==f.signature.text||(r?i.push(new Uint8Array(6)):i.push(t.writeHeader())),i.push(new Uint8Array([this.version,255])),this.version===5&&i.push(new Uint8Array(4)),i.push(d.writeNumber(e,4)),d.concat(i)}))}toHash(t,r,e=!1){const i=this.toSign(t,r);return d.concat([this.salt||new Uint8Array,i,this.signatureData,this.calculateTrailer(r,e)])}async hash(t,r,e,i=!1){if(this.version===6&&this.salt.length!==Qs(this.hashAlgorithm))throw Error("Signature salt does not have the expected length");return e||(e=this.toHash(t,r,i)),Qe(this.hashAlgorithm,e)}async verify(t,r,e,i=new Date,s=!1,a=G){if(!this.issuerKeyID.equals(t.getKeyID()))throw Error("Signature was not issued by the given public key");if(this.publicKeyAlgorithm!==t.algorithm)throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");const o=r===f.signature.binary||r===f.signature.text;if(!(this[In]&&!o)){let u,h;if(this.hashed?h=await this.hashed:(u=this.toHash(r,e,s),h=await this.hash(r,e,u)),h=await mt(h),this.signedHashValue[0]!==h[0]||this.signedHashValue[1]!==h[1])throw Error("Signed digest did not match");if(this.params=await this.params,this[In]=await W3(this.publicKeyAlgorithm,this.hashAlgorithm,this.params,t.publicParams,u,h),!this[In])throw Error("Signature verification failed")}const c=d.normalizeDate(i);if(c&&this.created>c)throw Error("Signature creation time is in the future");if(c&&c>=this.getExpirationTime())throw Error("Signature is expired");if(a.rejectHashAlgorithms.has(this.hashAlgorithm))throw Error("Insecure hash algorithm: "+f.read(f.hash,this.hashAlgorithm).toUpperCase());if(a.rejectMessageHashAlgorithms.has(this.hashAlgorithm)&&[f.signature.binary,f.signature.text].includes(this.signatureType))throw Error("Insecure message hash algorithm: "+f.read(f.hash,this.hashAlgorithm).toUpperCase());if(this.unknownSubpackets.forEach((({type:u,critical:h})=>{if(h)throw Error("Unknown critical signature subpacket type "+u)})),this.rawNotations.forEach((({name:u,critical:h})=>{if(h&&a.knownNotations.indexOf(u)<0)throw Error("Unknown critical notation: "+u)})),this.revocationKeyClass!==null)throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.")}isExpired(t=new Date){const r=d.normalizeDate(t);return r!==null&&!(this.created<=r&&r<this.getExpirationTime())}getExpirationTime(){return this.signatureNeverExpires?1/0:new Date(this.created.getTime()+1e3*this.signatureExpirationTime)}}function at(n,t,r){const e=[];return e.push(_i(r.length+1)),e.push(new Uint8Array([(t?128:0)|n])),e.push(r),d.concat(e)}function Qs(n){switch(n){case f.hash.sha256:return 16;case f.hash.sha384:return 24;case f.hash.sha512:return 32;case f.hash.sha224:case f.hash.sha3_256:return 16;case f.hash.sha3_512:return 32;default:throw Error("Unsupported hash function")}}class ae{static get tag(){return f.packet.onePassSignature}static fromSignaturePacket(t,r){const e=new ae;return e.version=t.version===6?6:3,e.signatureType=t.signatureType,e.hashAlgorithm=t.hashAlgorithm,e.publicKeyAlgorithm=t.publicKeyAlgorithm,e.issuerKeyID=t.issuerKeyID,e.salt=t.salt,e.issuerFingerprint=t.issuerFingerprint,e.flags=r?1:0,e}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.salt=null,this.issuerKeyID=null,this.issuerFingerprint=null,this.flags=null}read(t){let r=0;if(this.version=t[r++],this.version!==3&&this.version!==6)throw new it(`Version ${this.version} of the one-pass signature packet is unsupported.`);if(this.signatureType=t[r++],this.hashAlgorithm=t[r++],this.publicKeyAlgorithm=t[r++],this.version===6){const e=t[r++];this.salt=t.subarray(r,r+e),r+=e,this.issuerFingerprint=t.subarray(r,r+32),r+=32,this.issuerKeyID=new De,this.issuerKeyID.read(this.issuerFingerprint)}else this.issuerKeyID=new De,this.issuerKeyID.read(t.subarray(r,r+8)),r+=8;return this.flags=t[r++],this}write(){const t=[new Uint8Array([this.version,this.signatureType,this.hashAlgorithm,this.publicKeyAlgorithm])];return this.version===6?t.push(new Uint8Array([this.salt.length]),this.salt,this.issuerFingerprint):t.push(this.issuerKeyID.write()),t.push(new Uint8Array([this.flags])),d.concatUint8Array(t)}calculateTrailer(...t){return wr((async()=>Bt.prototype.calculateTrailer.apply(await this.correspondingSig,t)))}async verify(){const t=await this.correspondingSig;if(!t||t.constructor.tag!==f.packet.signature)throw Error("Corresponding signature packet missing");if(t.signatureType!==this.signatureType||t.hashAlgorithm!==this.hashAlgorithm||t.publicKeyAlgorithm!==this.publicKeyAlgorithm||!t.issuerKeyID.equals(this.issuerKeyID)||this.version===3&&t.version===6||this.version===6&&t.version!==6||this.version===6&&!d.equalsUint8Array(t.issuerFingerprint,this.issuerFingerprint)||this.version===6&&!d.equalsUint8Array(t.salt,this.salt))throw Error("Corresponding signature packet does not match one-pass signature packet");return t.hashed=this.hashed,t.verify.apply(t,arguments)}}function yu(n,t){if(!t[n]){let r;try{r=f.read(f.packet,n)}catch{throw new bi("Unknown packet type with tag: "+n)}throw Error("Packet not allowed in this context: "+r)}return new t[n]}ae.prototype.hash=Bt.prototype.hash,ae.prototype.toHash=Bt.prototype.toHash,ae.prototype.toSign=Bt.prototype.toSign;class rt extends Array{static async fromBinary(t,r,e=G,i=null,s=!1){const a=new rt;return await a.read(t,r,e,i,s),a}async read(t,r,e=G,i=null,s=!1){let a;e.additionalAllowedPackets.length&&(a=d.constructAllowedPackets(e.additionalAllowedPackets),r={...r,...a}),this.stream=Ye(t,(async(c,u)=>{const h=pe(c),l=te(u);try{let y=d.isStream(c);for(;;){let g,p;if(await l.ready,await E3(h,y,(async w=>{try{if(w.tag===f.packet.marker||w.tag===f.packet.trust||w.tag===f.packet.padding)return;const b=yu(w.tag,r);try{i?.recordPacket(w.tag,a)}catch(v){if(e.enforceGrammar)throw v;d.printDebugError(v)}b.packets=new rt,b.fromStream=d.isStream(w.packet),p=b.fromStream;try{await b.read(w.packet,e)}catch(v){throw v instanceof it?v:d.wrapError(new vs(`Parsing ${b.constructor.name} failed`),v)}await l.write(b)}catch(b){const v=b instanceof bi&&w.tag<=39,k=b instanceof it&&!(b instanceof bi)&&!e.ignoreUnsupportedPackets,m=b instanceof vs&&!e.ignoreMalformedPackets,C=mi(w.tag);if(v||k||m||C||!(b instanceof bi||b instanceof it||b instanceof vs))s?g=b:await l.abort(b);else{const D=new ea(w.tag,w.packet);await l.write(D)}d.printDebugError(b)}})),p&&(y=null),g)throw await h.readToEnd(),g;const A=await h.peekBytes(2);if(!A||!A.length){try{i?.recordEnd()}catch(w){if(e.enforceGrammar)throw w;d.printDebugError(w)}return await l.ready,void await l.close()}}}catch(y){await l.abort(y)}}));const o=pe(this.stream);for(;;){const{done:c,value:u}=await o.read();if(c?this.stream=null:this.push(u),c||mi(u.constructor.tag))break}o.releaseLock()}write(){const t=[];for(let r=0;r<this.length;r++){const e=this[r]instanceof ea?this[r].tag:this[r].constructor.tag,i=this[r].write();if(d.isStream(i)&&mi(this[r].constructor.tag)){let s=[],a=0;const o=512;t.push(Mi(e)),t.push(Et(i,(c=>{if(s.push(c),a+=c.length,a>=o){const u=Math.min(Math.log(a)/Math.LN2|0,30),h=2**u,l=d.concat([k3(u)].concat(s));return s=[l.subarray(1+h)],a=s[0].length,l.subarray(0,1+h)}}),(()=>d.concat([_i(a)].concat(s)))))}else{if(d.isStream(i)){let s=0;t.push(Et(Qr(i),(a=>{s+=a.length}),(()=>yo(e,s))))}else t.push(yo(e,i.length));t.push(i)}}return d.concat(t)}filterByTag(...t){const r=new rt,e=i=>s=>i===s;for(let i=0;i<this.length;i++)t.some(e(this[i].constructor.tag))&&r.push(this[i]);return r}findPacket(t){return this.find((r=>r.constructor.tag===t))}indexOfTag(...t){const r=[],e=this,i=s=>a=>s===a;for(let s=0;s<this.length;s++)t.some(i(e[s].constructor.tag))&&r.push(s);return r}}class be extends Error{constructor(...t){super(...t),Error.captureStackTrace&&Error.captureStackTrace(this,be),this.name="GrammarError"}}var wt;(function(n){n[n.EmptyMessage=0]="EmptyMessage",n[n.PlaintextOrEncryptedData=1]="PlaintextOrEncryptedData",n[n.EncryptedSessionKeys=2]="EncryptedSessionKeys",n[n.StandaloneAdditionalAllowedData=3]="StandaloneAdditionalAllowedData"})(wt||(wt={}));class ls{constructor(){this.state=wt.EmptyMessage,this.leadingOnePassSignatureCounter=0}recordPacket(t,r){switch(this.state){case wt.EmptyMessage:case wt.StandaloneAdditionalAllowedData:switch(t){case f.packet.literalData:case f.packet.compressedData:case f.packet.aeadEncryptedData:case f.packet.symEncryptedIntegrityProtectedData:case f.packet.symmetricallyEncryptedData:return void(this.state=wt.PlaintextOrEncryptedData);case f.packet.signature:if(this.state===wt.StandaloneAdditionalAllowedData&&--this.leadingOnePassSignatureCounter<0)throw new be("Trailing signature packet without OPS");return;case f.packet.onePassSignature:if(this.state===wt.StandaloneAdditionalAllowedData)throw new be("OPS following StandaloneAdditionalAllowedData");return void this.leadingOnePassSignatureCounter++;case f.packet.publicKeyEncryptedSessionKey:case f.packet.symEncryptedSessionKey:return void(this.state=wt.EncryptedSessionKeys);default:if(!r?.[t])throw new be(`Unexpected packet ${t} in state ${this.state}`);return void(this.state=wt.StandaloneAdditionalAllowedData)}case wt.PlaintextOrEncryptedData:if(t===f.packet.signature){if(--this.leadingOnePassSignatureCounter<0)throw new be("Trailing signature packet without OPS");return void(this.state=wt.PlaintextOrEncryptedData)}if(!r?.[t])throw new be(`Unexpected packet ${t} in state ${this.state}`);return void(this.state=wt.PlaintextOrEncryptedData);case wt.EncryptedSessionKeys:switch(t){case f.packet.publicKeyEncryptedSessionKey:case f.packet.symEncryptedSessionKey:return void(this.state=wt.EncryptedSessionKeys);case f.packet.symEncryptedIntegrityProtectedData:case f.packet.aeadEncryptedData:case f.packet.symmetricallyEncryptedData:return void(this.state=wt.PlaintextOrEncryptedData);case f.packet.signature:if(--this.leadingOnePassSignatureCounter<0)throw new be("Trailing signature packet without OPS");return void(this.state=wt.PlaintextOrEncryptedData);default:if(!r?.[t])throw new be(`Unexpected packet ${t} in state ${this.state}`);this.state=wt.EncryptedSessionKeys}}}recordEnd(){switch(this.state){case wt.EmptyMessage:case wt.PlaintextOrEncryptedData:case wt.EncryptedSessionKeys:case wt.StandaloneAdditionalAllowedData:if(this.leadingOnePassSignatureCounter>0)throw new be("Missing trailing signature packets")}}}const gu=d.constructAllowedPackets([Ar,ae,Bt]);class ti{static get tag(){return f.packet.compressedData}constructor(t=G){this.packets=null,this.algorithm=t.preferredCompressionAlgorithm,this.compressed=null}async read(t,r=G){await Wi(t,(async e=>{this.algorithm=await e.readByte(),this.compressed=e.remainder(),await this.decompress(r)}))}write(){return this.compressed===null&&this.compress(),d.concat([new Uint8Array([this.algorithm]),this.compressed])}async decompress(t=G){const r=f.read(f.compression,this.algorithm),e=Au[r];if(!e)throw Error(r+" decompression not supported");let i=await e(this.compressed);if(t.maxDecompressedMessageSize!==1/0){let s=0;i=Et(i,(a=>{if(s+=a.length,s>t.maxDecompressedMessageSize)throw Error("Maximum decompressed message size exceeded");return a}))}vt(this.compressed)&&!gt(this.compressed)||(i=await mt(i)),this.packets=await rt.fromBinary(i,gu,t,new ls)}compress(){const t=f.read(f.compression,this.algorithm),r=du[t];if(!r)throw Error(t+" compression not supported");const e=this.packets.write();let i=r(e);vt(e)&&!gt(e)||(i=wr((()=>mt(i)))),this.compressed=i}}function zi(n,t){return r=>{let e;if(e=gt(r)?new ReadableStream({async start(c){try{c.enqueue(await mt(r)),c.close()}catch(u){c.error(u)}}}):vt(r)?r:Wn(r),e=(function(c){const u=pe(c);return new ReadableStream({async pull(h){try{const{value:l,done:y}=await u.read();if(y)return void h.close();for(let g=0;g<=l.length;g+=65536)(!g||g<l.length)&&h.enqueue(l.subarray(g,g+65536))}catch(l){h.error(l)}}},{highWaterMark:0})})(e),n)try{const c=n();return e.pipeThrough(c)}catch(c){if(c.name!=="TypeError")throw c}const i=pe(e),s=new t;let a=!1,o=!1;return new ReadableStream({start(c){s.ondata=(u,h)=>{c.enqueue(u),a=!0,h&&(c.close(),o=!0)}},async pull(){for(a=!1;!a&&!o;){const{done:c,value:u}=await i.read();if(c)return void s.push(new Uint8Array,!0);u.length&&s.push(u)}}},{highWaterMark:0})}}function pu(){return async function(n){const{default:t}=await Promise.resolve().then((function(){return B5}));return t(Wn(n))}}const Gi=n=>({compressor:typeof CompressionStream<"u"&&(()=>new CompressionStream(n)),decompressor:typeof DecompressionStream<"u"&&(()=>new DecompressionStream(n))}),du={zip:zi(Gi("deflate-raw").compressor,Ki),zlib:zi(Gi("deflate").compressor,uu)},Au={uncompressed:n=>n,zip:zi(Gi("deflate-raw").decompressor,Ci),zlib:zi(Gi("deflate").decompressor,hu),bzip2:pu()},wu=d.constructAllowedPackets([Ar,ti,ae,Bt]);class cn{static get tag(){return f.packet.symEncryptedIntegrityProtectedData}static fromObject({version:t,aeadAlgorithm:r}){if(t!==1&&t!==2)throw Error("Unsupported SEIPD version");const e=new cn;return e.version=t,t===2&&(e.aeadAlgorithm=r),e}constructor(){this.version=null,this.cipherAlgorithm=null,this.aeadAlgorithm=null,this.chunkSizeByte=null,this.salt=null,this.encrypted=null,this.packets=null}async read(t){await Wi(t,(async r=>{if(this.version=await r.readByte(),this.version!==1&&this.version!==2)throw new it(`Version ${this.version} of the SEIP packet is unsupported.`);this.version===2&&(this.cipherAlgorithm=await r.readByte(),this.aeadAlgorithm=await r.readByte(),this.chunkSizeByte=await r.readByte(),this.salt=await r.readBytes(32)),this.encrypted=r.remainder()}))}write(){return this.version===2?d.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.salt,this.encrypted]):d.concat([new Uint8Array([this.version]),this.encrypted])}async encrypt(t,r,e=G){const{blockSize:i,keySize:s}=ot(t);if(r.length!==s)throw Error("Unexpected session key size");let a=this.packets.write();if(gt(a)&&(a=await mt(a)),this.version===2)this.cipherAlgorithm=t,this.salt=Dt(32),this.chunkSizeByte=e.aeadChunkSizeByte,this.encrypted=await ji(this,"encrypt",r,a);else{const o=await x1(t),c=new Uint8Array([211,20]),u=d.concat([o,a,c]),h=await Qe(f.hash.sha1,On(u)),l=d.concat([u,h]);this.encrypted=await Vn(t,r,l,new Uint8Array(i))}return!0}async decrypt(t,r,e=G){if(r.length!==ot(t).keySize)throw Error("Unexpected session key size");let i,s=Qr(this.encrypted);gt(s)&&(s=await mt(s));let a=!1;if(this.version===2){if(this.cipherAlgorithm!==t)throw Error("Unexpected session key algorithm");i=await ji(this,"decrypt",r,s)}else{const{blockSize:o}=ot(t),c=await cs(t,r,s,new Uint8Array(o)),u=Qt(On(c),-20),h=Qt(c,0,-20),l=Promise.all([mt(await Qe(f.hash.sha1,On(h))),mt(u)]).then((([g,p])=>{if(!d.equalsUint8Array(g,p))throw Error("Modification detected.");return new Uint8Array})),y=Qt(h,o+2);i=Qt(y,0,-2),i=Ft([i,wr((()=>l))]),d.isStream(s)&&e.allowUnauthenticatedStream?a=!0:i=await mt(i)}return this.packets=await rt.fromBinary(i,wu,e,new ls,a),!0}}async function ji(n,t,r,e){const i=n instanceof cn&&n.version===2,s=!i&&n.constructor.tag===f.packet.aeadEncryptedData;if(!i&&!s)throw Error("Unexpected packet type");const a=Ve(n.aeadAlgorithm,s),o=t==="decrypt"?a.tagLength:0,c=t==="encrypt"?a.tagLength:0,u=2**(n.chunkSizeByte+6)+o,h=s?8:0,l=new ArrayBuffer(13+h),y=new Uint8Array(l,0,5+h),g=new Uint8Array(l),p=new DataView(l),A=new Uint8Array(l,5,8);y.set([192|n.constructor.tag,n.version,n.cipherAlgorithm,n.aeadAlgorithm,n.chunkSizeByte],0);let w,b,v=0,k=Promise.resolve(),m=0,C=0;if(i){const{keySize:P}=ot(n.cipherAlgorithm),{ivLength:S}=a,E=new Uint8Array(l,0,5),K=await pr(f.hash.sha256,r,n.salt,E,P+S);r=K.subarray(0,P),w=K.subarray(P),w.fill(0,w.length-8),b=new DataView(w.buffer,w.byteOffset,w.byteLength)}else w=n.iv;const D=await a(n.cipherAlgorithm,r);return Ye(e,(async(P,S)=>{if(d.isStream(P)!=="array"){const I=new TransformStream({},{highWaterMark:d.getHardwareConcurrency()*2**(n.chunkSizeByte+6),size:B=>B.length});xr(I.readable,S),S=I.writable}const E=pe(P),K=te(S);try{for(;;){let I=await E.readBytes(u+o)||new Uint8Array;const B=I.subarray(I.length-o);let U,x,M;if(I=I.subarray(0,I.length-o),i)M=w;else{M=w.slice();for(let Q=0;Q<8;Q++)M[w.length-8+Q]^=A[Q]}if(!v||I.length?(E.unshift(B),U=D[t](I,M,y),U.catch((()=>{})),C+=I.length-o+c):(p.setInt32(5+h+4,m),U=D[t](B,M,g),U.catch((()=>{})),C+=c,x=!0),m+=I.length-o,k=k.then((()=>U)).then((async Q=>{await K.ready,await K.write(Q),C-=Q.length})).catch((Q=>K.abort(Q))),(x||C>K.desiredSize)&&await k,x){await K.close();break}i?b.setInt32(w.length-4,++v):p.setInt32(9,++v)}}catch(I){await K.ready.catch((()=>{})),await K.abort(I)}}))}const mu=d.constructAllowedPackets([Ar,ti,ae,Bt]);class bu{static get tag(){return f.packet.aeadEncryptedData}constructor(){this.version=1,this.cipherAlgorithm=null,this.aeadAlgorithm=f.aead.eax,this.chunkSizeByte=null,this.iv=null,this.encrypted=null,this.packets=null}async read(t){await Wi(t,(async r=>{const e=await r.readByte();if(e!==1)throw new it(`Version ${e} of the AEAD-encrypted data packet is not supported.`);this.cipherAlgorithm=await r.readByte(),this.aeadAlgorithm=await r.readByte(),this.chunkSizeByte=await r.readByte();const i=Ve(this.aeadAlgorithm,!0);this.iv=await r.readBytes(i.ivLength),this.encrypted=r.remainder()}))}write(){return d.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.iv,this.encrypted])}async decrypt(t,r,e=G){this.packets=await rt.fromBinary(await ji(this,"decrypt",r,Qr(this.encrypted)),mu,e,new ls)}async encrypt(t,r,e=G){this.cipherAlgorithm=t;const{ivLength:i}=Ve(this.aeadAlgorithm,!0);this.iv=Dt(i),this.chunkSizeByte=e.aeadChunkSizeByte;const s=this.packets.write();this.encrypted=await ji(this,"encrypt",r,s)}}class Yn{static get tag(){return f.packet.publicKeyEncryptedSessionKey}constructor(){this.version=null,this.publicKeyID=new De,this.publicKeyVersion=null,this.publicKeyFingerprint=null,this.publicKeyAlgorithm=null,this.sessionKey=null,this.sessionKeyAlgorithm=null,this.encrypted={}}static fromObject({version:t,encryptionKeyPacket:r,anonymousRecipient:e,sessionKey:i,sessionKeyAlgorithm:s}){const a=new Yn;if(t!==3&&t!==6)throw Error("Unsupported PKESK version");return a.version=t,t===6&&(a.publicKeyVersion=e?null:r.version,a.publicKeyFingerprint=e?null:r.getFingerprintBytes()),a.publicKeyID=e?De.wildcard():r.getKeyID(),a.publicKeyAlgorithm=r.algorithm,a.sessionKey=i,a.sessionKeyAlgorithm=s,a}read(t){let r=0;if(this.version=t[r++],this.version!==3&&this.version!==6)throw new it(`Version ${this.version} of the PKESK packet is unsupported.`);if(this.version===6){const e=t[r++];if(e){this.publicKeyVersion=t[r++];const i=e-1;this.publicKeyFingerprint=t.subarray(r,r+i),r+=i,this.publicKeyVersion>=5?this.publicKeyID.read(this.publicKeyFingerprint):this.publicKeyID.read(this.publicKeyFingerprint.subarray(-8))}else this.publicKeyID=De.wildcard()}else r+=this.publicKeyID.read(t.subarray(r,r+8));if(this.publicKeyAlgorithm=t[r++],this.encrypted=(function(e,i){let s=0;switch(e){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:return{c:d.readMPI(i.subarray(s))};case f.publicKey.elgamal:{const a=d.readMPI(i.subarray(s));return s+=a.length+2,{c1:a,c2:d.readMPI(i.subarray(s))}}case f.publicKey.ecdh:{const a=d.readMPI(i.subarray(s));s+=a.length+2;const o=new P1;return o.read(i.subarray(s)),{V:a,C:o}}case f.publicKey.x25519:case f.publicKey.x448:{const a=Xr(e),o=d.readExactSubarray(i,s,s+a);s+=o.length;const c=new os;return c.read(i.subarray(s)),{ephemeralPublicKey:o,C:c}}default:throw new it("Unknown public key encryption algorithm.")}})(this.publicKeyAlgorithm,t.subarray(r)),this.publicKeyAlgorithm===f.publicKey.x25519||this.publicKeyAlgorithm===f.publicKey.x448){if(this.version===3)this.sessionKeyAlgorithm=f.write(f.symmetric,this.encrypted.C.algorithm);else if(this.encrypted.C.algorithm!==null)throw Error("Unexpected cleartext symmetric algorithm")}}write(){const t=[new Uint8Array([this.version])];return this.version===6?this.publicKeyFingerprint!==null?(t.push(new Uint8Array([this.publicKeyFingerprint.length+1,this.publicKeyVersion])),t.push(this.publicKeyFingerprint)):t.push(new Uint8Array([0])):t.push(this.publicKeyID.write()),t.push(new Uint8Array([this.publicKeyAlgorithm]),on(this.publicKeyAlgorithm,this.encrypted)),d.concatUint8Array(t)}async encrypt(t){const r=f.write(f.publicKey,this.publicKeyAlgorithm),e=this.version===3?this.sessionKeyAlgorithm:null,i=t.version===5?t.getFingerprintBytes().subarray(0,20):t.getFingerprintBytes(),s=Oo(this.version,r,e,this.sessionKey);this.encrypted=await N3(r,e,t.publicParams,s,i)}async decrypt(t,r){if(this.publicKeyAlgorithm!==t.algorithm)throw Error("Decryption error");const e=r?Oo(this.version,this.publicKeyAlgorithm,r.sessionKeyAlgorithm,r.sessionKey):null,i=t.version===5?t.getFingerprintBytes().subarray(0,20):t.getFingerprintBytes(),s=await O3(this.publicKeyAlgorithm,t.publicParams,t.privateParams,this.encrypted,i,e),{sessionKey:a,sessionKeyAlgorithm:o}=(function(c,u,h,l){switch(u){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:case f.publicKey.elgamal:case f.publicKey.ecdh:{const y=h.subarray(0,h.length-2),g=h.subarray(h.length-2),p=d.writeChecksum(y.subarray(y.length%8)),A=p[0]===g[0]&p[1]===g[1],w=c===6?{sessionKeyAlgorithm:null,sessionKey:y}:{sessionKeyAlgorithm:y[0],sessionKey:y.subarray(1)};if(l){const b=A&w.sessionKeyAlgorithm===l.sessionKeyAlgorithm&w.sessionKey.length===l.sessionKey.length;return{sessionKey:d.selectUint8Array(b,w.sessionKey,l.sessionKey),sessionKeyAlgorithm:c===6?null:d.selectUint8(b,w.sessionKeyAlgorithm,l.sessionKeyAlgorithm)}}if(A&&(c===6||f.read(f.symmetric,w.sessionKeyAlgorithm)))return w;throw Error("Decryption error")}case f.publicKey.x25519:case f.publicKey.x448:return{sessionKeyAlgorithm:null,sessionKey:h};default:throw Error("Unsupported public key algorithm")}})(this.version,this.publicKeyAlgorithm,s,r);if(this.version===3){const c=this.publicKeyAlgorithm!==f.publicKey.x25519&&this.publicKeyAlgorithm!==f.publicKey.x448;if(this.sessionKeyAlgorithm=c?o:this.sessionKeyAlgorithm,a.length!==ot(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}this.sessionKey=a}}function Oo(n,t,r,e){switch(t){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:case f.publicKey.elgamal:case f.publicKey.ecdh:return d.concatUint8Array([new Uint8Array(n===6?[]:[r]),e,d.writeChecksum(e.subarray(e.length%8))]);case f.publicKey.x25519:case f.publicKey.x448:return e;default:throw Error("Unsupported public key algorithm")}}class un{static get tag(){return f.packet.symEncryptedSessionKey}constructor(t=G){this.version=t.aeadProtect?6:4,this.sessionKey=null,this.sessionKeyEncryptionAlgorithm=null,this.sessionKeyAlgorithm=null,this.aeadAlgorithm=f.write(f.aead,t.preferredAEADAlgorithm),this.encrypted=null,this.s2k=null,this.iv=null}read(t){let r=0;if(this.version=t[r++],this.version!==4&&this.version!==5&&this.version!==6)throw new it(`Version ${this.version} of the SKESK packet is unsupported.`);this.version===6&&r++;const e=t[r++];this.version>=5&&(this.aeadAlgorithm=t[r++],this.version===6&&r++);const i=t[r++];if(this.s2k=Hi(i),r+=this.s2k.read(t.subarray(r,t.length)),this.version>=5){const s=Ve(this.aeadAlgorithm,!0);this.iv=t.subarray(r,r+=s.ivLength)}this.version>=5||r<t.length?(this.encrypted=t.subarray(r,t.length),this.sessionKeyEncryptionAlgorithm=e):this.sessionKeyAlgorithm=e}write(){const t=this.encrypted===null?this.sessionKeyAlgorithm:this.sessionKeyEncryptionAlgorithm;let r;const e=this.s2k.write();if(this.version===6){const i=e.length,s=3+i+this.iv.length;r=d.concatUint8Array([new Uint8Array([this.version,s,t,this.aeadAlgorithm,i]),e,this.iv,this.encrypted])}else this.version===5?r=d.concatUint8Array([new Uint8Array([this.version,t,this.aeadAlgorithm]),e,this.iv,this.encrypted]):(r=d.concatUint8Array([new Uint8Array([this.version,t]),e]),this.encrypted!==null&&(r=d.concatUint8Array([r,this.encrypted])));return r}async decrypt(t){const r=this.sessionKeyEncryptionAlgorithm!==null?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm,{blockSize:e,keySize:i}=ot(r),s=await this.s2k.produceKey(t,i);if(this.version>=5){const a=Ve(this.aeadAlgorithm,!0),o=new Uint8Array([192|un.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),c=this.version===6?await pr(f.hash.sha256,s,new Uint8Array,o,i):s,u=await a(r,c);this.sessionKey=await u.decrypt(this.encrypted,this.iv,o)}else if(this.encrypted!==null){const a=await cs(r,s,this.encrypted,new Uint8Array(e));if(this.sessionKeyAlgorithm=f.write(f.symmetric,a[0]),this.sessionKey=a.subarray(1,a.length),this.sessionKey.length!==ot(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}else this.sessionKey=s}async encrypt(t,r=G){const e=this.sessionKeyEncryptionAlgorithm!==null?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm;this.sessionKeyEncryptionAlgorithm=e,this.s2k=M1(r),this.s2k.generateSalt();const{blockSize:i,keySize:s}=ot(e),a=await this.s2k.produceKey(t,s);if(this.sessionKey===null&&(this.sessionKey=fa(this.sessionKeyAlgorithm)),this.version>=5){const o=Ve(this.aeadAlgorithm);this.iv=Dt(o.ivLength);const c=new Uint8Array([192|un.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),u=this.version===6?await pr(f.hash.sha256,a,new Uint8Array,c,s):a,h=await o(e,u);this.encrypted=await h.encrypt(this.sessionKey,this.iv,c)}else{const o=d.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]),this.sessionKey]);this.encrypted=await Vn(e,a,o,new Uint8Array(i))}}}class Ke{static get tag(){return f.packet.publicKey}constructor(t=new Date,r=G){this.version=r.v6Keys?6:4,this.created=d.normalizeDate(t),this.algorithm=null,this.publicParams=null,this.expirationTimeV3=0,this.fingerprint=null,this.keyID=null}static fromSecretKeyPacket(t){const r=new Ke,{version:e,created:i,algorithm:s,publicParams:a,keyID:o,fingerprint:c}=t;return r.version=e,r.created=i,r.algorithm=s,r.publicParams=a,r.keyID=o,r.fingerprint=c,r}async read(t,r=G){let e=0;if(this.version=t[e++],this.version===5&&!r.enableParsingV5Entities)throw new it("Support for parsing v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(this.version===4||this.version===5||this.version===6){this.created=d.readDate(t.subarray(e,e+4)),e+=4,this.algorithm=t[e++],this.version>=5&&(e+=4);const{read:i,publicParams:s}=(function(a,o){let c=0;switch(a){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:case f.publicKey.rsaSign:{const u=d.readMPI(o.subarray(c));c+=u.length+2;const h=d.readMPI(o.subarray(c));return c+=h.length+2,{read:c,publicParams:{n:u,e:h}}}case f.publicKey.dsa:{const u=d.readMPI(o.subarray(c));c+=u.length+2;const h=d.readMPI(o.subarray(c));c+=h.length+2;const l=d.readMPI(o.subarray(c));c+=l.length+2;const y=d.readMPI(o.subarray(c));return c+=y.length+2,{read:c,publicParams:{p:u,q:h,g:l,y}}}case f.publicKey.elgamal:{const u=d.readMPI(o.subarray(c));c+=u.length+2;const h=d.readMPI(o.subarray(c));c+=h.length+2;const l=d.readMPI(o.subarray(c));return c+=l.length+2,{read:c,publicParams:{p:u,g:h,y:l}}}case f.publicKey.ecdsa:{const u=new je;c+=u.read(o),Bs(u);const h=d.readMPI(o.subarray(c));return c+=h.length+2,{read:c,publicParams:{oid:u,Q:h}}}case f.publicKey.eddsaLegacy:{const u=new je;if(c+=u.read(o),Bs(u),u.getName()!==f.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let h=d.readMPI(o.subarray(c));return c+=h.length+2,h=d.leftPad(h,33),{read:c,publicParams:{oid:u,Q:h}}}case f.publicKey.ecdh:{const u=new je;c+=u.read(o),Bs(u);const h=d.readMPI(o.subarray(c));c+=h.length+2;const l=new D1;return c+=l.read(o.subarray(c)),{read:c,publicParams:{oid:u,Q:h,kdfParams:l}}}case f.publicKey.ed25519:case f.publicKey.ed448:case f.publicKey.x25519:case f.publicKey.x448:{const u=d.readExactSubarray(o,c,c+Xr(a));return c+=u.length,{read:c,publicParams:{A:u}}}default:throw new it("Unknown public key encryption algorithm.")}})(this.algorithm,t.subarray(e));if(this.version===6&&s.oid&&(s.oid.getName()===f.curve.curve25519Legacy||s.oid.getName()===f.curve.ed25519Legacy))throw Error("Legacy curve25519 cannot be used with v6 keys");return this.publicParams=s,e+=i,await this.computeFingerprintAndKeyID(),e}throw new it(`Version ${this.version} of the key packet is unsupported.`)}write(){const t=[];t.push(new Uint8Array([this.version])),t.push(d.writeDate(this.created)),t.push(new Uint8Array([this.algorithm]));const r=on(this.algorithm,this.publicParams);return this.version>=5&&t.push(d.writeNumber(r.length,4)),t.push(r),d.concatUint8Array(t)}writeForHash(t){const r=this.writePublicKey(),e=149+t,i=t>=5?4:2;return d.concatUint8Array([new Uint8Array([e]),d.writeNumber(r.length,i),r])}isDecrypted(){return null}getCreationTime(){return this.created}getKeyID(){return this.keyID}async computeFingerprintAndKeyID(){if(await this.computeFingerprint(),this.keyID=new De,this.version>=5)this.keyID.read(this.fingerprint.subarray(0,8));else{if(this.version!==4)throw Error("Unsupported key version");this.keyID.read(this.fingerprint.subarray(12,20))}}async computeFingerprint(){const t=this.writeForHash(this.version);if(this.version>=5)this.fingerprint=await Qe(f.hash.sha256,t);else{if(this.version!==4)throw Error("Unsupported key version");this.fingerprint=await Qe(f.hash.sha1,t)}}getFingerprintBytes(){return this.fingerprint}getFingerprint(){return d.uint8ArrayToHex(this.getFingerprintBytes())}hasSameFingerprintAs(t){return this.version===t.version&&d.equalsUint8Array(this.writePublicKey(),t.writePublicKey())}getAlgorithmInfo(){const t={};t.algorithm=f.read(f.publicKey,this.algorithm);const r=this.publicParams.n||this.publicParams.p;return r?t.bits=d.uint8ArrayBitLength(r):this.publicParams.oid&&(t.curve=this.publicParams.oid.getName()),t}}Ke.prototype.readPublicKey=Ke.prototype.read,Ke.prototype.writePublicKey=Ke.prototype.write;const ku=d.constructAllowedPackets([Ar,ti,ae,Bt]);class Eu{static get tag(){return f.packet.symmetricallyEncryptedData}constructor(){this.encrypted=null,this.packets=null}read(t){this.encrypted=t}write(){return this.encrypted}async decrypt(t,r,e=G){if(!e.allowUnauthenticatedMessages)throw Error("Message is not authenticated.");const{blockSize:i}=ot(t),s=await mt(Qr(this.encrypted)),a=await cs(t,r,s.subarray(i+2),s.subarray(2,i+2));this.packets=await rt.fromBinary(a,ku,e)}async encrypt(t,r,e=G){const i=this.packets.write(),{blockSize:s}=ot(t),a=await x1(t),o=await Vn(t,r,a,new Uint8Array(s)),c=await Vn(t,r,i,o.subarray(2));this.encrypted=d.concat([o,c])}}class K5{static get tag(){return f.packet.marker}read(t){return t[0]===80&&t[1]===71&&t[2]===80}write(){return new Uint8Array([80,71,80])}}class ys extends Ke{static get tag(){return f.packet.publicSubkey}constructor(t,r){super(t,r)}static fromSecretSubkeyPacket(t){const r=new ys,{version:e,created:i,algorithm:s,publicParams:a,keyID:o,fingerprint:c}=t;return r.version=e,r.created=i,r.algorithm=s,r.publicParams=a,r.keyID=o,r.fingerprint=c,r}}class Za{static get tag(){return f.packet.userAttribute}constructor(){this.attributes=[]}read(t){let r=0;for(;r<t.length;){const e=_c(t.subarray(r,t.length));r+=e.offset,this.attributes.push(d.uint8ArrayToString(t.subarray(r,r+e.len))),r+=e.len}}write(){const t=[];for(let r=0;r<this.attributes.length;r++)t.push(_i(this.attributes[r].length)),t.push(d.stringToUint8Array(this.attributes[r]));return d.concatUint8Array(t)}equals(t){return!!(t&&t instanceof Za)&&this.attributes.every((function(r,e){return r===t.attributes[e]}))}}class Ja extends Ke{static get tag(){return f.packet.secretKey}constructor(t=new Date,r=G){super(t,r),this.keyMaterial=null,this.isEncrypted=null,this.s2kUsage=0,this.s2k=null,this.symmetric=null,this.aead=null,this.isLegacyAEAD=null,this.privateParams=null,this.usedModernAEAD=null}async read(t,r=G){let e=await this.readPublicKey(t,r);const i=e;this.s2kUsage=t[e++],this.version===5&&e++,this.version===6&&this.s2kUsage&&e++;try{if(this.s2kUsage===255||this.s2kUsage===254||this.s2kUsage===253){this.symmetric=t[e++],this.s2kUsage===253&&(this.aead=t[e++]),this.version===6&&e++;const s=t[e++];if(this.s2k=Hi(s),e+=this.s2k.read(t.subarray(e,t.length)),this.s2k.type==="gnu-dummy")return}else this.s2kUsage&&(this.symmetric=this.s2kUsage);this.s2kUsage&&(this.isLegacyAEAD=this.s2kUsage===253&&(this.version===5||this.version===4&&r.parseAEADEncryptedV4KeysAsLegacy),this.s2kUsage!==253||this.isLegacyAEAD?(this.iv=t.subarray(e,e+ot(this.symmetric).blockSize),this.usedModernAEAD=!1):(this.iv=t.subarray(e,e+Ve(this.aead).ivLength),this.usedModernAEAD=!0),e+=this.iv.length)}catch(s){if(!this.s2kUsage)throw s;this.unparseableKeyMaterial=t.subarray(i),this.isEncrypted=!0}if(this.version===5&&(e+=4),this.keyMaterial=t.subarray(e),this.isEncrypted=!!this.s2kUsage,!this.isEncrypted){let s;if(this.version===6)s=this.keyMaterial;else if(s=this.keyMaterial.subarray(0,-2),!d.equalsUint8Array(d.writeChecksum(s),this.keyMaterial.subarray(-2)))throw Error("Key checksum mismatch");try{const{read:a,privateParams:o}=Io(this.algorithm,s,this.publicParams);if(a<s.length)throw Error("Error reading MPIs");this.privateParams=o}catch(a){throw a instanceof it?a:Error("Error reading MPIs")}}}write(){const t=this.writePublicKey();if(this.unparseableKeyMaterial)return d.concatUint8Array([t,this.unparseableKeyMaterial]);const r=[t];r.push(new Uint8Array([this.s2kUsage]));const e=[];if(this.s2kUsage===255||this.s2kUsage===254||this.s2kUsage===253){e.push(this.symmetric),this.s2kUsage===253&&e.push(this.aead);const i=this.s2k.write();this.version===6&&e.push(i.length),e.push(...i)}return this.s2kUsage&&this.s2k.type!=="gnu-dummy"&&e.push(...this.iv),(this.version===5||this.version===6&&this.s2kUsage)&&r.push(new Uint8Array([e.length])),r.push(new Uint8Array(e)),this.isDummy()||(this.s2kUsage||(this.keyMaterial=on(this.algorithm,this.privateParams)),this.version===5&&r.push(d.writeNumber(this.keyMaterial.length,4)),r.push(this.keyMaterial),this.s2kUsage||this.version===6||r.push(d.writeChecksum(this.keyMaterial))),d.concatUint8Array(r)}isDecrypted(){return this.isEncrypted===!1}isMissingSecretKeyMaterial(){return this.unparseableKeyMaterial!==void 0||this.isDummy()}isDummy(){return!(!this.s2k||this.s2k.type!=="gnu-dummy")}makeDummy(t=G){this.isDummy()||(this.isDecrypted()&&this.clearPrivateParams(),delete this.unparseableKeyMaterial,this.isEncrypted=null,this.keyMaterial=null,this.s2k=Hi(f.s2k.gnu,t),this.s2k.algorithm=0,this.s2k.c=0,this.s2k.type="gnu-dummy",this.s2kUsage=254,this.symmetric=f.symmetric.aes256,this.isLegacyAEAD=null,this.usedModernAEAD=null)}async encrypt(t,r=G){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key packet is already encrypted");if(!t)throw Error("A non-empty passphrase is required for key encryption.");this.s2k=M1(r),this.s2k.generateSalt();const e=on(this.algorithm,this.privateParams);this.symmetric=f.symmetric.aes256;const{blockSize:i}=ot(this.symmetric);if(r.aeadProtect){this.s2kUsage=253,this.aead=r.preferredAEADAlgorithm;const s=Ve(this.aead);this.isLegacyAEAD=this.version===5,this.usedModernAEAD=!this.isLegacyAEAD;const a=Mi(this.constructor.tag),o=await Ms(this.version,this.s2k,t,this.symmetric,this.aead,a,this.isLegacyAEAD),c=await s(this.symmetric,o);this.iv=this.isLegacyAEAD?Dt(i):Dt(s.ivLength);const u=this.isLegacyAEAD?new Uint8Array:d.concatUint8Array([a,this.writePublicKey()]);this.keyMaterial=await c.encrypt(e,this.iv.subarray(0,s.ivLength),u)}else{this.s2kUsage=254,this.usedModernAEAD=!1;const s=await Ms(this.version,this.s2k,t,this.symmetric);this.iv=Dt(i),this.keyMaterial=await Vn(this.symmetric,s,d.concatUint8Array([e,await Qe(f.hash.sha1,e)]),this.iv)}}async decrypt(t){if(this.isDummy())return!1;if(this.unparseableKeyMaterial)throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");if(this.isDecrypted())throw Error("Key packet is already decrypted.");let r;const e=Mi(this.constructor.tag);if(this.s2kUsage!==254&&this.s2kUsage!==253)throw this.s2kUsage===255?Error("Encrypted private key is authenticated using an insecure two-byte hash"):Error("Private key is encrypted using an insecure S2K function: unsalted MD5");let i;if(r=await Ms(this.version,this.s2k,t,this.symmetric,this.aead,e,this.isLegacyAEAD),this.s2kUsage===253){const s=Ve(this.aead,!0),a=await s(this.symmetric,r);try{const o=this.isLegacyAEAD?new Uint8Array:d.concatUint8Array([e,this.writePublicKey()]);i=await a.decrypt(this.keyMaterial,this.iv.subarray(0,s.ivLength),o)}catch(o){throw o.message==="Authentication tag mismatch"?Error("Incorrect key passphrase: "+o.message):o}}else{const s=await cs(this.symmetric,r,this.keyMaterial,this.iv);i=s.subarray(0,-20);const a=await Qe(f.hash.sha1,i);if(!d.equalsUint8Array(a,s.subarray(-20)))throw Error("Incorrect key passphrase")}try{const{privateParams:s}=Io(this.algorithm,i,this.publicParams);this.privateParams=s}catch{throw Error("Error reading MPIs")}this.isEncrypted=!1,this.keyMaterial=null,this.s2kUsage=0,this.aead=null,this.symmetric=null,this.isLegacyAEAD=null}async validate(){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key is not decrypted");if(this.usedModernAEAD)return;let t;try{t=await z3(this.algorithm,this.publicParams,this.privateParams)}catch{t=!1}if(!t)throw Error("Key is invalid")}async generate(t,r){if(this.version===6&&(this.algorithm===f.publicKey.ecdh&&r===f.curve.curve25519Legacy||this.algorithm===f.publicKey.eddsaLegacy))throw Error(`Cannot generate v6 keys of type 'ecc' with curve ${r}. Generate a key of type 'curve25519' instead`);const{privateParams:e,publicParams:i}=await H3(this.algorithm,t,r);this.privateParams=e,this.publicParams=i,this.isEncrypted=!1}clearPrivateParams(){this.isMissingSecretKeyMaterial()||(Object.keys(this.privateParams).forEach((t=>{this.privateParams[t].fill(0),delete this.privateParams[t]})),this.privateParams=null,this.isEncrypted=!0)}}async function Ms(n,t,r,e,i,s,a){if(t.type==="argon2"&&!i)throw Error("Using Argon2 S2K without AEAD is not allowed");if(t.type==="simple"&&n===6)throw Error("Using Simple S2K with version 6 keys is not allowed");const{keySize:o}=ot(e),c=await t.produceKey(r,o);if(!i||n===5||a)return c;const u=d.concatUint8Array([s,new Uint8Array([n,e,i])]);return pr(f.hash.sha256,c,new Uint8Array,u,o)}class gs{static get tag(){return f.packet.userID}constructor(){this.userID="",this.name="",this.email="",this.comment=""}static fromObject(t){if(d.isString(t)||t.name&&!d.isString(t.name)||t.email&&!d.isEmailAddress(t.email)||t.comment&&!d.isString(t.comment))throw Error("Invalid user ID format");const r=new gs;Object.assign(r,t);const e=[];return r.name&&e.push(r.name),r.comment&&e.push(`(${r.comment})`),r.email&&e.push(`<${r.email}>`),r.userID=e.join(" "),r}read(t,r=G){const e=d.decodeUTF8(t);if(e.length>r.maxUserIDLength)throw Error("User ID string is too long");const i=o=>/^[^\s@]+@[^\s@]+$/.test(o),s=e.indexOf("<"),a=e.lastIndexOf(">");if(s!==-1&&a!==-1&&a>s){const o=e.substring(s+1,a);if(i(o)){this.email=o;const c=e.substring(0,s).trim(),u=c.indexOf("("),h=c.lastIndexOf(")");u!==-1&&h!==-1&&h>u?(this.comment=c.substring(u+1,h).trim(),this.name=c.substring(0,u).trim()):(this.name=c,this.comment="")}}else i(e.trim())&&(this.email=e.trim(),this.name="",this.comment="");this.userID=e}write(){return d.encodeUTF8(this.userID)}equals(t){return t&&t.userID===this.userID}}class H1 extends Ja{static get tag(){return f.packet.secretSubkey}constructor(t=new Date,r=G){super(t,r)}}class C5{static get tag(){return f.packet.trust}read(){throw new it("Trust packets are not supported")}write(){throw new it("Trust packets are not supported")}}class U5{static get tag(){return f.packet.padding}constructor(){this.padding=null}read(t){}write(){return this.padding}async createPadding(t){this.padding=Dt(t)}}const vu=d.constructAllowedPackets([Bt]);class Ur{constructor(t){this.packets=t||new rt}write(){return this.packets.write()}armor(t=G){const r=this.packets.some((e=>e.constructor.tag===Bt.tag&&e.version!==6));return gn(f.armor.signature,this.write(),void 0,void 0,void 0,r,t)}getSigningKeyIDs(){return this.packets.map((t=>t.issuerKeyID))}}async function P5({armoredSignature:n,binarySignature:t,config:r,...e}){r={...G,...r};let i=n||t;if(!i)throw Error("readSignature: must pass options object containing `armoredSignature` or `binarySignature`");if(n&&!d.isString(n))throw Error("readSignature: options.armoredSignature must be a string");if(t&&!d.isUint8Array(t))throw Error("readSignature: options.binarySignature must be a Uint8Array");const s=Object.keys(e);if(s.length>0)throw Error("Unknown option: "+s.join(", "));if(n){const{type:o,data:c}=await Ze(i);if(o!==f.armor.signature)throw Error("Armored text not of type signature");i=c}const a=await rt.fromBinary(i,vu,r);return new Ur(a)}async function z1(n,t){const r=new H1(n.date,t);return r.packets=null,r.algorithm=f.write(f.publicKey,n.algorithm),await r.generate(n.rsaBits,n.curve),await r.computeFingerprintAndKeyID(),r}async function Iu(n,t){const r=new Ja(n.date,t);return r.packets=null,r.algorithm=f.write(f.publicKey,n.algorithm),await r.generate(n.rsaBits,n.curve,n.config),await r.computeFingerprintAndKeyID(),r}async function ne(n,t,r,e,i=new Date,s){let a,o;for(let c=n.length-1;c>=0;c--)try{(!a||n[c].created>=a.created)&&(await n[c].verify(t,r,e,i,void 0,s),a=n[c])}catch(u){o=u}if(!a)throw d.wrapError(`Could not find valid ${f.read(f.signature,r)} signature in key ${t.getKeyID().toHex()}`.replace("certGeneric ","self-").replace(/([a-z])([A-Z])/g,((c,u,h)=>u+" "+h.toLowerCase())),o);return a}function ma(n,t,r=new Date){const e=d.normalizeDate(r);if(e!==null){const i=Vi(n,t);return!(n.created<=e&&e<i)}return!1}async function G1(n,t,r,e){const i={};i.key=t,i.bind=n;const s={signatureType:f.signature.subkeyBinding};return r.sign?(s.keyFlags=[f.keyFlags.signData],s.embeddedSignature=await xe(i,[],n,{signatureType:f.signature.keyBinding},r.date,void 0,void 0,void 0,e)):s.keyFlags=[f.keyFlags.encryptCommunication|f.keyFlags.encryptStorage],r.keyExpirationTime>0&&(s.keyExpirationTime=r.keyExpirationTime,s.keyNeverExpires=!1),await xe(i,[],t,s,r.date,void 0,void 0,void 0,e)}async function Su(n,t,r=new Date,e=[],i){const s=f.hash.sha256,a=i.preferredHashAlgorithm,o=await Promise.all(n.map((async(l,y)=>(await l.getPrimarySelfSignature(r,e[y],i)).preferredHashAlgorithms||[]))),c=new Map;for(const l of o)for(const y of l)try{const g=f.write(f.hash,y);c.set(g,c.has(g)?c.get(g)+1:1)}catch{}const u=l=>n.length===0||c.get(l)===n.length||l===s,h=()=>{if(c.size===0)return s;const l=Array.from(c.keys()).filter((y=>u(y))).sort(((y,g)=>It(y)-It(g)))[0];return It(l)>=It(s)?l:s};if(new Set([f.publicKey.ecdsa,f.publicKey.eddsaLegacy,f.publicKey.ed25519,f.publicKey.ed448]).has(t.algorithm)){const l=(function(p,A){switch(p){case f.publicKey.ecdsa:case f.publicKey.eddsaLegacy:return w1(A);case f.publicKey.ed25519:case f.publicKey.ed448:return ts(p);default:throw Error("Unknown elliptic signing algo")}})(t.algorithm,t.publicParams.oid),y=u(a),g=It(a)>=It(l);if(y&&g)return a;{const p=h();return It(p)>=It(l)?p:l}}return u(a)?a:h()}async function xe(n,t,r,e,i,s,a=[],o=!1,c){if(r.isDummy())throw Error("Cannot sign with a gnu-dummy key.");if(!r.isDecrypted())throw Error("Signing key is not decrypted.");const u=new Bt;return Object.assign(u,e),u.publicKeyAlgorithm=r.algorithm,u.hashAlgorithm=await Su(t,r,i,s,c),u.rawNotations=[...a],await u.sign(r,n,i,o,c),u}async function Pr(n,t,r,e=new Date,i){(n=n[r])&&(t[r].length?await Promise.all(n.map((async function(s){s.isExpired(e)||i&&!await i(s)||t[r].some((function(a){return d.equalsUint8Array(a.writeParams(),s.writeParams())}))||t[r].push(s)}))):t[r]=n)}async function hn(n,t,r,e,i,s,a=new Date,o){s=s||n;const c=[];return await Promise.all(e.map((async function(u){try{if(!i||u.issuerKeyID.equals(i.issuerKeyID)){const h=![f.reasonForRevocation.keyRetired,f.reasonForRevocation.keySuperseded,f.reasonForRevocation.userIDInvalid].includes(u.reasonForRevocationFlag);await u.verify(s,t,r,h?null:a,!1,o),c.push(u.issuerKeyID)}}catch{}}))),i?(i.revoked=!!c.some((u=>u.equals(i.issuerKeyID)))||i.revoked||!1,i.revoked):c.length>0}function Vi(n,t){let r;return t.keyNeverExpires===!1&&(r=n.created.getTime()+1e3*t.keyExpirationTime),r?new Date(r):1/0}function ba(n,t={}){switch(n.type=n.type||t.type,n.curve=n.curve||t.curve,n.rsaBits=n.rsaBits||t.rsaBits,n.keyExpirationTime=n.keyExpirationTime!==void 0?n.keyExpirationTime:t.keyExpirationTime,n.passphrase=d.isString(n.passphrase)?n.passphrase:t.passphrase,n.date=n.date||t.date,n.sign=n.sign||!1,n.type){case"ecc":try{n.curve=f.write(f.curve,n.curve)}catch{throw Error("Unknown curve")}n.curve!==f.curve.ed25519Legacy&&n.curve!==f.curve.curve25519Legacy&&n.curve!=="ed25519"&&n.curve!=="curve25519"||(n.curve=n.sign?f.curve.ed25519Legacy:f.curve.curve25519Legacy),n.sign?n.algorithm=n.curve===f.curve.ed25519Legacy?f.publicKey.eddsaLegacy:f.publicKey.ecdsa:n.algorithm=f.publicKey.ecdh;break;case"curve25519":n.algorithm=n.sign?f.publicKey.ed25519:f.publicKey.x25519;break;case"curve448":n.algorithm=n.sign?f.publicKey.ed448:f.publicKey.x448;break;case"rsa":n.algorithm=f.publicKey.rsaEncryptSign;break;default:throw Error("Unsupported key type "+n.type)}return n}function Ho(n,t,r){switch(n.algorithm){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaSign:case f.publicKey.dsa:case f.publicKey.ecdsa:case f.publicKey.eddsaLegacy:case f.publicKey.ed25519:case f.publicKey.ed448:if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!t.keyFlags||!!(t.keyFlags[0]&f.keyFlags.signData);default:return!1}}function zo(n,t,r){switch(n.algorithm){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaEncrypt:case f.publicKey.elgamal:case f.publicKey.ecdh:case f.publicKey.x25519:case f.publicKey.x448:if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!t.keyFlags||!!(t.keyFlags[0]&f.keyFlags.encryptCommunication)||!!(t.keyFlags[0]&f.keyFlags.encryptStorage);default:return!1}}function Go(n,t,r){if(!t.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");switch(n.algorithm){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaEncrypt:case f.publicKey.elgamal:case f.publicKey.ecdh:case f.publicKey.x25519:case f.publicKey.x448:return!(!(!t.keyFlags||t.keyFlags[0]&f.keyFlags.signData)||!r.allowInsecureDecryptionWithSigningKeys)||!t.keyFlags||!!(t.keyFlags[0]&f.keyFlags.encryptCommunication)||!!(t.keyFlags[0]&f.keyFlags.encryptStorage);default:return!1}}function cr(n,t){const r=f.write(f.publicKey,n.algorithm),e=n.getAlgorithmInfo();if(t.rejectPublicKeyAlgorithms.has(r))throw Error(e.algorithm+" keys are considered too weak.");switch(r){case f.publicKey.rsaEncryptSign:case f.publicKey.rsaSign:case f.publicKey.rsaEncrypt:if(e.bits<t.minRSABits)throw Error(`RSA keys shorter than ${t.minRSABits} bits are considered too weak.`);break;case f.publicKey.ecdsa:case f.publicKey.eddsaLegacy:case f.publicKey.ecdh:if(t.rejectCurves.has(e.curve))throw Error(`Support for ${e.algorithm} keys using curve ${e.curve} is disabled.`)}}class Hn{constructor(t,r){this.userID=t.constructor.tag===f.packet.userID?t:null,this.userAttribute=t.constructor.tag===f.packet.userAttribute?t:null,this.selfCertifications=[],this.otherCertifications=[],this.revocationSignatures=[],this.mainKey=r}toPacketList(){const t=new rt;return t.push(this.userID||this.userAttribute),t.push(...this.revocationSignatures),t.push(...this.selfCertifications),t.push(...this.otherCertifications),t}clone(){const t=new Hn(this.userID||this.userAttribute,this.mainKey);return t.selfCertifications=[...this.selfCertifications],t.otherCertifications=[...this.otherCertifications],t.revocationSignatures=[...this.revocationSignatures],t}async certify(t,r,e){const i=this.mainKey.keyPacket,s={userID:this.userID,userAttribute:this.userAttribute,key:i},a=new Hn(s.userID||s.userAttribute,this.mainKey);return a.otherCertifications=await Promise.all(t.map((async function(o){if(!o.isPrivate())throw Error("Need private key for signing");if(o.hasSameFingerprintAs(i))throw Error("The user's own key can only be used for self-certifications");const c=await o.getSigningKey(void 0,r,void 0,e);return xe(s,[o],c.keyPacket,{signatureType:f.signature.certGeneric,keyFlags:[f.keyFlags.certifyKeys|f.keyFlags.signData]},r,void 0,void 0,void 0,e)}))),await a.update(this,r,e),a}async isRevoked(t,r,e=new Date,i=G){const s=this.mainKey.keyPacket;return hn(s,f.signature.certRevocation,{key:s,userID:this.userID,userAttribute:this.userAttribute},this.revocationSignatures,t,r,e,i)}async verifyCertificate(t,r,e=new Date,i){const s=this,a=this.mainKey.keyPacket,o={userID:this.userID,userAttribute:this.userAttribute,key:a},{issuerKeyID:c}=t,u=r.filter((h=>h.getKeys(c).length>0));return u.length===0?null:(await Promise.all(u.map((async h=>{const l=await h.getSigningKey(c,t.created,void 0,i);if(t.revoked||await s.isRevoked(t,l.keyPacket,e,i))throw Error("User certificate is revoked");try{await t.verify(l.keyPacket,f.signature.certGeneric,o,e,void 0,i)}catch(y){throw d.wrapError("User certificate is invalid",y)}}))),!0)}async verifyAllCertifications(t,r=new Date,e){const i=this,s=this.selfCertifications.concat(this.otherCertifications);return Promise.all(s.map((async a=>({keyID:a.issuerKeyID,valid:await i.verifyCertificate(a,t,r,e).catch((()=>!1))}))))}async verify(t=new Date,r){if(!this.selfCertifications.length)throw Error("No self-certifications found");const e=this,i=this.mainKey.keyPacket,s={userID:this.userID,userAttribute:this.userAttribute,key:i};let a;for(let o=this.selfCertifications.length-1;o>=0;o--)try{const c=this.selfCertifications[o];if(c.revoked||await e.isRevoked(c,void 0,t,r))throw Error("Self-certification is revoked");try{await c.verify(i,f.signature.certGeneric,s,t,void 0,r)}catch(u){throw d.wrapError("Self-certification is invalid",u)}return!0}catch(c){a=c}throw a}async update(t,r,e){const i=this.mainKey.keyPacket,s={userID:this.userID,userAttribute:this.userAttribute,key:i};await Pr(t,this,"selfCertifications",r,(async function(a){try{return await a.verify(i,f.signature.certGeneric,s,r,!1,e),!0}catch{return!1}})),await Pr(t,this,"otherCertifications",r),await Pr(t,this,"revocationSignatures",r,(function(a){return hn(i,f.signature.certRevocation,s,[a],void 0,void 0,r,e)}))}async revoke(t,{flag:r=f.reasonForRevocation.noReason,string:e=""}={},i=new Date,s=G){const a={userID:this.userID,userAttribute:this.userAttribute,key:t},o=new Hn(a.userID||a.userAttribute,this.mainKey);return o.revocationSignatures.push(await xe(a,[],t,{signatureType:f.signature.certRevocation,reasonForRevocationFlag:f.write(f.reasonForRevocation,r),reasonForRevocationString:e},i,void 0,void 0,!1,s)),await o.update(this),o}}class fn{constructor(t,r){this.keyPacket=t,this.bindingSignatures=[],this.revocationSignatures=[],this.mainKey=r}toPacketList(){const t=new rt;return t.push(this.keyPacket),t.push(...this.revocationSignatures),t.push(...this.bindingSignatures),t}clone(){const t=new fn(this.keyPacket,this.mainKey);return t.bindingSignatures=[...this.bindingSignatures],t.revocationSignatures=[...this.revocationSignatures],t}async isRevoked(t,r,e=new Date,i=G){const s=this.mainKey.keyPacket;return hn(s,f.signature.subkeyRevocation,{key:s,bind:this.keyPacket},this.revocationSignatures,t,r,e,i)}async verify(t=new Date,r=G){const e=this.mainKey.keyPacket,i={key:e,bind:this.keyPacket},s=await ne(this.bindingSignatures,e,f.signature.subkeyBinding,i,t,r);if(s.revoked||await this.isRevoked(s,null,t,r))throw Error("Subkey is revoked");if(ma(this.keyPacket,s,t))throw Error("Subkey is expired");return s}async getExpirationTime(t=new Date,r=G){const e=this.mainKey.keyPacket,i={key:e,bind:this.keyPacket};let s;try{s=await ne(this.bindingSignatures,e,f.signature.subkeyBinding,i,t,r)}catch{return null}const a=Vi(this.keyPacket,s),o=s.getExpirationTime();return a<o?a:o}async update(t,r=new Date,e=G){const i=this.mainKey.keyPacket;if(!this.hasSameFingerprintAs(t))throw Error("Subkey update method: fingerprints of subkeys not equal");this.keyPacket.constructor.tag===f.packet.publicSubkey&&t.keyPacket.constructor.tag===f.packet.secretSubkey&&(this.keyPacket=t.keyPacket);const s=this,a={key:i,bind:s.keyPacket};await Pr(t,this,"bindingSignatures",r,(async function(o){for(let c=0;c<s.bindingSignatures.length;c++)if(s.bindingSignatures[c].issuerKeyID.equals(o.issuerKeyID))return o.created>s.bindingSignatures[c].created&&(s.bindingSignatures[c]=o),!1;try{return await o.verify(i,f.signature.subkeyBinding,a,r,void 0,e),!0}catch{return!1}})),await Pr(t,this,"revocationSignatures",r,(function(o){return hn(i,f.signature.subkeyRevocation,a,[o],void 0,void 0,r,e)}))}async revoke(t,{flag:r=f.reasonForRevocation.noReason,string:e=""}={},i=new Date,s=G){const a={key:t,bind:this.keyPacket},o=new fn(this.keyPacket,this.mainKey);return o.revocationSignatures.push(await xe(a,[],t,{signatureType:f.signature.subkeyRevocation,reasonForRevocationFlag:f.write(f.reasonForRevocation,r),reasonForRevocationString:e},i,void 0,void 0,!1,s)),await o.update(this),o}hasSameFingerprintAs(t){return this.keyPacket.hasSameFingerprintAs(t.keyPacket||t)}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","isDecrypted"].forEach((n=>{fn.prototype[n]=function(){return this.keyPacket[n]()}}));const Bu=d.constructAllowedPackets([Bt]),jo=new Set([f.packet.publicKey,f.packet.privateKey]),Vo=new Set([f.packet.publicKey,f.packet.privateKey,f.packet.publicSubkey,f.packet.privateSubkey]);class j1{packetListToStructure(t,r=new Set){let e,i,s,a;for(const o of t){if(o instanceof ea){Vo.has(o.tag)&&!a&&(a=jo.has(o.tag)?jo:Vo);continue}const c=o.constructor.tag;if(a){if(!a.has(c))continue;a=null}if(r.has(c))throw Error("Unexpected packet type: "+c);switch(c){case f.packet.publicKey:case f.packet.secretKey:if(this.keyPacket)throw Error("Key block contains multiple keys");if(this.keyPacket=o,i=this.getKeyID(),!i)throw Error("Missing Key ID");break;case f.packet.userID:case f.packet.userAttribute:e=new Hn(o,this),this.users.push(e);break;case f.packet.publicSubkey:case f.packet.secretSubkey:e=null,s=new fn(o,this),this.subkeys.push(s);break;case f.packet.signature:switch(o.signatureType){case f.signature.certGeneric:case f.signature.certPersona:case f.signature.certCasual:case f.signature.certPositive:if(!e){d.printDebug("Dropping certification signatures without preceding user packet");continue}o.issuerKeyID.equals(i)?e.selfCertifications.push(o):e.otherCertifications.push(o);break;case f.signature.certRevocation:e?e.revocationSignatures.push(o):this.directSignatures.push(o);break;case f.signature.key:this.directSignatures.push(o);break;case f.signature.subkeyBinding:if(!s){d.printDebug("Dropping subkey binding signature without preceding subkey packet");continue}s.bindingSignatures.push(o);break;case f.signature.keyRevocation:this.revocationSignatures.push(o);break;case f.signature.subkeyRevocation:if(!s){d.printDebug("Dropping subkey revocation signature without preceding subkey packet");continue}s.revocationSignatures.push(o)}}}}toPacketList(){const t=new rt;return t.push(this.keyPacket),t.push(...this.revocationSignatures),t.push(...this.directSignatures),this.users.map((r=>t.push(...r.toPacketList()))),this.subkeys.map((r=>t.push(...r.toPacketList()))),t}clone(t=!1){const r=new this.constructor(this.toPacketList());return t&&r.getKeys().forEach((e=>{if(e.keyPacket=Object.create(Object.getPrototypeOf(e.keyPacket),Object.getOwnPropertyDescriptors(e.keyPacket)),!e.keyPacket.isDecrypted())return;const i={};Object.keys(e.keyPacket.privateParams).forEach((s=>{i[s]=new Uint8Array(e.keyPacket.privateParams[s])})),e.keyPacket.privateParams=i})),r}getSubkeys(t=null){return this.subkeys.filter((r=>!t||r.getKeyID().equals(t,!0)))}getKeys(t=null){const r=[];return t&&!this.getKeyID().equals(t,!0)||r.push(this),r.concat(this.getSubkeys(t))}getKeyIDs(){return this.getKeys().map((t=>t.getKeyID()))}getUserIDs(){return this.users.map((t=>t.userID?t.userID.userID:null)).filter((t=>t!==null))}write(){return this.toPacketList().write()}async getSigningKey(t=null,r=new Date,e={},i=G){await this.verifyPrimaryKey(r,e,i);const s=this.keyPacket;try{cr(s,i)}catch(c){throw d.wrapError("Could not verify primary key",c)}const a=this.subkeys.slice().sort(((c,u)=>u.keyPacket.created-c.keyPacket.created||u.keyPacket.algorithm-c.keyPacket.algorithm));let o;for(const c of a)if(!t||c.getKeyID().equals(t))try{await c.verify(r,i);const u={key:s,bind:c.keyPacket},h=await ne(c.bindingSignatures,s,f.signature.subkeyBinding,u,r,i);if(!Ho(c.keyPacket,h,i))continue;if(!h.embeddedSignature)throw Error("Missing embedded signature");return await ne([h.embeddedSignature],c.keyPacket,f.signature.keyBinding,u,r,i),cr(c.keyPacket,i),c}catch(u){o=u}try{const c=await this.getPrimarySelfSignature(r,e,i);if((!t||s.getKeyID().equals(t))&&Ho(s,c,i))return cr(s,i),this}catch(c){o=c}throw d.wrapError("Could not find valid signing key packet in key "+this.getKeyID().toHex(),o)}async getEncryptionKey(t,r=new Date,e={},i=G){await this.verifyPrimaryKey(r,e,i);const s=this.keyPacket;try{cr(s,i)}catch(c){throw d.wrapError("Could not verify primary key",c)}const a=this.subkeys.slice().sort(((c,u)=>u.keyPacket.created-c.keyPacket.created||u.keyPacket.algorithm-c.keyPacket.algorithm));let o;for(const c of a)if(!t||c.getKeyID().equals(t))try{await c.verify(r,i);const u={key:s,bind:c.keyPacket},h=await ne(c.bindingSignatures,s,f.signature.subkeyBinding,u,r,i);if(zo(c.keyPacket,h,i))return cr(c.keyPacket,i),c}catch(u){o=u}try{const c=await this.getPrimarySelfSignature(r,e,i);if((!t||s.getKeyID().equals(t))&&zo(s,c,i))return cr(s,i),this}catch(c){o=c}throw d.wrapError("Could not find valid encryption key packet in key "+this.getKeyID().toHex(),o)}async isRevoked(t,r,e=new Date,i=G){return hn(this.keyPacket,f.signature.keyRevocation,{key:this.keyPacket},this.revocationSignatures,t,r,e,i)}async verifyPrimaryKey(t=new Date,r={},e=G){const i=this.keyPacket;if(await this.isRevoked(null,null,t,e))throw Error("Primary key is revoked");if(ma(i,await this.getPrimarySelfSignature(t,r,e),t))throw Error("Primary key is expired");if(i.version!==6){const s=await ne(this.directSignatures,i,f.signature.key,{key:i},t,e).catch((()=>{}));if(s&&ma(i,s,t))throw Error("Primary key is expired")}}async getExpirationTime(t,r=G){let e;try{const i=await this.getPrimarySelfSignature(null,t,r),s=Vi(this.keyPacket,i),a=i.getExpirationTime(),o=this.keyPacket.version!==6&&await ne(this.directSignatures,this.keyPacket,f.signature.key,{key:this.keyPacket},null,r).catch((()=>{}));if(o){const c=Vi(this.keyPacket,o);e=Math.min(s,a,c)}else e=s<a?s:a}catch{e=null}return d.normalizeDate(e)}async getPrimarySelfSignature(t=new Date,r={},e=G){const i=this.keyPacket;if(i.version===6)return ne(this.directSignatures,i,f.signature.key,{key:i},t,e);const{selfCertification:s}=await this.getPrimaryUser(t,r,e);return s}async getPrimaryUser(t=new Date,r={},e=G){const i=this.keyPacket,s=[];let a;for(let h=0;h<this.users.length;h++)try{const l=this.users[h];if(!l.userID)continue;if(r.name!==void 0&&l.userID.name!==r.name||r.email!==void 0&&l.userID.email!==r.email||r.comment!==void 0&&l.userID.comment!==r.comment)throw Error("Could not find user that matches that user ID");const y={userID:l.userID,key:i},g=await ne(l.selfCertifications,i,f.signature.certGeneric,y,t,e);s.push({index:h,user:l,selfCertification:g})}catch(l){a=l}if(!s.length)throw a||Error("Could not find primary user");await Promise.all(s.map((async h=>{h.selfCertification.revoked||await h.user.isRevoked(h.selfCertification,null,t,e)})));const o=s.sort((function(h,l){const y=h.selfCertification,g=l.selfCertification;return g.revoked-y.revoked||y.isPrimaryUserID-g.isPrimaryUserID||y.created-g.created})).pop(),{user:c,selfCertification:u}=o;if(u.revoked||await c.isRevoked(u,null,t,e))throw Error("Primary user is revoked");return o}async update(t,r=new Date,e=G){if(!this.hasSameFingerprintAs(t))throw Error("Primary key fingerprints must be equal to update the key");if(!this.isPrivate()&&t.isPrivate()){if(!(this.subkeys.length===t.subkeys.length&&this.subkeys.every((s=>t.subkeys.some((a=>s.hasSameFingerprintAs(a)))))))throw Error("Cannot update public key with private key if subkeys mismatch");return t.update(this,e)}const i=this.clone();return await Pr(t,i,"revocationSignatures",r,(s=>hn(i.keyPacket,f.signature.keyRevocation,i,[s],null,t.keyPacket,r,e))),await Pr(t,i,"directSignatures",r),await Promise.all(t.users.map((async s=>{const a=i.users.filter((o=>s.userID&&s.userID.equals(o.userID)||s.userAttribute&&s.userAttribute.equals(o.userAttribute)));if(a.length>0)await Promise.all(a.map((o=>o.update(s,r,e))));else{const o=s.clone();o.mainKey=i,i.users.push(o)}}))),await Promise.all(t.subkeys.map((async s=>{const a=i.subkeys.filter((o=>o.hasSameFingerprintAs(s)));if(a.length>0)await Promise.all(a.map((o=>o.update(s,r,e))));else{const o=s.clone();o.mainKey=i,i.subkeys.push(o)}}))),i}async getRevocationCertificate(t=new Date,r=G){const e={key:this.keyPacket},i=await ne(this.revocationSignatures,this.keyPacket,f.signature.keyRevocation,e,t,r),s=new rt;s.push(i);const a=this.keyPacket.version!==6;return gn(f.armor.publicKey,s.write(),null,null,"This is a revocation certificate",a,r)}async applyRevocationCertificate(t,r=new Date,e=G){const i=await Ze(t),s=(await rt.fromBinary(i.data,Bu,e)).findPacket(f.packet.signature);if(!s||s.signatureType!==f.signature.keyRevocation)throw Error("Could not find revocation signature packet");if(!s.issuerKeyID.equals(this.getKeyID()))throw Error("Revocation signature does not match key");try{await s.verify(this.keyPacket,f.signature.keyRevocation,{key:this.keyPacket},r,void 0,e)}catch(o){throw d.wrapError("Could not verify revocation signature",o)}const a=this.clone();return a.revocationSignatures.push(s),a}async signPrimaryUser(t,r,e,i=G){const{index:s,user:a}=await this.getPrimaryUser(r,e,i),o=await a.certify(t,r,i),c=this.clone();return c.users[s]=o,c}async signAllUsers(t,r=new Date,e=G){const i=this.clone();return i.users=await Promise.all(this.users.map((function(s){return s.certify(t,r,e)}))),i}async verifyPrimaryUser(t,r=new Date,e,i=G){const s=this.keyPacket,{user:a}=await this.getPrimaryUser(r,e,i);return t?await a.verifyAllCertifications(t,r,i):[{keyID:s.getKeyID(),valid:await a.verify(r,i).catch((()=>!1))}]}async verifyAllUsers(t,r=new Date,e=G){const i=this.keyPacket,s=[];return await Promise.all(this.users.map((async a=>{const o=t?await a.verifyAllCertifications(t,r,e):[{keyID:i.getKeyID(),valid:await a.verify(r,e).catch((()=>!1))}];s.push(...o.map((c=>({userID:a.userID?a.userID.userID:null,userAttribute:a.userAttribute,keyID:c.keyID,valid:c.valid}))))}))),s}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","hasSameFingerprintAs"].forEach((n=>{j1.prototype[n]=fn.prototype[n]}));class ka extends j1{constructor(t){if(super(),this.keyPacket=null,this.revocationSignatures=[],this.directSignatures=[],this.users=[],this.subkeys=[],t&&(this.packetListToStructure(t,new Set([f.packet.secretKey,f.packet.secretSubkey])),!this.keyPacket))throw Error("Invalid key: missing public-key packet")}isPrivate(){return!1}toPublic(){return this}armor(t=G){const r=this.keyPacket.version!==6;return gn(f.armor.publicKey,this.toPacketList().write(),void 0,void 0,void 0,r,t)}}class pn extends ka{constructor(t){if(super(),this.packetListToStructure(t,new Set([f.packet.publicKey,f.packet.publicSubkey])),!this.keyPacket)throw Error("Invalid key: missing private-key packet")}isPrivate(){return!0}toPublic(){const t=new rt,r=this.toPacketList();for(const e of r)switch(e.constructor.tag){case f.packet.secretKey:{const i=Ke.fromSecretKeyPacket(e);t.push(i);break}case f.packet.secretSubkey:{const i=ys.fromSecretSubkeyPacket(e);t.push(i);break}default:t.push(e)}return new ka(t)}armor(t=G){const r=this.keyPacket.version!==6;return gn(f.armor.privateKey,this.toPacketList().write(),void 0,void 0,void 0,r,t)}async getDecryptionKeys(t,r=new Date,e={},i=G){const s=this.keyPacket,a=[];let o=null;for(let u=0;u<this.subkeys.length;u++)if(!t||this.subkeys[u].getKeyID().equals(t,!0)){if(this.subkeys[u].keyPacket.isDummy()){o=o||Error("Gnu-dummy key packets cannot be used for decryption");continue}try{const h={key:s,bind:this.subkeys[u].keyPacket},l=await ne(this.subkeys[u].bindingSignatures,s,f.signature.subkeyBinding,h,r,i);Go(this.subkeys[u].keyPacket,l,i)&&a.push(this.subkeys[u])}catch(h){o=h}}const c=await this.getPrimarySelfSignature(r,e,i);if(t&&!s.getKeyID().equals(t,!0)||!Go(s,c,i)||(s.isDummy()?o=o||Error("Gnu-dummy key packets cannot be used for decryption"):a.push(this)),a.length===0)throw o||Error("No decryption key packets found");return a}isDecrypted(){return this.getKeys().some((({keyPacket:t})=>t.isDecrypted()))}async validate(t=G){if(!this.isPrivate())throw Error("Cannot validate a public key");let r;if(this.keyPacket.isDummy()){const e=await this.getSigningKey(null,null,void 0,{...t,rejectPublicKeyAlgorithms:new Set,minRSABits:0});e&&!e.keyPacket.isDummy()&&(r=e.keyPacket)}else r=this.keyPacket;if(r)return r.validate();{const e=this.getKeys();if(e.map((i=>i.keyPacket.isDummy())).every(Boolean))throw Error("Cannot validate an all-gnu-dummy key");return Promise.all(e.map((i=>i.keyPacket.validate())))}}clearPrivateParams(){this.getKeys().forEach((({keyPacket:t})=>{t.isDecrypted()&&t.clearPrivateParams()}))}async revoke({flag:t=f.reasonForRevocation.noReason,string:r=""}={},e=new Date,i=G){if(!this.isPrivate())throw Error("Need private key for revoking");const s={key:this.keyPacket},a=this.clone();return a.revocationSignatures.push(await xe(s,[],this.keyPacket,{signatureType:f.signature.keyRevocation,reasonForRevocationFlag:f.write(f.reasonForRevocation,t),reasonForRevocationString:r},e,void 0,void 0,void 0,i)),a}async addSubkey(t={}){const r={...G,...t.config};if(t.passphrase)throw Error("Subkey could not be encrypted here, please encrypt whole key");if(t.rsaBits<r.minRSABits)throw Error(`rsaBits should be at least ${r.minRSABits}, got: ${t.rsaBits}`);const e=this.keyPacket;if(e.isDummy())throw Error("Cannot add subkey to gnu-dummy primary key");if(!e.isDecrypted())throw Error("Key is not decrypted");const i=e.getAlgorithmInfo();i.type=(function(c){switch(f.write(f.publicKey,c)){case f.publicKey.rsaEncrypt:case f.publicKey.rsaEncryptSign:case f.publicKey.rsaSign:case f.publicKey.dsa:return"rsa";case f.publicKey.ecdsa:case f.publicKey.eddsaLegacy:return"ecc";case f.publicKey.ed25519:return"curve25519";case f.publicKey.ed448:return"curve448";default:throw Error("Unsupported algorithm")}})(i.algorithm),i.rsaBits=i.bits||4096,i.curve=i.curve||"curve25519Legacy",t=ba(t,i);const s=await z1(t,{...r,v6Keys:this.keyPacket.version===6});cr(s,r);const a=await G1(s,e,t,r),o=this.toPacketList();return o.push(s,a),new pn(o)}}const ps=d.constructAllowedPackets([Ke,ys,Ja,H1,gs,Za,Bt]);function V1(n){for(const t of n)switch(t.constructor.tag){case f.packet.secretKey:return new pn(n);case f.packet.publicKey:return new ka(n)}throw Error("No key packet found")}async function q1(n,t,r,e){r.passphrase&&await n.encrypt(r.passphrase,e),await Promise.all(t.map((async function(c,u){const h=r.subkeys[u].passphrase;h&&await c.encrypt(h,e)})));const i=new rt;function s(c,u){return[u,...c.filter((h=>h!==u))]}function a(){const c={};c.keyFlags=[f.keyFlags.certifyKeys|f.keyFlags.signData];const u=s([f.symmetric.aes256,f.symmetric.aes128],e.preferredSymmetricAlgorithm);if(c.preferredSymmetricAlgorithms=u,e.aeadProtect){const h=s([f.aead.gcm,f.aead.eax,f.aead.ocb],e.preferredAEADAlgorithm);c.preferredCipherSuites=h.flatMap((l=>u.map((y=>[y,l]))))}return c.preferredHashAlgorithms=s([f.hash.sha512,f.hash.sha256,f.hash.sha3_512,f.hash.sha3_256],e.preferredHashAlgorithm),c.preferredCompressionAlgorithms=s([f.compression.uncompressed,f.compression.zlib,f.compression.zip],e.preferredCompressionAlgorithm),c.features=[0],c.features[0]|=f.features.modificationDetection,e.aeadProtect&&(c.features[0]|=f.features.seipdv2),r.keyExpirationTime>0&&(c.keyExpirationTime=r.keyExpirationTime,c.keyNeverExpires=!1),c}if(i.push(n),n.version===6){const c={key:n},u=a();u.signatureType=f.signature.key;const h=await xe(c,[],n,u,r.date,void 0,void 0,void 0,e);i.push(h)}await Promise.all(r.userIDs.map((async function(c,u){const h=gs.fromObject(c),l={userID:h,key:n},y=n.version!==6?a():{};return y.signatureType=f.signature.certPositive,u===0&&(y.isPrimaryUserID=!0),{userIDPacket:h,signaturePacket:await xe(l,[],n,y,r.date,void 0,void 0,void 0,e)}}))).then((c=>{c.forEach((({userIDPacket:u,signaturePacket:h})=>{i.push(u),i.push(h)}))})),await Promise.all(t.map((async function(c,u){const h=r.subkeys[u];return{secretSubkeyPacket:c,subkeySignaturePacket:await G1(c,n,h,e)}}))).then((c=>{c.forEach((({secretSubkeyPacket:u,subkeySignaturePacket:h})=>{i.push(u),i.push(h)}))}));const o={key:n};return i.push(await xe(o,[],n,{signatureType:f.signature.keyRevocation,reasonForRevocationFlag:f.reasonForRevocation.noReason,reasonForRevocationString:""},r.date,void 0,void 0,void 0,e)),r.passphrase&&n.clearPrivateParams(),t.map((function(c,u){r.subkeys[u].passphrase&&c.clearPrivateParams()})),new pn(i)}async function D5({armoredKey:n,binaryKey:t,config:r,...e}){if(r={...G,...r},!n&&!t)throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");if(n&&!d.isString(n))throw Error("readKey: options.armoredKey must be a string");if(t&&!d.isUint8Array(t))throw Error("readKey: options.binaryKey must be a Uint8Array");const i=Object.keys(e);if(i.length>0)throw Error("Unknown option: "+i.join(", "));let s;if(n){const{type:c,data:u}=await Ze(n);if(c!==f.armor.publicKey&&c!==f.armor.privateKey)throw Error("Armored text not of type key");s=u}else s=t;const a=await rt.fromBinary(s,ps,r),o=a.indexOfTag(f.packet.publicKey,f.packet.secretKey);if(o.length===0)throw Error("No key packet found");return V1(a.slice(o[0],o[1]))}async function x5({armoredKey:n,binaryKey:t,config:r,...e}){if(r={...G,...r},!n&&!t)throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");if(n&&!d.isString(n))throw Error("readPrivateKey: options.armoredKey must be a string");if(t&&!d.isUint8Array(t))throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");const i=Object.keys(e);if(i.length>0)throw Error("Unknown option: "+i.join(", "));let s;if(n){const{type:c,data:u}=await Ze(n);if(c!==f.armor.privateKey)throw Error("Armored text not of type private key");s=u}else s=t;const a=await rt.fromBinary(s,ps,r),o=a.indexOfTag(f.packet.publicKey,f.packet.secretKey);for(let c=0;c<o.length;c++){if(a[o[c]].constructor.tag===f.packet.publicKey)continue;const u=a.slice(o[c],o[c+1]);return new pn(u)}throw Error("No secret key packet found")}async function Q5({armoredKeys:n,binaryKeys:t,config:r,...e}){r={...G,...r};let i=n||t;if(!i)throw Error("readKeys: must pass options object containing `armoredKeys` or `binaryKeys`");if(n&&!d.isString(n))throw Error("readKeys: options.armoredKeys must be a string");if(t&&!d.isUint8Array(t))throw Error("readKeys: options.binaryKeys must be a Uint8Array");const s=Object.keys(e);if(s.length>0)throw Error("Unknown option: "+s.join(", "));if(n){const{type:u,data:h}=await Ze(n);if(u!==f.armor.publicKey&&u!==f.armor.privateKey)throw Error("Armored text not of type key");i=h}const a=[],o=await rt.fromBinary(i,ps,r),c=o.indexOfTag(f.packet.publicKey,f.packet.secretKey);if(c.length===0)throw Error("No key packet found");for(let u=0;u<c.length;u++){const h=V1(o.slice(c[u],c[u+1]));a.push(h)}return a}async function M5({armoredKeys:n,binaryKeys:t,config:r}){r={...G,...r};let e=n||t;if(!e)throw Error("readPrivateKeys: must pass options object containing `armoredKeys` or `binaryKeys`");if(n&&!d.isString(n))throw Error("readPrivateKeys: options.armoredKeys must be a string");if(t&&!d.isUint8Array(t))throw Error("readPrivateKeys: options.binaryKeys must be a Uint8Array");if(n){const{type:o,data:c}=await Ze(n);if(o!==f.armor.privateKey)throw Error("Armored text not of type private key");e=c}const i=[],s=await rt.fromBinary(e,ps,r),a=s.indexOfTag(f.packet.publicKey,f.packet.secretKey);for(let o=0;o<a.length;o++){if(s[a[o]].constructor.tag===f.packet.publicKey)continue;const c=s.slice(a[o],a[o+1]),u=new pn(c);i.push(u)}if(i.length===0)throw Error("No secret key packet found");return i}const Ku=d.constructAllowedPackets([Ar,ti,bu,cn,Eu,Yn,un,ae,Bt]),Cu=d.constructAllowedPackets([un]),Uu=d.constructAllowedPackets([Bt]);class Ot{constructor(t){this.packets=t||new rt}getEncryptionKeyIDs(){const t=[];return this.packets.filterByTag(f.packet.publicKeyEncryptedSessionKey).forEach((function(r){t.push(r.publicKeyID)})),t}getSigningKeyIDs(){const t=this.unwrapCompressed(),r=t.packets.filterByTag(f.packet.onePassSignature);return r.length>0?r.map((e=>e.issuerKeyID)):t.packets.filterByTag(f.packet.signature).map((e=>e.issuerKeyID))}async decrypt(t,r,e,i=new Date,s=G){const a=this.packets.filterByTag(f.packet.symmetricallyEncryptedData,f.packet.symEncryptedIntegrityProtectedData,f.packet.aeadEncryptedData);if(a.length===0)throw Error("No encrypted data found");const o=a[0],c=o.cipherAlgorithm,u=e||await this.decryptSessionKeys(t,r,c,i,s);let h=null;const l=Promise.all(u.map((async({algorithm:g,data:p})=>{if(!d.isUint8Array(p)||!o.cipherAlgorithm&&!d.isString(g))throw Error("Invalid session key for decryption.");try{const A=o.cipherAlgorithm||f.write(f.symmetric,g);await o.decrypt(A,p,s)}catch(A){d.printDebugError(A),h=A}})));if(Ws(o.encrypted),o.encrypted=null,await l,!o.packets||!o.packets.length)throw h||Error("Decryption failed.");const y=new Ot(o.packets);return o.packets=new rt,y}async decryptSessionKeys(t,r,e,i=new Date,s=G){let a,o=[];if(r){const c=this.packets.filterByTag(f.packet.symEncryptedSessionKey);if(c.length===0)throw Error("No symmetrically encrypted session key packet found.");await Promise.all(r.map((async function(u,h){let l;l=h?await rt.fromBinary(c.write(),Cu,s):c,await Promise.all(l.map((async function(y){try{await y.decrypt(u),o.push(y)}catch(g){d.printDebugError(g),g instanceof us&&(a=g)}})))})))}else{if(!t)throw Error("No key or password specified.");{const c=this.packets.filterByTag(f.packet.publicKeyEncryptedSessionKey);if(c.length===0)throw Error("No public key encrypted session key packet found.");await Promise.all(c.map((async function(u){await Promise.all(t.map((async function(h){let l;try{l=(await h.getDecryptionKeys(u.publicKeyID,null,void 0,s)).map((g=>g.keyPacket))}catch(g){return void(a=g)}let y=[f.symmetric.aes256,f.symmetric.aes128,f.symmetric.tripledes,f.symmetric.cast5];try{const g=await h.getPrimarySelfSignature(i,void 0,s);g.preferredSymmetricAlgorithms&&(y=y.concat(g.preferredSymmetricAlgorithms))}catch{}await Promise.all(l.map((async function(g){if(!g.isDecrypted())throw Error("Decryption key is not decrypted.");if(s.constantTimePKCS1Decryption&&(u.publicKeyAlgorithm===f.publicKey.rsaEncrypt||u.publicKeyAlgorithm===f.publicKey.rsaEncryptSign||u.publicKeyAlgorithm===f.publicKey.rsaSign||u.publicKeyAlgorithm===f.publicKey.elgamal)){const p=u.write();await Promise.all((e?[e]:Array.from(s.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms)).map((async A=>{const w=new Yn;w.read(p);const b={sessionKeyAlgorithm:A,sessionKey:fa(A)};try{await w.decrypt(g,b),o.push(w)}catch(v){d.printDebugError(v),a=v}})))}else try{await u.decrypt(g);const p=e||u.sessionKeyAlgorithm;if(p&&!y.includes(f.write(f.symmetric,p)))throw Error("A non-preferred symmetric algorithm was used.");o.push(u)}catch(p){d.printDebugError(p),a=p}})))}))),Ws(u.encrypted),u.encrypted=null})))}}if(o.length>0){if(o.length>1){const c=new Set;o=o.filter((u=>{const h=u.sessionKeyAlgorithm+d.uint8ArrayToString(u.sessionKey);return!c.has(h)&&(c.add(h),!0)}))}return o.map((c=>({data:c.sessionKey,algorithm:c.sessionKeyAlgorithm&&f.read(f.symmetric,c.sessionKeyAlgorithm)})))}throw a||Error("Session key decryption failed.")}getLiteralData(){const t=this.unwrapCompressed().packets.findPacket(f.packet.literalData);return t&&t.getBytes()||null}getFilename(){const t=this.unwrapCompressed().packets.findPacket(f.packet.literalData);return t&&t.getFilename()||null}getText(){const t=this.unwrapCompressed().packets.findPacket(f.packet.literalData);return t?t.getText():null}static async generateSessionKey(t=[],r=new Date,e=[],i=G){const{symmetricAlgo:s,aeadAlgo:a}=await(async function(u=[],h=new Date,l=[],y=G){const g=await Promise.all(u.map(((w,b)=>w.getPrimarySelfSignature(h,l[b],y))));if(u.length?g.every((w=>w.features&&w.features[0]&f.features.seipdv2)):y.aeadProtect){const w={symmetricAlgo:f.symmetric.aes128,aeadAlgo:f.aead.ocb},b=[{symmetricAlgo:y.preferredSymmetricAlgorithm,aeadAlgo:y.preferredAEADAlgorithm},{symmetricAlgo:y.preferredSymmetricAlgorithm,aeadAlgo:f.aead.ocb},{symmetricAlgo:f.symmetric.aes128,aeadAlgo:y.preferredAEADAlgorithm}];for(const v of b)if(g.every((k=>k.preferredCipherSuites&&k.preferredCipherSuites.some((m=>m[0]===v.symmetricAlgo&&m[1]===v.aeadAlgo)))))return v;return w}const p=f.symmetric.aes128,A=y.preferredSymmetricAlgorithm;return{symmetricAlgo:g.every((w=>w.preferredSymmetricAlgorithms&&w.preferredSymmetricAlgorithms.includes(A)))?A:p,aeadAlgo:void 0}})(t,r,e,i),o=f.read(f.symmetric,s),c=a?f.read(f.aead,a):void 0;return await Promise.all(t.map((u=>u.getEncryptionKey().catch((()=>null)).then((h=>{if(h&&(h.keyPacket.algorithm===f.publicKey.x25519||h.keyPacket.algorithm===f.publicKey.x448)&&!c&&!d.isAES(s))throw Error("Could not generate a session key compatible with the given `encryptionKeys`: X22519 and X448 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.")}))))),{data:fa(s),algorithm:o,aeadAlgorithm:c}}async encrypt(t,r,e,i=!1,s=[],a=new Date,o=[],c=G){if(e){if(!d.isUint8Array(e.data)||!d.isString(e.algorithm))throw Error("Invalid session key for encryption.")}else if(t&&t.length)e=await Ot.generateSessionKey(t,a,o,c);else{if(!r||!r.length)throw Error("No keys, passwords, or session key provided.");e=await Ot.generateSessionKey(void 0,void 0,void 0,c)}const{data:u,algorithm:h,aeadAlgorithm:l}=e,y=await Ot.encryptSessionKey(u,h,l,t,r,i,s,a,o,c),g=cn.fromObject({version:l?2:1,aeadAlgorithm:l?f.write(f.aead,l):null});g.packets=this.packets;const p=f.write(f.symmetric,h);return await g.encrypt(p,u,c),y.packets.push(g),g.packets=new rt,y}static async encryptSessionKey(t,r,e,i,s,a=!1,o=[],c=new Date,u=[],h=G){const l=new rt,y=f.write(f.symmetric,r),g=e&&f.write(f.aead,e);if(i){const p=await Promise.all(i.map((async function(A,w){const b=await A.getEncryptionKey(o[w],c,u,h),v=Yn.fromObject({version:g?6:3,encryptionKeyPacket:b.keyPacket,anonymousRecipient:a,sessionKey:t,sessionKeyAlgorithm:y});return await v.encrypt(b.keyPacket),delete v.sessionKey,v})));l.push(...p)}if(s){const p=async function(v,k){try{return await v.decrypt(k),1}catch{return 0}},A=(v,k)=>v+k,w=async function(v,k,m,C){const D=new un(h);return D.sessionKey=v,D.sessionKeyAlgorithm=k,m&&(D.aeadAlgorithm=m),await D.encrypt(C,h),h.passwordCollisionCheck&&(await Promise.all(s.map((P=>p(D,P))))).reduce(A)!==1?w(v,k,C):(delete D.sessionKey,D)},b=await Promise.all(s.map((v=>w(t,y,g,v))));l.push(...b)}return new Ot(l)}async sign(t=[],r=[],e=null,i=[],s=new Date,a=[],o=[],c=[],u=G){const h=new rt,l=this.packets.findPacket(f.packet.literalData);if(!l)throw Error("No literal data packet to sign.");const y=await Ea(l,t,r,e,i,s,a,o,c,!1,u),g=y.map(((p,A)=>ae.fromSignaturePacket(p,A===0))).reverse();return h.push(...g),h.push(l),h.push(...y),new Ot(h)}compress(t,r=G){if(t===f.compression.uncompressed)return this;const e=new ti(r);e.algorithm=t,e.packets=this.packets;const i=new rt;return i.push(e),new Ot(i)}async signDetached(t=[],r=[],e=null,i=[],s=[],a=new Date,o=[],c=[],u=G){const h=this.packets.findPacket(f.packet.literalData);if(!h)throw Error("No literal data packet to sign.");return new Ur(await Ea(h,t,r,e,i,s,a,o,c,!0,u))}async verify(t,r=new Date,e=G){const i=this.unwrapCompressed(),s=i.packets.filterByTag(f.packet.literalData);if(s.length!==1)throw Error("Can only verify message with one literal data packet.");let a=i.packets;gt(a.stream)&&(a=a.concat(await mt(a.stream,(u=>u||[]))));const o=a.filterByTag(f.packet.onePassSignature).reverse(),c=a.filterByTag(f.packet.signature);return o.length&&!c.length&&d.isStream(a.stream)&&!gt(a.stream)?(await Promise.all(o.map((async u=>{u.correspondingSig=new Promise(((h,l)=>{u.correspondingSigResolve=h,u.correspondingSigReject=l})),u.signatureData=wr((async()=>(await u.correspondingSig).signatureData)),u.hashed=mt(await u.hash(u.signatureType,s[0],void 0,!1)),u.hashed.catch((()=>{}))}))),a.stream=Ye(a.stream,(async(u,h)=>{const l=pe(u),y=te(h);try{for(let g=0;g<o.length;g++){const{value:p}=await l.read();o[g].correspondingSigResolve(p)}await l.readToEnd(),await y.ready,await y.close()}catch(g){o.forEach((p=>{p.correspondingSigReject(g)})),await y.abort(g)}})),Ui(o,s,t,r,!1,e)):Ui(c,s,t,r,!1,e)}async verifyDetached(t,r,e=new Date,i=G){const s=this.unwrapCompressed().packets.filterByTag(f.packet.literalData);if(s.length!==1)throw Error("Can only verify message with one literal data packet.");return Ui(t.packets.filterByTag(f.packet.signature),s,r,e,!0,i)}unwrapCompressed(){const t=this.packets.filterByTag(f.packet.compressedData);return t.length?new Ot(t[0].packets):this}async appendSignature(t,r=G){await this.packets.read(d.isUint8Array(t)?t:(await Ze(t)).data,Uu,r)}write(){return this.packets.write()}armor(t=G){const r=this.packets[this.packets.length-1],e=r.constructor.tag===cn.tag?r.version!==2:this.packets.some((i=>i.constructor.tag===Bt.tag&&i.version!==6));return gn(f.armor.message,this.write(),null,null,null,e,t)}}async function Ea(n,t,r=[],e=null,i=[],s=new Date,a=[],o=[],c=[],u=!1,h=G){const l=new rt,y=n.text===null?f.signature.binary:f.signature.text;if(await Promise.all(t.map((async(g,p)=>{const A=a[p];if(!g.isPrivate())throw Error("Need private key for signing");const w=await g.getSigningKey(i[p],s,A,h);return xe(n,r.length?r:[g],w.keyPacket,{signatureType:y},s,o,c,u,h)}))).then((g=>{l.push(...g)})),e){const g=e.packets.filterByTag(f.packet.signature);l.push(...g)}return l}function Ui(n,t,r,e=new Date,i=!1,s=G){return n.filter((a=>["text","binary"].includes(f.read(f.signature,a.signatureType)))).map((a=>(function(o,c,u,h=new Date,l=!1,y=G){let g,p;for(const b of u){const v=b.getKeys(o.issuerKeyID);if(v.length>0){g=b,p=v[0];break}}const A=o instanceof ae?o.correspondingSig:o,w={keyID:o.issuerKeyID,verified:(async()=>{if(!p)throw Error("Could not find signing key with key ID "+o.issuerKeyID.toHex());await o.verify(p.keyPacket,o.signatureType,c[0],h,l,y);const b=await A;if(p.getCreationTime()>b.created)throw Error("Key is newer than the signature");try{await g.getSigningKey(p.getKeyID(),b.created,void 0,y)}catch(v){if(!y.allowInsecureVerificationWithReformattedKeys||!v.message.match(/Signature creation time is in the future/))throw v;await g.getSigningKey(p.getKeyID(),h,void 0,y)}return!0})(),signature:(async()=>{const b=await A,v=new rt;return b&&v.push(b),new Ur(v)})()};return w.signature.catch((()=>{})),w.verified.catch((()=>{})),w})(a,t,r,e,i,s)))}async function R5({armoredMessage:n,binaryMessage:t,config:r,...e}){r={...G,...r};let i=n||t;if(!i)throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");if(n&&!d.isString(n)&&!d.isStream(n))throw Error("readMessage: options.armoredMessage must be a string or stream");if(t&&!d.isUint8Array(t)&&!d.isStream(t))throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");const s=Object.keys(e);if(s.length>0)throw Error("Unknown option: "+s.join(", "));const a=d.isStream(i);if(n){const{type:u,data:h}=await Ze(i);if(u!==f.armor.message)throw Error("Armored text not of type message");i=h}const o=await rt.fromBinary(i,Ku,r,new ls),c=new Ot(o);return c.fromStream=a,c}async function T5({text:n,binary:t,filename:r,date:e=new Date,format:i=n!==void 0?"utf8":"binary",...s}){const a=n!==void 0?n:t;if(a===void 0)throw Error("createMessage: must pass options object containing `text` or `binary`");if(n&&!d.isString(n)&&!d.isStream(n))throw Error("createMessage: options.text must be a string or stream");if(t&&!d.isUint8Array(t)&&!d.isStream(t))throw Error("createMessage: options.binary must be a Uint8Array or stream");const o=Object.keys(s);if(o.length>0)throw Error("Unknown option: "+o.join(", "));const c=d.isStream(a),u=new Ar(e);n!==void 0?u.setText(a,f.write(f.literal,i)):u.setBytes(a,f.write(f.literal,i)),r!==void 0&&u.setFilename(r);const h=new rt;h.push(u);const l=new Ot(h);return l.fromStream=c,l}const Pu=d.constructAllowedPackets([Bt]);class qe{constructor(t,r){if(this.text=d.removeTrailingSpaces(t).replace(/\r?\n/g,`\r
`),r&&!(r instanceof Ur))throw Error("Invalid signature input");this.signature=r||new Ur(new rt)}getSigningKeyIDs(){const t=[];return this.signature.packets.forEach((function(r){t.push(r.issuerKeyID)})),t}async sign(t,r=[],e=null,i=[],s=new Date,a=[],o=[],c=[],u=G){const h=new Ar;h.setText(this.text);const l=new Ur(await Ea(h,t,r,e,i,s,a,o,c,!0,u));return new qe(this.text,l)}verify(t,r=new Date,e=G){const i=this.signature.packets.filterByTag(f.packet.signature),s=new Ar;return s.setText(this.text),Ui(i,[s],t,r,!0,e)}getText(){return this.text.replace(/\r\n/g,`
`)}armor(t=G){const r=this.signature.packets.some((i=>i.version!==6)),e={hash:r?Array.from(new Set(this.signature.packets.map((i=>f.read(f.hash,i.hashAlgorithm).toUpperCase())))).join():null,text:this.text,data:this.signature.packets.write()};return gn(f.armor.signed,e,void 0,void 0,void 0,r,t)}}async function F5({cleartextMessage:n,config:t,...r}){if(t={...G,...t},!n)throw Error("readCleartextMessage: must pass options object containing `cleartextMessage`");if(!d.isString(n))throw Error("readCleartextMessage: options.cleartextMessage must be a string");const e=Object.keys(r);if(e.length>0)throw Error("Unknown option: "+e.join(", "));const i=await Ze(n);if(i.type!==f.armor.signed)throw Error("No cleartext signed message.");const s=await rt.fromBinary(i.data,Pu,t);(function(o,c){const u=function(l){const y=g=>p=>g.hashAlgorithm===p;for(let g=0;g<c.length;g++)if(c[g].constructor.tag===f.packet.signature&&!l.some(y(c[g])))return!1;return!0},h=[];if(o.forEach((l=>{const y=l.match(/^Hash: (.+)$/);if(!y)throw Error('Only "Hash" header allowed in cleartext signed message');{const g=y[1].replace(/\s/g,"").split(",").map((p=>{try{return f.write(f.hash,p.toLowerCase())}catch{throw Error("Unknown hash algorithm in armor header: "+p.toLowerCase())}}));h.push(...g)}})),h.length&&!u(h))throw Error("Hash algorithm mismatch in armor header and signature")})(i.headers,s);const a=new Ur(s);return new qe(i.text,a)}async function L5({text:n,...t}){if(!n)throw Error("createCleartextMessage: must pass options object containing `text`");if(!d.isString(n))throw Error("createCleartextMessage: options.text must be a string");const r=Object.keys(t);if(r.length>0)throw Error("Unknown option: "+r.join(", "));return new qe(n)}async function N5({userIDs:n=[],passphrase:t,type:r,curve:e,rsaBits:i=4096,keyExpirationTime:s=0,date:a=new Date,subkeys:o=[{}],format:c="armored",config:u,...h}){ue(u={...G,...u}),r||e?(r=r||"ecc",e=e||"curve25519Legacy"):(r=u.v6Keys?"curve25519":"ecc",e="curve25519Legacy"),n=st(n);const l=Object.keys(h);if(l.length>0)throw Error("Unknown option: "+l.join(", "));if(n.length===0&&!u.v6Keys)throw Error("UserIDs are required for V4 keys");if(r==="rsa"&&i<u.minRSABits)throw Error(`rsaBits should be at least ${u.minRSABits}, got: ${i}`);const y={userIDs:n,passphrase:t,type:r,rsaBits:i,curve:e,keyExpirationTime:s,date:a,subkeys:o};try{const{key:g,revocationCertificate:p}=await(async function(A,w){A.sign=!0,(A=ba(A)).subkeys=A.subkeys.map(((C,D)=>ba(A.subkeys[D],A)));let b=[Iu(A,w)];b=b.concat(A.subkeys.map((C=>z1(C,w))));const v=await Promise.all(b),k=await q1(v[0],v.slice(1),A,w),m=await k.getRevocationCertificate(A.date,w);return k.revocationSignatures=[],{key:k,revocationCertificate:m}})(y,u);return g.getKeys().forEach((({keyPacket:A})=>cr(A,u))),{privateKey:yr(g,c,u),publicKey:yr(g.toPublic(),c,u),revocationCertificate:p}}catch(g){throw d.wrapError("Error generating keypair",g)}}async function O5({privateKey:n,userIDs:t=[],passphrase:r,keyExpirationTime:e=0,date:i,format:s="armored",config:a,...o}){ue(a={...G,...a}),t=st(t);const c=Object.keys(o);if(c.length>0)throw Error("Unknown option: "+c.join(", "));if(t.length===0&&n.keyPacket.version!==6)throw Error("UserIDs are required for V4 keys");const u={privateKey:n,userIDs:t,passphrase:r,keyExpirationTime:e,date:i};try{const{key:h,revocationCertificate:l}=await(async function(y,g){y=k(y);const{privateKey:p}=y;if(!p.isPrivate())throw Error("Cannot reformat a public key");if(p.keyPacket.isDummy())throw Error("Cannot reformat a gnu-dummy primary key");if(!p.getKeys().every((({keyPacket:m})=>m.isDecrypted())))throw Error("Key is not decrypted");const A=p.keyPacket;y.subkeys||(y.subkeys=await Promise.all(p.subkeys.map((async m=>{const C=m.keyPacket,D={key:A,bind:C},P=await ne(m.bindingSignatures,A,f.signature.subkeyBinding,D,null,g).catch((()=>({})));return{sign:P.keyFlags&&P.keyFlags[0]&f.keyFlags.signData}}))));const w=p.subkeys.map((m=>m.keyPacket));if(y.subkeys.length!==w.length)throw Error("Number of subkey options does not match number of subkeys");y.subkeys=y.subkeys.map((m=>k(m,y)));const b=await q1(A,w,y,g),v=await b.getRevocationCertificate(y.date,g);return b.revocationSignatures=[],{key:b,revocationCertificate:v};function k(m,C={}){return m.keyExpirationTime=m.keyExpirationTime||C.keyExpirationTime,m.passphrase=d.isString(m.passphrase)?m.passphrase:C.passphrase,m.date=m.date||C.date,m}})(u,a);return{privateKey:yr(h,s,a),publicKey:yr(h.toPublic(),s,a),revocationCertificate:l}}catch(h){throw d.wrapError("Error reformatting keypair",h)}}async function H5({key:n,revocationCertificate:t,reasonForRevocation:r,date:e=new Date,format:i="armored",config:s,...a}){ue(s={...G,...s});const o=Object.keys(a);if(o.length>0)throw Error("Unknown option: "+o.join(", "));try{const c=t?await n.applyRevocationCertificate(t,e,s):await n.revoke(r,e,s);return c.isPrivate()?{privateKey:yr(c,i,s),publicKey:yr(c.toPublic(),i,s)}:{privateKey:null,publicKey:yr(c,i,s)}}catch(c){throw d.wrapError("Error revoking key",c)}}async function z5({privateKey:n,passphrase:t,config:r,...e}){ue(r={...G,...r});const i=Object.keys(e);if(i.length>0)throw Error("Unknown option: "+i.join(", "));if(!n.isPrivate())throw Error("Cannot decrypt a public key");const s=n.clone(!0),a=d.isArray(t)?t:[t];try{return await Promise.all(s.getKeys().map((o=>d.anyPromise(a.map((c=>o.keyPacket.decrypt(c))))))),await s.validate(r),s}catch(o){throw s.clearPrivateParams(),d.wrapError("Error decrypting private key",o)}}async function G5({privateKey:n,passphrase:t,config:r,...e}){ue(r={...G,...r});const i=Object.keys(e);if(i.length>0)throw Error("Unknown option: "+i.join(", "));if(!n.isPrivate())throw Error("Cannot encrypt a public key");const s=n.clone(!0),a=s.getKeys(),o=d.isArray(t)?t:Array(a.length).fill(t);if(o.length!==a.length)throw Error("Invalid number of passphrases given for key encryption");try{return await Promise.all(a.map((async(c,u)=>{const{keyPacket:h}=c;await h.encrypt(o[u],r),h.clearPrivateParams()}))),s}catch(c){throw s.clearPrivateParams(),d.wrapError("Error encrypting private key",c)}}async function j5({message:n,encryptionKeys:t,signingKeys:r,passwords:e,sessionKey:i,format:s="armored",signature:a=null,wildcard:o=!1,signingKeyIDs:c=[],encryptionKeyIDs:u=[],date:h=new Date,signingUserIDs:l=[],encryptionUserIDs:y=[],signatureNotations:g=[],config:p,...A}){if(ue(p={...G,...p}),Xa(n),Wa(s),t=st(t),r=st(r),e=st(e),c=st(c),u=st(u),l=st(l),y=st(y),g=st(g),A.detached)throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");if(A.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");if(A.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");if(A.armor!==void 0)throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");const w=Object.keys(A);if(w.length>0)throw Error("Unknown option: "+w.join(", "));r||(r=[]);try{if((r.length||a)&&(n=await n.sign(r,t,a,c,h,l,u,g,p)),n=n.compress(await(async function(v=[],k=new Date,m=[],C=G){const D=f.compression.uncompressed,P=C.preferredCompressionAlgorithm;return(await Promise.all(v.map((async function(E,K){const I=(await E.getPrimarySelfSignature(k,m[K],C)).preferredCompressionAlgorithms;return!!I&&I.indexOf(P)>=0})))).every(Boolean)?P:D})(t,h,y,p),p),n=await n.encrypt(t,e,i,o,u,h,y,p),s==="object")return n;const b=s==="armored"?n.armor(p):n.write();return await ds(b)}catch(b){throw d.wrapError("Error encrypting message",b)}}async function V5({message:n,decryptionKeys:t,passwords:r,sessionKeys:e,verificationKeys:i,expectSigned:s=!1,format:a="utf8",signature:o=null,date:c=new Date,config:u,...h}){if(ue(u={...G,...u}),Xa(n),i=st(i),t=st(t),r=st(r),e=st(e),h.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");if(h.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");const l=Object.keys(h);if(l.length>0)throw Error("Unknown option: "+l.join(", "));try{const y=await n.decrypt(t,r,e,c,u);i||(i=[]);const g={};if(g.signatures=o?await y.verifyDetached(o,i,c,u):await y.verify(i,c,u),g.data=a==="binary"?y.getLiteralData():y.getText(),g.filename=y.getFilename(),Z1(g,n,...new Set([y,y.unwrapCompressed()])),s){if(i.length===0)throw Error("Verification keys are required to verify message signatures");if(g.signatures.length===0)throw Error("Message is not signed");g.data=Ft([g.data,wr((async()=>(await d.anyPromise(g.signatures.map((p=>p.verified))),a==="binary"?new Uint8Array:"")))])}return g.data=await ds(g.data),g}catch(y){throw d.wrapError("Error decrypting message",y)}}async function q5({message:n,signingKeys:t,recipientKeys:r=[],format:e="armored",detached:i=!1,signingKeyIDs:s=[],date:a=new Date,signingUserIDs:o=[],recipientUserIDs:c=[],signatureNotations:u=[],config:h,...l}){if(ue(h={...G,...h}),Y1(n),Wa(e),t=st(t),s=st(s),o=st(o),r=st(r),c=st(c),u=st(u),l.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.sign, pass `signingKeys` instead");if(l.armor!==void 0)throw Error("The `armor` option has been removed from openpgp.sign, pass `format` instead.");const y=Object.keys(l);if(y.length>0)throw Error("Unknown option: "+y.join(", "));if(n instanceof qe&&e==="binary")throw Error("Cannot return signed cleartext message in binary format");if(n instanceof qe&&i)throw Error("Cannot detach-sign a cleartext message");if(!t||t.length===0)throw Error("No signing keys provided");try{let g;return g=i?await n.signDetached(t,r,void 0,s,a,o,c,u,h):await n.sign(t,r,void 0,s,a,o,c,u,h),e==="object"?g:(g=e==="armored"?g.armor(h):g.write(),i&&(g=Ye(n.packets.write(),(async(p,A)=>{await Promise.all([xr(g,A),mt(p).catch((()=>{}))])}))),await ds(g))}catch(g){throw d.wrapError("Error signing message",g)}}async function Y5({message:n,verificationKeys:t,expectSigned:r=!1,format:e="utf8",signature:i=null,date:s=new Date,config:a,...o}){if(ue(a={...G,...a}),Y1(n),t=st(t),o.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.verify, pass `verificationKeys` instead");const c=Object.keys(o);if(c.length>0)throw Error("Unknown option: "+c.join(", "));if(n instanceof qe&&e==="binary")throw Error("Can't return cleartext message data as binary");if(n instanceof qe&&i)throw Error("Can't verify detached cleartext signature");try{const u={};if(u.signatures=i?await n.verifyDetached(i,t,s,a):await n.verify(t,s,a),u.data=e==="binary"?n.getLiteralData():n.getText(),n.fromStream&&!i&&Z1(u,...new Set([n,n.unwrapCompressed()])),r){if(u.signatures.length===0)throw Error("Message is not signed");u.data=Ft([u.data,wr((async()=>(await d.anyPromise(u.signatures.map((h=>h.verified))),e==="binary"?new Uint8Array:"")))])}return u.data=await ds(u.data),u}catch(u){throw d.wrapError("Error verifying signed message",u)}}async function Z5({encryptionKeys:n,date:t=new Date,encryptionUserIDs:r=[],config:e,...i}){if(ue(e={...G,...e}),n=st(n),r=st(r),i.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.generateSessionKey, pass `encryptionKeys` instead");const s=Object.keys(i);if(s.length>0)throw Error("Unknown option: "+s.join(", "));try{return await Ot.generateSessionKey(n,t,r,e)}catch(a){throw d.wrapError("Error generating session key",a)}}async function J5({data:n,algorithm:t,aeadAlgorithm:r,encryptionKeys:e,passwords:i,format:s="armored",wildcard:a=!1,encryptionKeyIDs:o=[],date:c=new Date,encryptionUserIDs:u=[],config:h,...l}){if(ue(h={...G,...h}),(function(g){if(!d.isUint8Array(g))throw Error("Parameter [data] must be of type Uint8Array")})(n),(function(g,p){if(!d.isString(g))throw Error("Parameter ["+p+"] must be of type String")})(t,"algorithm"),Wa(s),e=st(e),i=st(i),o=st(o),u=st(u),l.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.encryptSessionKey, pass `encryptionKeys` instead");const y=Object.keys(l);if(y.length>0)throw Error("Unknown option: "+y.join(", "));if(!(e&&e.length!==0||i&&i.length!==0))throw Error("No encryption keys or passwords provided.");try{return yr(await Ot.encryptSessionKey(n,t,r,e,i,a,o,c,u,h),s,h)}catch(g){throw d.wrapError("Error encrypting session key",g)}}async function X5({message:n,decryptionKeys:t,passwords:r,date:e=new Date,config:i,...s}){if(ue(i={...G,...i}),Xa(n),t=st(t),r=st(r),s.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.decryptSessionKeys, pass `decryptionKeys` instead");const a=Object.keys(s);if(a.length>0)throw Error("Unknown option: "+a.join(", "));try{return await n.decryptSessionKeys(t,r,void 0,e,i)}catch(o){throw d.wrapError("Error decrypting session keys",o)}}function Xa(n){if(!(n instanceof Ot))throw Error("Parameter [message] needs to be of type Message")}function Y1(n){if(!(n instanceof qe||n instanceof Ot))throw Error("Parameter [message] needs to be of type Message or CleartextMessage")}function Wa(n){if(n!=="armored"&&n!=="binary"&&n!=="object")throw Error("Unsupported format "+n)}const Du=Object.keys(G).length;function ue(n){const t=Object.keys(n);if(t.length!==Du){for(const r of t)if(G[r]===void 0)throw Error("Unknown config property: "+r)}}function st(n){return n&&!d.isArray(n)&&(n=[n]),n}async function ds(n){return d.isStream(n)==="array"?mt(n):n}function Z1(n,t,...r){n.data=Ye(t.packets.stream,(async(e,i)=>{await xr(n.data,i,{preventClose:!0});const s=te(i);try{await mt(e,(a=>a)),await Promise.all(r.map((a=>mt(a.packets.stream,(o=>o))))),await s.close()}catch(a){await s.abort(a)}}))}function yr(n,t,r){switch(t){case"object":return n;case"armored":return n.armor(r);case"binary":return n.write();default:throw Error("Unsupported format "+t)}}const zr=typeof Lt=="object"&&"crypto"in Lt?Lt.crypto:void 0;function ei(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function Zn(n){if(!Number.isSafeInteger(n)||n<0)throw Error("positive integer expected, got "+n)}function Me(n,...t){if(!ei(n))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw Error("Uint8Array expected of length "+t+", got length="+n.length)}function J1(n){if(typeof n!="function"||typeof n.create!="function")throw Error("Hash should be wrapped by utils.createHasher");Zn(n.outputLen),Zn(n.blockLen)}function ln(n,t=!0){if(n.destroyed)throw Error("Hash instance has been destroyed");if(t&&n.finished)throw Error("Hash#digest() has already been called")}function X1(n,t){Me(n);const r=t.outputLen;if(n.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}function ce(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function Rs(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Ae(n,t){return n<<32-t|n>>>t}function hr(n,t){return n<<t|n>>>32-t>>>0}const qo=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68?n=>n:function(n){for(let r=0;r<n.length;r++)n[r]=(t=n[r])<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;var t;return n},W1=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",xu=Array.from({length:256},((n,t)=>t.toString(16).padStart(2,"0")));function Dr(n){if(Me(n),W1)return n.toHex();let t="";for(let r=0;r<n.length;r++)t+=xu[n[r]];return t}const Yo=48,Qu=57,Zo=65,Mu=70,Jo=97,Ru=102;function Xo(n){return n>=Yo&&n<=Qu?n-Yo:n>=Zo&&n<=Mu?n-(Zo-10):n>=Jo&&n<=Ru?n-(Jo-10):void 0}function qi(n){if(typeof n!="string")throw Error("hex string expected, got "+typeof n);if(W1)return Uint8Array.fromHex(n);const t=n.length,r=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const e=new Uint8Array(r);for(let i=0,s=0;i<r;i++,s+=2){const a=Xo(n.charCodeAt(s)),o=Xo(n.charCodeAt(s+1));if(a===void 0||o===void 0){const c=n[s]+n[s+1];throw Error('hex string expected, got non-hex character "'+c+'" at index '+s)}e[i]=16*a+o}return e}function ri(n){return typeof n=="string"&&(n=(function(t){if(typeof t!="string")throw Error("string expected");return new Uint8Array(new TextEncoder().encode(t))})(n)),Me(n),n}function le(...n){let t=0;for(let e=0;e<n.length;e++){const i=n[e];Me(i),t+=i.length}const r=new Uint8Array(t);for(let e=0,i=0;e<n.length;e++){const s=n[e];r.set(s,i),i+=s.length}return r}class _a{}function We(n){const t=e=>n().update(ri(e)).digest(),r=n();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>n(),t}const Tu=We;function As(n=32){if(zr&&typeof zr.getRandomValues=="function")return zr.getRandomValues(new Uint8Array(n));if(zr&&typeof zr.randomBytes=="function")return Uint8Array.from(zr.randomBytes(n));throw Error("crypto.getRandomValues must be defined")}const $a=BigInt(0),va=BigInt(1);function Tr(n,t=""){if(typeof n!="boolean")throw Error((t&&`"${t}"`)+"expected boolean, got type="+typeof n);return n}function ge(n,t,r=""){const e=ei(n),i=n?.length,s=t!==void 0;if(!e||s&&i!==t)throw Error((r&&`"${r}" `)+"expected Uint8Array"+(s?" of length "+t:"")+", got "+(e?"length="+i:"type="+typeof n));return n}function hi(n){const t=n.toString(16);return 1&t.length?"0"+t:t}function _1(n){if(typeof n!="string")throw Error("hex string expected, got "+typeof n);return n===""?$a:BigInt("0x"+n)}function ws(n){return _1(Dr(n))}function Fr(n){return Me(n),_1(Dr(Uint8Array.from(n).reverse()))}function to(n,t){return qi(n.toString(16).padStart(2*t,"0"))}function eo(n,t){return to(n,t).reverse()}function lt(n,t,r){let e;if(typeof t=="string")try{e=qi(t)}catch(s){throw Error(n+" must be hex string or Uint8Array, cause: "+s)}else{if(!ei(t))throw Error(n+" must be hex string or Uint8Array");e=Uint8Array.from(t)}const i=e.length;if(typeof r=="number"&&i!==r)throw Error(n+" of length "+r+" expected, got "+i);return e}function Wo(n){return Uint8Array.from(n)}const Ts=n=>typeof n=="bigint"&&$a<=n;function Jn(n,t,r,e){if(!(function(i,s,a){return Ts(i)&&Ts(s)&&Ts(a)&&s<=i&&i<a})(t,r,e))throw Error("expected valid "+n+": "+r+" <= n < "+e+", got "+t)}function $1(n){let t;for(t=0;n>$a;n>>=va,t+=1);return t}const ni=n=>(va<<BigInt(n))-va;function dn(n,t,r={}){if(!n||typeof n!="object")throw Error("expected valid options object");function e(i,s,a){const o=n[i];if(a&&o===void 0)return;const c=typeof o;if(c!==s||o===null)throw Error(`param "${i}" is invalid: expected ${s}, got ${c}`)}Object.entries(t).forEach((([i,s])=>e(i,s,!1))),Object.entries(r).forEach((([i,s])=>e(i,s,!0)))}function Yi(n){const t=new WeakMap;return(r,...e)=>{const i=t.get(r);if(i!==void 0)return i;const s=n(r,...e);return t.set(r,s),s}}const Vt=BigInt(0),Ht=BigInt(1),Sr=BigInt(2),t0=BigInt(3),e0=BigInt(4),r0=BigInt(5),Fu=BigInt(7),n0=BigInt(8),Lu=BigInt(9),_o=BigInt(16);function St(n,t){const r=n%t;return r>=Vt?r:t+r}function ft(n,t,r){let e=n;for(;t-- >Vt;)e*=e,e%=r;return e}function $o(n,t){if(n===Vt)throw Error("invert: expected non-zero number");if(t<=Vt)throw Error("invert: expected positive modulus, got "+t);let r=St(n,t),e=t,i=Vt,s=Ht;for(;r!==Vt;){const a=e%r,o=i-s*(e/r);e=r,r=a,i=s,s=o}if(e!==Ht)throw Error("invert: does not exist");return St(i,t)}function ro(n,t,r){if(!n.eql(n.sqr(t),r))throw Error("Cannot find square root")}function i0(n,t){const r=(n.ORDER+Ht)/e0,e=n.pow(t,r);return ro(n,e,t),e}function Nu(n,t){const r=(n.ORDER-r0)/n0,e=n.mul(t,Sr),i=n.pow(e,r),s=n.mul(t,i),a=n.mul(n.mul(s,Sr),i),o=n.mul(s,n.sub(a,n.ONE));return ro(n,o,t),o}function tc(n){if(n<t0)throw Error("sqrt is not defined for small field");let t=n-Ht,r=0;for(;t%Sr===Vt;)t/=Sr,r++;let e=Sr;const i=Xt(n);for(;ec(i,e)===1;)if(e++>1e3)throw Error("Cannot find square root: probably non-prime P");if(r===1)return i0;let s=i.pow(e,t);const a=(t+Ht)/Sr;return function(o,c){if(o.is0(c))return c;if(ec(o,c)!==1)throw Error("Cannot find square root");let u=r,h=o.mul(o.ONE,s),l=o.pow(c,t),y=o.pow(c,a);for(;!o.eql(l,o.ONE);){if(o.is0(l))return o.ZERO;let g=1,p=o.sqr(l);for(;!o.eql(p,o.ONE);)if(g++,p=o.sqr(p),g===u)throw Error("Cannot find square root");const A=Ht<<BigInt(u-g-1),w=o.pow(h,A);u=g,h=o.sqr(w),l=o.mul(l,h),y=o.mul(y,w)}return y}}function Ou(n){return n%e0===t0?i0:n%n0===r0?Nu:n%_o===Lu?(function(t){const r=Xt(t),e=tc(t),i=e(r,r.neg(r.ONE)),s=e(r,i),a=e(r,r.neg(i)),o=(t+Fu)/_o;return(c,u)=>{let h=c.pow(u,o),l=c.mul(h,i);const y=c.mul(h,s),g=c.mul(h,a),p=c.eql(c.sqr(l),u),A=c.eql(c.sqr(y),u);h=c.cmov(h,l,p),l=c.cmov(g,y,A);const w=c.eql(c.sqr(l),u),b=c.cmov(h,l,w);return ro(c,b,u),b}})(n):tc(n)}const Hu=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function s0(n,t,r=!1){const e=Array(t.length).fill(r?n.ZERO:void 0),i=t.reduce(((a,o,c)=>n.is0(o)?a:(e[c]=a,n.mul(a,o))),n.ONE),s=n.inv(i);return t.reduceRight(((a,o,c)=>n.is0(o)?a:(e[c]=n.mul(a,e[c]),n.mul(a,o))),s),e}function ec(n,t){const r=(n.ORDER-Ht)/Sr,e=n.pow(t,r),i=n.eql(e,n.ONE),s=n.eql(e,n.ZERO),a=n.eql(e,n.neg(n.ONE));if(!i&&!s&&!a)throw Error("invalid Legendre symbol result");return i?1:s?0:-1}function a0(n,t){t!==void 0&&Zn(t);const r=t!==void 0?t:n.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Xt(n,t,r=!1,e={}){if(n<=Vt)throw Error("invalid field: expected ORDER > 0, got "+n);let i,s,a,o=!1;if(typeof t=="object"&&t!=null){if(e.sqrt||r)throw Error("cannot specify opts in two arguments");const y=t;y.BITS&&(i=y.BITS),y.sqrt&&(s=y.sqrt),typeof y.isLE=="boolean"&&(r=y.isLE),typeof y.modFromBytes=="boolean"&&(o=y.modFromBytes),a=y.allowedLengths}else typeof t=="number"&&(i=t),e.sqrt&&(s=e.sqrt);const{nBitLength:c,nByteLength:u}=a0(n,i);if(u>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let h;const l=Object.freeze({ORDER:n,isLE:r,BITS:c,BYTES:u,MASK:ni(c),ZERO:Vt,ONE:Ht,allowedLengths:a,create:y=>St(y,n),isValid:y=>{if(typeof y!="bigint")throw Error("invalid field element: expected bigint, got "+typeof y);return Vt<=y&&y<n},is0:y=>y===Vt,isValidNot0:y=>!l.is0(y)&&l.isValid(y),isOdd:y=>(y&Ht)===Ht,neg:y=>St(-y,n),eql:(y,g)=>y===g,sqr:y=>St(y*y,n),add:(y,g)=>St(y+g,n),sub:(y,g)=>St(y-g,n),mul:(y,g)=>St(y*g,n),pow:(y,g)=>(function(p,A,w){if(w<Vt)throw Error("invalid exponent, negatives unsupported");if(w===Vt)return p.ONE;if(w===Ht)return A;let b=p.ONE,v=A;for(;w>Vt;)w&Ht&&(b=p.mul(b,v)),v=p.sqr(v),w>>=Ht;return b})(l,y,g),div:(y,g)=>St(y*$o(g,n),n),sqrN:y=>y*y,addN:(y,g)=>y+g,subN:(y,g)=>y-g,mulN:(y,g)=>y*g,inv:y=>$o(y,n),sqrt:s||(y=>(h||(h=Ou(n)),h(l,y))),toBytes:y=>r?eo(y,u):to(y,u),fromBytes:(y,g=!0)=>{if(a){if(!a.includes(y.length)||y.length>u)throw Error("Field.fromBytes: expected "+a+" bytes, got "+y.length);const A=new Uint8Array(u);A.set(y,r?0:A.length-y.length),y=A}if(y.length!==u)throw Error("Field.fromBytes: expected "+u+" bytes, got "+y.length);let p=r?Fr(y):ws(y);if(o&&(p=St(p,n)),!g&&!l.isValid(p))throw Error("invalid field element: outside of range 0..ORDER");return p},invertBatch:y=>s0(l,y),cmov:(y,g,p)=>p?g:y});return Object.freeze(l)}function o0(n){if(typeof n!="bigint")throw Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function rc(n){const t=o0(n);return t+Math.ceil(t/2)}function c0(n,t,r){return n&t^~n&r}function u0(n,t,r){return n&t^n&r^t&r}class ii extends _a{constructor(t,r,e,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=r,this.padOffset=e,this.isLE=i,this.buffer=new Uint8Array(t),this.view=Rs(this.buffer)}update(t){ln(this),Me(t=ri(t));const{view:r,buffer:e,blockLen:i}=this,s=t.length;for(let a=0;a<s;){const o=Math.min(i-this.pos,s-a);if(o!==i)e.set(t.subarray(a,a+o),this.pos),this.pos+=o,a+=o,this.pos===i&&(this.process(r,0),this.pos=0);else{const c=Rs(t);for(;i<=s-a;a+=i)this.process(c,a)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){ln(this),X1(t,this),this.finished=!0;const{buffer:r,view:e,blockLen:i,isLE:s}=this;let{pos:a}=this;r[a++]=128,ce(this.buffer.subarray(a)),this.padOffset>i-a&&(this.process(e,0),a=0);for(let l=a;l<i;l++)r[l]=0;(function(l,y,g,p){if(typeof l.setBigUint64=="function")return l.setBigUint64(y,g,p);const A=BigInt(32),w=BigInt(4294967295),b=Number(g>>A&w),v=Number(g&w),k=p?4:0,m=p?0:4;l.setUint32(y+k,b,p),l.setUint32(y+m,v,p)})(e,i-8,BigInt(8*this.length),s),this.process(e,0);const o=Rs(t),c=this.outputLen;if(c%4)throw Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,h=this.get();if(u>h.length)throw Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)o.setUint32(4*l,h[l],s)}digest(){const{buffer:t,outputLen:r}=this;this.digestInto(t);const e=t.slice(0,r);return this.destroy(),e}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:r,buffer:e,length:i,finished:s,destroyed:a,pos:o}=this;return t.destroyed=a,t.finished=s,t.length=i,t.pos=o,i%r&&t.buffer.set(e),t}clone(){return this._cloneInto()}}const _e=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),$e=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),Mt=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),Rt=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),fi=BigInt(2**32-1),nc=BigInt(32);function zu(n,t=!1){return t?{h:Number(n&fi),l:Number(n>>nc&fi)}:{h:0|Number(n>>nc&fi),l:0|Number(n&fi)}}function h0(n,t=!1){const r=n.length;let e=new Uint32Array(r),i=new Uint32Array(r);for(let s=0;s<r;s++){const{h:a,l:o}=zu(n[s],t);[e[s],i[s]]=[a,o]}return[e,i]}const ic=(n,t,r)=>n>>>r,sc=(n,t,r)=>n<<32-r|t>>>r,Gr=(n,t,r)=>n>>>r|t<<32-r,jr=(n,t,r)=>n<<32-r|t>>>r,li=(n,t,r)=>n<<64-r|t>>>r-32,yi=(n,t,r)=>n>>>r-32|t<<64-r;function Fe(n,t,r,e){const i=(t>>>0)+(e>>>0);return{h:n+r+(i/2**32|0)|0,l:0|i}}const Gu=(n,t,r)=>(n>>>0)+(t>>>0)+(r>>>0),ju=(n,t,r,e)=>t+r+e+(n/2**32|0)|0,Vu=(n,t,r,e)=>(n>>>0)+(t>>>0)+(r>>>0)+(e>>>0),qu=(n,t,r,e,i)=>t+r+e+i+(n/2**32|0)|0,Yu=(n,t,r,e,i)=>(n>>>0)+(t>>>0)+(r>>>0)+(e>>>0)+(i>>>0),Zu=(n,t,r,e,i,s)=>t+r+e+i+s+(n/2**32|0)|0,Ju=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tr=new Uint32Array(64);class f0 extends ii{constructor(t=32){super(64,t,8,!1),this.A=0|_e[0],this.B=0|_e[1],this.C=0|_e[2],this.D=0|_e[3],this.E=0|_e[4],this.F=0|_e[5],this.G=0|_e[6],this.H=0|_e[7]}get(){const{A:t,B:r,C:e,D:i,E:s,F:a,G:o,H:c}=this;return[t,r,e,i,s,a,o,c]}set(t,r,e,i,s,a,o,c){this.A=0|t,this.B=0|r,this.C=0|e,this.D=0|i,this.E=0|s,this.F=0|a,this.G=0|o,this.H=0|c}process(t,r){for(let l=0;l<16;l++,r+=4)tr[l]=t.getUint32(r,!1);for(let l=16;l<64;l++){const y=tr[l-15],g=tr[l-2],p=Ae(y,7)^Ae(y,18)^y>>>3,A=Ae(g,17)^Ae(g,19)^g>>>10;tr[l]=A+tr[l-7]+p+tr[l-16]|0}let{A:e,B:i,C:s,D:a,E:o,F:c,G:u,H:h}=this;for(let l=0;l<64;l++){const y=h+(Ae(o,6)^Ae(o,11)^Ae(o,25))+c0(o,c,u)+Ju[l]+tr[l]|0,g=(Ae(e,2)^Ae(e,13)^Ae(e,22))+u0(e,i,s)|0;h=u,u=c,c=o,o=a+y|0,a=s,s=i,i=e,e=y+g|0}e=e+this.A|0,i=i+this.B|0,s=s+this.C|0,a=a+this.D|0,o=o+this.E|0,c=c+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(e,i,s,a,o,c,u,h)}roundClean(){ce(tr)}destroy(){this.set(0,0,0,0,0,0,0,0),ce(this.buffer)}}class Xu extends f0{constructor(){super(28),this.A=0|$e[0],this.B=0|$e[1],this.C=0|$e[2],this.D=0|$e[3],this.E=0|$e[4],this.F=0|$e[5],this.G=0|$e[6],this.H=0|$e[7]}}const l0=h0(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((n=>BigInt(n)))),Wu=l0[0],_u=l0[1],er=new Uint32Array(80),rr=new Uint32Array(80);class y0 extends ii{constructor(t=64){super(128,t,16,!1),this.Ah=0|Rt[0],this.Al=0|Rt[1],this.Bh=0|Rt[2],this.Bl=0|Rt[3],this.Ch=0|Rt[4],this.Cl=0|Rt[5],this.Dh=0|Rt[6],this.Dl=0|Rt[7],this.Eh=0|Rt[8],this.El=0|Rt[9],this.Fh=0|Rt[10],this.Fl=0|Rt[11],this.Gh=0|Rt[12],this.Gl=0|Rt[13],this.Hh=0|Rt[14],this.Hl=0|Rt[15]}get(){const{Ah:t,Al:r,Bh:e,Bl:i,Ch:s,Cl:a,Dh:o,Dl:c,Eh:u,El:h,Fh:l,Fl:y,Gh:g,Gl:p,Hh:A,Hl:w}=this;return[t,r,e,i,s,a,o,c,u,h,l,y,g,p,A,w]}set(t,r,e,i,s,a,o,c,u,h,l,y,g,p,A,w){this.Ah=0|t,this.Al=0|r,this.Bh=0|e,this.Bl=0|i,this.Ch=0|s,this.Cl=0|a,this.Dh=0|o,this.Dl=0|c,this.Eh=0|u,this.El=0|h,this.Fh=0|l,this.Fl=0|y,this.Gh=0|g,this.Gl=0|p,this.Hh=0|A,this.Hl=0|w}process(t,r){for(let k=0;k<16;k++,r+=4)er[k]=t.getUint32(r),rr[k]=t.getUint32(r+=4);for(let k=16;k<80;k++){const m=0|er[k-15],C=0|rr[k-15],D=Gr(m,C,1)^Gr(m,C,8)^ic(m,0,7),P=jr(m,C,1)^jr(m,C,8)^sc(m,C,7),S=0|er[k-2],E=0|rr[k-2],K=Gr(S,E,19)^li(S,E,61)^ic(S,0,6),I=jr(S,E,19)^yi(S,E,61)^sc(S,E,6),B=Vu(P,I,rr[k-7],rr[k-16]),U=qu(B,D,K,er[k-7],er[k-16]);er[k]=0|U,rr[k]=0|B}let{Ah:e,Al:i,Bh:s,Bl:a,Ch:o,Cl:c,Dh:u,Dl:h,Eh:l,El:y,Fh:g,Fl:p,Gh:A,Gl:w,Hh:b,Hl:v}=this;for(let k=0;k<80;k++){const m=Gr(l,y,14)^Gr(l,y,18)^li(l,y,41),C=jr(l,y,14)^jr(l,y,18)^yi(l,y,41),D=l&g^~l&A,P=Yu(v,C,y&p^~y&w,_u[k],rr[k]),S=Zu(P,b,m,D,Wu[k],er[k]),E=0|P,K=Gr(e,i,28)^li(e,i,34)^li(e,i,39),I=jr(e,i,28)^yi(e,i,34)^yi(e,i,39),B=e&s^e&o^s&o,U=i&a^i&c^a&c;b=0|A,v=0|w,A=0|g,w=0|p,g=0|l,p=0|y,{h:l,l:y}=Fe(0|u,0|h,0|S,0|E),u=0|o,h=0|c,o=0|s,c=0|a,s=0|e,a=0|i;const x=Gu(E,I,U);e=ju(x,S,K,B),i=0|x}({h:e,l:i}=Fe(0|this.Ah,0|this.Al,0|e,0|i)),{h:s,l:a}=Fe(0|this.Bh,0|this.Bl,0|s,0|a),{h:o,l:c}=Fe(0|this.Ch,0|this.Cl,0|o,0|c),{h:u,l:h}=Fe(0|this.Dh,0|this.Dl,0|u,0|h),{h:l,l:y}=Fe(0|this.Eh,0|this.El,0|l,0|y),{h:g,l:p}=Fe(0|this.Fh,0|this.Fl,0|g,0|p),{h:A,l:w}=Fe(0|this.Gh,0|this.Gl,0|A,0|w),{h:b,l:v}=Fe(0|this.Hh,0|this.Hl,0|b,0|v),this.set(e,i,s,a,o,c,u,h,l,y,g,p,A,w,b,v)}roundClean(){ce(er,rr)}destroy(){ce(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class $u extends y0{constructor(){super(48),this.Ah=0|Mt[0],this.Al=0|Mt[1],this.Bh=0|Mt[2],this.Bl=0|Mt[3],this.Ch=0|Mt[4],this.Cl=0|Mt[5],this.Dh=0|Mt[6],this.Dl=0|Mt[7],this.Eh=0|Mt[8],this.El=0|Mt[9],this.Fh=0|Mt[10],this.Fl=0|Mt[11],this.Gh=0|Mt[12],this.Gl=0|Mt[13],this.Hh=0|Mt[14],this.Hl=0|Mt[15]}}const no=We((()=>new f0)),th=We((()=>new Xu)),g0=We((()=>new y0)),p0=We((()=>new $u));class d0 extends _a{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,J1(t);const e=ri(r);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(e.length>i?t.create().update(e).digest():e);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=t.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),ce(s)}update(t){return ln(this),this.iHash.update(t),this}digestInto(t){ln(this),Me(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:e,finished:i,destroyed:s,blockLen:a,outputLen:o}=this;return t.finished=i,t.destroyed=s,t.blockLen=a,t.outputLen=o,t.oHash=r._cloneInto(t.oHash),t.iHash=e._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const A0=(n,t,r)=>new d0(n,t).update(r).digest();A0.create=(n,t)=>new d0(n,t);const yn=BigInt(0),Br=BigInt(1);function Zi(n,t){const r=t.negate();return n?r:t}function Kr(n,t){const r=s0(n.Fp,t.map((e=>e.Z)));return t.map(((e,i)=>n.fromAffine(e.toAffine(r[i]))))}function w0(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw Error("invalid window size, expected [1.."+t+"], got W="+n)}function Fs(n,t){w0(n,t);const r=2**n;return{windows:Math.ceil(t/n)+1,windowSize:2**(n-1),mask:ni(n),maxNumber:r,shiftBy:BigInt(n)}}function ac(n,t,r){const{windowSize:e,mask:i,maxNumber:s,shiftBy:a}=r;let o=Number(n&i),c=n>>a;o>e&&(o-=s,c+=Br);const u=t*e;return{nextN:c,offset:u+Math.abs(o)-1,isZero:o===0,isNeg:o<0,isNegF:t%2!=0,offsetF:u}}const Ls=new WeakMap,m0=new WeakMap;function Ns(n){return m0.get(n)||1}function oc(n){if(n!==yn)throw Error("invalid wNAF")}class b0{constructor(t,r){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=r}_unsafeLadder(t,r,e=this.ZERO){let i=t;for(;r>yn;)r&Br&&(e=e.add(i)),i=i.double(),r>>=Br;return e}precomputeWindow(t,r){const{windows:e,windowSize:i}=Fs(r,this.bits),s=[];let a=t,o=a;for(let c=0;c<e;c++){o=a,s.push(o);for(let u=1;u<i;u++)o=o.add(a),s.push(o);a=o.double()}return s}wNAF(t,r,e){if(!this.Fn.isValid(e))throw Error("invalid scalar");let i=this.ZERO,s=this.BASE;const a=Fs(t,this.bits);for(let o=0;o<a.windows;o++){const{nextN:c,offset:u,isZero:h,isNeg:l,isNegF:y,offsetF:g}=ac(e,o,a);e=c,h?s=s.add(Zi(y,r[g])):i=i.add(Zi(l,r[u]))}return oc(e),{p:i,f:s}}wNAFUnsafe(t,r,e,i=this.ZERO){const s=Fs(t,this.bits);for(let a=0;a<s.windows&&e!==yn;a++){const{nextN:o,offset:c,isZero:u,isNeg:h}=ac(e,a,s);if(e=o,!u){const l=r[c];i=i.add(h?l.negate():l)}}return oc(e),i}getPrecomputes(t,r,e){let i=Ls.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&(typeof e=="function"&&(i=e(i)),Ls.set(r,i))),i}cached(t,r,e){const i=Ns(t);return this.wNAF(i,this.getPrecomputes(i,t,e),r)}unsafe(t,r,e,i){const s=Ns(t);return s===1?this._unsafeLadder(t,r,i):this.wNAFUnsafe(s,this.getPrecomputes(s,t,e),r,i)}createCache(t,r){w0(r,this.bits),m0.set(t,r),Ls.delete(t)}hasCache(t){return Ns(t)!==1}}function k0(n,t,r,e){(function(y,g){if(!Array.isArray(y))throw Error("array expected");y.forEach(((p,A)=>{if(!(p instanceof g))throw Error("invalid point at index "+A)}))})(r,n),(function(y,g){if(!Array.isArray(y))throw Error("array of scalars expected");y.forEach(((p,A)=>{if(!g.isValid(p))throw Error("invalid scalar at index "+A)}))})(e,t);const i=r.length,s=e.length;if(i!==s)throw Error("arrays of points and scalars must have equal length");const a=n.ZERO,o=$1(BigInt(i));let c=1;o>12?c=o-3:o>4?c=o-2:o>0&&(c=2);const u=ni(c),h=Array(Number(u)+1).fill(a);let l=a;for(let y=Math.floor((t.BITS-1)/c)*c;y>=0;y-=c){h.fill(a);for(let p=0;p<s;p++){const A=e[p],w=Number(A>>BigInt(y)&u);h[w]=h[w].add(r[p])}let g=a;for(let p=h.length-1,A=a;p>0;p--)A=A.add(h[p]),g=g.add(A);if(l=l.add(g),y!==0)for(let p=0;p<c;p++)l=l.double()}return l}function cc(n,t,r){if(t){if(t.ORDER!==n)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return(function(e){dn(e,Hu.reduce(((i,s)=>(i[s]="function",i)),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))})(t),t}return Xt(n,{isLE:r})}function E0(n,t,r={},e){if(e===void 0&&(e=n==="edwards"),!t||typeof t!="object")throw Error(`expected valid ${n} CURVE object`);for(const o of["p","n","h"]){const c=t[o];if(!(typeof c=="bigint"&&c>yn))throw Error(`CURVE.${o} must be positive bigint`)}const i=cc(t.p,r.Fp,e),s=cc(t.n,r.Fn,e),a=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const o of a)if(!i.isValid(t[o]))throw Error(`CURVE.${o} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:i,Fn:s}}const uc=(n,t)=>(n+(n>=0?t:-t)/v0)/t;function Ia(n){if(!["compact","recovered","der"].includes(n))throw Error('Signature format must be "compact", "recovered", or "der"');return n}function Os(n,t){const r={};for(let e of Object.keys(t))r[e]=n[e]===void 0?t[e]:n[e];return Tr(r.lowS,"lowS"),Tr(r.prehash,"prehash"),r.format!==void 0&&Ia(r.format),r}const ze={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(n,t)=>{const{Err:r}=ze;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(1&t.length)throw new r("tlv.encode: unpadded data");const e=t.length/2,i=hi(e);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const s=e>127?hi(i.length/2|128):"";return hi(n)+s+i+t},decode(n,t){const{Err:r}=ze;let e=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[e++]!==n)throw new r("tlv.decode: wrong tlv");const i=t[e++];let s=0;if(128&i){const o=127&i;if(!o)throw new r("tlv.decode(long): indefinite length not supported");if(o>4)throw new r("tlv.decode(long): byte length is too big");const c=t.subarray(e,e+o);if(c.length!==o)throw new r("tlv.decode: length bytes not complete");if(c[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const u of c)s=s<<8|u;if(e+=o,s<128)throw new r("tlv.decode(long): not minimal encoding")}else s=i;const a=t.subarray(e,e+s);if(a.length!==s)throw new r("tlv.decode: wrong value length");return{v:a,l:t.subarray(e+s)}}},_int:{encode(n){const{Err:t}=ze;if(n<Ge)throw new t("integer: negative integers are not allowed");let r=hi(n);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:t}=ze;if(128&n[0])throw new t("invalid signature integer: negative");if(n[0]===0&&!(128&n[1]))throw new t("invalid signature integer: unnecessary leading zero");return ws(n)}},toSig(n){const{Err:t,_int:r,_tlv:e}=ze,i=lt("signature",n),{v:s,l:a}=e.decode(48,i);if(a.length)throw new t("invalid signature: left bytes after parsing");const{v:o,l:c}=e.decode(2,s),{v:u,l:h}=e.decode(2,c);if(h.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(o),s:r.decode(u)}},hexFromSig(n){const{_tlv:t,_int:r}=ze,e=t.encode(2,r.encode(n.r))+t.encode(2,r.encode(n.s));return t.encode(48,e)}},Ge=BigInt(0),_r=BigInt(1),v0=BigInt(2),gi=BigInt(3),eh=BigInt(4);function $r(n,t){const{BYTES:r}=n;let e;if(typeof t=="bigint")e=t;else{let i=lt("private key",t);try{e=n.fromBytes(i)}catch{throw Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!n.isValidNot0(e))throw Error("invalid private key: out of range [1..N-1]");return e}function rh(n,t={}){const r=E0("weierstrass",n,t),{Fp:e,Fn:i}=r;let s=r.CURVE;const{h:a,n:o}=s;dn(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=t;if(c&&(!e.is0(s.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const u=S0(e,i);function h(){if(!e.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const l=t.toBytes||function(K,I,B){const{x:U,y:x}=I.toAffine(),M=e.toBytes(U);return Tr(B,"isCompressed"),B?(h(),le(I0(!e.isOdd(x)),M)):le(Uint8Array.of(4),M,e.toBytes(x))},y=t.fromBytes||function(K){ge(K,void 0,"Point");const{publicKey:I,publicKeyUncompressed:B}=u,U=K.length,x=K[0],M=K.subarray(1);if(U!==I||x!==2&&x!==3){if(U===B&&x===4){const Q=e.BYTES,R=e.fromBytes(M.subarray(0,Q)),N=e.fromBytes(M.subarray(Q,2*Q));if(!p(R,N))throw Error("bad point: is not on curve");return{x:R,y:N}}throw Error(`bad point: got length ${U}, expected compressed=${I} or uncompressed=${B}`)}{const Q=e.fromBytes(M);if(!e.isValid(Q))throw Error("bad point: is not on curve, wrong x");const R=g(Q);let N;try{N=e.sqrt(R)}catch(T){const F=T instanceof Error?": "+T.message:"";throw Error("bad point: is not on curve, sqrt error"+F)}return h(),!(1&~x)!==e.isOdd(N)&&(N=e.neg(N)),{x:Q,y:N}}};function g(K){const I=e.sqr(K),B=e.mul(I,K);return e.add(e.add(B,e.mul(K,s.a)),s.b)}function p(K,I){const B=e.sqr(I),U=g(K);return e.eql(B,U)}if(!p(s.Gx,s.Gy))throw Error("bad curve params: generator point");const A=e.mul(e.pow(s.a,gi),eh),w=e.mul(e.sqr(s.b),BigInt(27));if(e.is0(e.add(A,w)))throw Error("bad curve params: a or b");function b(K,I,B=!1){if(!e.isValid(I)||B&&e.is0(I))throw Error("bad point coordinate "+K);return I}function v(K){if(!(K instanceof P))throw Error("ProjectivePoint expected")}function k(K){if(!c||!c.basises)throw Error("no endo");return(function(I,B,U){const[[x,M],[Q,R]]=B,N=uc(R*I,U),T=uc(-M*I,U);let F=I-N*x-T*Q,z=-N*M-T*R;const L=F<Ge,O=z<Ge;L&&(F=-F),O&&(z=-z);const H=ni(Math.ceil($1(U)/2))+_r;if(F<Ge||F>=H||z<Ge||z>=H)throw Error("splitScalar (endomorphism): failed, k="+I);return{k1neg:L,k1:F,k2neg:O,k2:z}})(K,c.basises,i.ORDER)}const m=Yi(((K,I)=>{const{X:B,Y:U,Z:x}=K;if(e.eql(x,e.ONE))return{x:B,y:U};const M=K.is0();I==null&&(I=M?e.ONE:e.inv(x));const Q=e.mul(B,I),R=e.mul(U,I),N=e.mul(x,I);if(M)return{x:e.ZERO,y:e.ZERO};if(!e.eql(N,e.ONE))throw Error("invZ was invalid");return{x:Q,y:R}})),C=Yi((K=>{if(K.is0()){if(t.allowInfinityPoint&&!e.is0(K.Y))return;throw Error("bad point: ZERO")}const{x:I,y:B}=K.toAffine();if(!e.isValid(I)||!e.isValid(B))throw Error("bad point: x or y not field elements");if(!p(I,B))throw Error("bad point: equation left != right");if(!K.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));function D(K,I,B,U,x){return B=new P(e.mul(B.X,K),B.Y,B.Z),I=Zi(U,I),B=Zi(x,B),I.add(B)}class P{constructor(I,B,U){this.X=b("x",I),this.Y=b("y",B,!0),this.Z=b("z",U),Object.freeze(this)}static CURVE(){return s}static fromAffine(I){const{x:B,y:U}=I||{};if(!I||!e.isValid(B)||!e.isValid(U))throw Error("invalid affine point");if(I instanceof P)throw Error("projective point not allowed");return e.is0(B)&&e.is0(U)?P.ZERO:new P(B,U,e.ONE)}static fromBytes(I){const B=P.fromAffine(y(ge(I,void 0,"point")));return B.assertValidity(),B}static fromHex(I){return P.fromBytes(lt("pointHex",I))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(I=8,B=!0){return E.createCache(this,I),B||this.multiply(gi),this}assertValidity(){C(this)}hasEvenY(){const{y:I}=this.toAffine();if(!e.isOdd)throw Error("Field doesn't support isOdd");return!e.isOdd(I)}equals(I){v(I);const{X:B,Y:U,Z:x}=this,{X:M,Y:Q,Z:R}=I,N=e.eql(e.mul(B,R),e.mul(M,x)),T=e.eql(e.mul(U,R),e.mul(Q,x));return N&&T}negate(){return new P(this.X,e.neg(this.Y),this.Z)}double(){const{a:I,b:B}=s,U=e.mul(B,gi),{X:x,Y:M,Z:Q}=this;let R=e.ZERO,N=e.ZERO,T=e.ZERO,F=e.mul(x,x),z=e.mul(M,M),L=e.mul(Q,Q),O=e.mul(x,M);return O=e.add(O,O),T=e.mul(x,Q),T=e.add(T,T),R=e.mul(I,T),N=e.mul(U,L),N=e.add(R,N),R=e.sub(z,N),N=e.add(z,N),N=e.mul(R,N),R=e.mul(O,R),T=e.mul(U,T),L=e.mul(I,L),O=e.sub(F,L),O=e.mul(I,O),O=e.add(O,T),T=e.add(F,F),F=e.add(T,F),F=e.add(F,L),F=e.mul(F,O),N=e.add(N,F),L=e.mul(M,Q),L=e.add(L,L),F=e.mul(L,O),R=e.sub(R,F),T=e.mul(L,z),T=e.add(T,T),T=e.add(T,T),new P(R,N,T)}add(I){v(I);const{X:B,Y:U,Z:x}=this,{X:M,Y:Q,Z:R}=I;let N=e.ZERO,T=e.ZERO,F=e.ZERO;const z=s.a,L=e.mul(s.b,gi);let O=e.mul(B,M),H=e.mul(U,Q),j=e.mul(x,R),V=e.add(B,U),J=e.add(M,Q);V=e.mul(V,J),J=e.add(O,H),V=e.sub(V,J),J=e.add(B,x);let q=e.add(M,R);return J=e.mul(J,q),q=e.add(O,j),J=e.sub(J,q),q=e.add(U,x),N=e.add(Q,R),q=e.mul(q,N),N=e.add(H,j),q=e.sub(q,N),F=e.mul(z,J),N=e.mul(L,j),F=e.add(N,F),N=e.sub(H,F),F=e.add(H,F),T=e.mul(N,F),H=e.add(O,O),H=e.add(H,O),j=e.mul(z,j),J=e.mul(L,J),H=e.add(H,j),j=e.sub(O,j),j=e.mul(z,j),J=e.add(J,j),O=e.mul(H,J),T=e.add(T,O),O=e.mul(q,J),N=e.mul(V,N),N=e.sub(N,O),O=e.mul(V,H),F=e.mul(q,F),F=e.add(F,O),new P(N,T,F)}subtract(I){return this.add(I.negate())}is0(){return this.equals(P.ZERO)}multiply(I){const{endo:B}=t;if(!i.isValidNot0(I))throw Error("invalid scalar: out of range");let U,x;const M=Q=>E.cached(this,Q,(R=>Kr(P,R)));if(B){const{k1neg:Q,k1:R,k2neg:N,k2:T}=k(I),{p:F,f:z}=M(R),{p:L,f:O}=M(T);x=z.add(O),U=D(B.beta,F,L,Q,N)}else{const{p:Q,f:R}=M(I);U=Q,x=R}return Kr(P,[U,x])[0]}multiplyUnsafe(I){const{endo:B}=t,U=this;if(!i.isValid(I))throw Error("invalid scalar: out of range");if(I===Ge||U.is0())return P.ZERO;if(I===_r)return U;if(E.hasCache(this))return this.multiply(I);if(B){const{k1neg:x,k1:M,k2neg:Q,k2:R}=k(I),{p1:N,p2:T}=(function(F,z,L,O){let H=z,j=F.ZERO,V=F.ZERO;for(;L>yn||O>yn;)L&Br&&(j=j.add(H)),O&Br&&(V=V.add(H)),H=H.double(),L>>=Br,O>>=Br;return{p1:j,p2:V}})(P,U,M,R);return D(B.beta,N,T,x,Q)}return E.unsafe(U,I)}multiplyAndAddUnsafe(I,B,U){const x=this.multiplyUnsafe(B).add(I.multiplyUnsafe(U));return x.is0()?void 0:x}toAffine(I){return m(this,I)}isTorsionFree(){const{isTorsionFree:I}=t;return a===_r||(I?I(P,this):E.unsafe(this,o).is0())}clearCofactor(){const{clearCofactor:I}=t;return a===_r?this:I?I(P,this):this.multiplyUnsafe(a)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}toBytes(I=!0){return Tr(I,"isCompressed"),this.assertValidity(),l(P,this,I)}toHex(I=!0){return Dr(this.toBytes(I))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(I=!0){return this.toBytes(I)}_setWindowSize(I){this.precompute(I)}static normalizeZ(I){return Kr(P,I)}static msm(I,B){return k0(P,i,I,B)}static fromPrivateKey(I){return P.BASE.multiply($r(i,I))}}P.BASE=new P(s.Gx,s.Gy,e.ONE),P.ZERO=new P(e.ZERO,e.ONE,e.ZERO),P.Fp=e,P.Fn=i;const S=i.BITS,E=new b0(P,t.endo?Math.ceil(S/2):S);return P.BASE.precompute(8),P}function I0(n){return Uint8Array.of(n?2:3)}function S0(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function nh(n,t={}){const{Fn:r}=n,e=t.randomBytes||As,i=Object.assign(S0(n.Fp,r),{seed:rc(r.ORDER)});function s(h){try{return!!$r(r,h)}catch{return!1}}function a(h=e(i.seed)){return(function(l,y,g=!1){const p=l.length,A=o0(y),w=rc(y);if(p<16||p<w||p>1024)throw Error("expected "+w+"-1024 bytes of input, got "+p);const b=St(g?Fr(l):ws(l),y-Ht)+Ht;return g?eo(b,A):to(b,A)})(ge(h,i.seed,"seed"),r.ORDER)}function o(h,l=!0){return n.BASE.multiply($r(r,h)).toBytes(l)}function c(h){if(typeof h=="bigint")return!1;if(h instanceof n)return!0;const{secretKey:l,publicKey:y,publicKeyUncompressed:g}=i;if(r.allowedLengths||l===y)return;const p=lt("key",h).length;return p===y||p===g}return Object.freeze({getPublicKey:o,getSharedSecret:function(h,l,y=!0){if(c(h)===!0)throw Error("first arg must be private key");if(c(l)===!1)throw Error("second arg must be public key");const g=$r(r,h);return n.fromHex(l).multiply(g).toBytes(y)},keygen:function(h){const l=a(h);return{secretKey:l,publicKey:o(l)}},Point:n,utils:{isValidSecretKey:s,isValidPublicKey:function(h,l){const{publicKey:y,publicKeyUncompressed:g}=i;try{const p=h.length;return(l!==!0||p===y)&&(l!==!1||p===g)&&!!n.fromBytes(h)}catch{return!1}},randomSecretKey:a,isValidPrivateKey:s,randomPrivateKey:a,normPrivateKeyToScalar:h=>$r(r,h),precompute:(h=8,l=n.BASE)=>l.precompute(h,!1)},lengths:i})}function ih(n,t,r={}){J1(t),dn(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const e=r.randomBytes||As,i=r.hmac||((S,...E)=>A0(t,S,le(...E))),{Fp:s,Fn:a}=n,{ORDER:o,BITS:c}=a,{keygen:u,getPublicKey:h,getSharedSecret:l,utils:y,lengths:g}=nh(n,r),p={prehash:!1,lowS:typeof r.lowS=="boolean"&&r.lowS,format:void 0,extraEntropy:!1},A="compact";function w(S){return S>o>>_r}function b(S,E){if(!a.isValidNot0(E))throw Error(`invalid signature ${S}: out of range 1..Point.Fn.ORDER`);return E}class v{constructor(E,K,I){this.r=b("r",E),this.s=b("s",K),I!=null&&(this.recovery=I),Object.freeze(this)}static fromBytes(E,K=A){let I;if((function(M,Q){Ia(Q);const R=g.signature;ge(M,Q==="compact"?R:Q==="recovered"?R+1:void 0,Q+" signature")})(E,K),K==="der"){const{r:M,s:Q}=ze.toSig(ge(E));return new v(M,Q)}K==="recovered"&&(I=E[0],K="compact",E=E.subarray(1));const B=a.BYTES,U=E.subarray(0,B),x=E.subarray(B,2*B);return new v(a.fromBytes(U),a.fromBytes(x),I)}static fromHex(E,K){return this.fromBytes(qi(E),K)}addRecoveryBit(E){return new v(this.r,this.s,E)}recoverPublicKey(E){const K=s.ORDER,{r:I,s:B,recovery:U}=this;if(U==null||![0,1,2,3].includes(U))throw Error("recovery id invalid");if(o*v0<K&&U>1)throw Error("recovery id is ambiguous for h>1 curve");const x=U===2||U===3?I+o:I;if(!s.isValid(x))throw Error("recovery id 2 or 3 invalid");const M=s.toBytes(x),Q=n.fromBytes(le(I0(!(1&U)),M)),R=a.inv(x),N=m(lt("msgHash",E)),T=a.create(-N*R),F=a.create(B*R),z=n.BASE.multiplyUnsafe(T).add(Q.multiplyUnsafe(F));if(z.is0())throw Error("point at infinify");return z.assertValidity(),z}hasHighS(){return w(this.s)}toBytes(E=A){if(Ia(E),E==="der")return qi(ze.hexFromSig(this));const K=a.toBytes(this.r),I=a.toBytes(this.s);if(E==="recovered"){if(this.recovery==null)throw Error("recovery bit must be present");return le(Uint8Array.of(this.recovery),K,I)}return le(K,I)}toHex(E){return Dr(this.toBytes(E))}assertValidity(){}static fromCompact(E){return v.fromBytes(lt("sig",E),"compact")}static fromDER(E){return v.fromBytes(lt("sig",E),"der")}normalizeS(){return this.hasHighS()?new v(this.r,a.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Dr(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Dr(this.toBytes("compact"))}}const k=r.bits2int||function(S){if(S.length>8192)throw Error("input is too large");const E=ws(S),K=8*S.length-c;return K>0?E>>BigInt(K):E},m=r.bits2int_modN||function(S){return a.create(k(S))},C=ni(c);function D(S){return Jn("num < 2^"+c,S,Ge,C),a.toBytes(S)}function P(S,E){return ge(S,void 0,"message"),E?ge(t(S),void 0,"prehashed message"):S}return Object.freeze({keygen:u,getPublicKey:h,getSharedSecret:l,utils:y,lengths:g,Point:n,sign:function(S,E,K={}){S=lt("message",S);const{seed:I,k2sig:B}=(function(x,M,Q){if(["recovered","canonical"].some((j=>j in Q)))throw Error("sign() legacy options not supported");const{lowS:R,prehash:N,extraEntropy:T}=Os(Q,p);x=P(x,N);const F=m(x),z=$r(a,M),L=[D(z),D(F)];if(T!=null&&T!==!1){const j=T===!0?e(g.secretKey):T;L.push(lt("extraEntropy",j))}const O=le(...L),H=F;return{seed:O,k2sig:function(j){const V=k(j);if(!a.isValidNot0(V))return;const J=a.inv(V),q=n.BASE.multiply(V).toAffine(),$=a.create(q.x);if($===Ge)return;const _=a.create(J*a.create(H+$*z));if(_===Ge)return;let nt=(q.x===$?0:2)|Number(q.y&_r),W=_;return R&&w(_)&&(W=a.neg(_),nt^=1),new v($,W,nt)}}})(S,E,K);return(function(x,M,Q){if(typeof x!="number"||x<2)throw Error("hashLen must be a number");if(typeof M!="number"||M<2)throw Error("qByteLen must be a number");if(typeof Q!="function")throw Error("hmacFn must be a function");const R=V=>new Uint8Array(V),N=V=>Uint8Array.of(V);let T=R(x),F=R(x),z=0;const L=()=>{T.fill(1),F.fill(0),z=0},O=(...V)=>Q(F,T,...V),H=(V=R(0))=>{F=O(N(0),V),T=O(),V.length!==0&&(F=O(N(1),V),T=O())},j=()=>{if(z++>=1e3)throw Error("drbg: tried 1000 values");let V=0;const J=[];for(;V<M;){T=O();const q=T.slice();J.push(q),V+=T.length}return le(...J)};return(V,J)=>{let q;for(L(),H(V);!(q=J(j()));)H();return L(),q}})(t.outputLen,a.BYTES,i)(I,B)},verify:function(S,E,K,I={}){const{lowS:B,prehash:U,format:x}=Os(I,p);if(K=lt("publicKey",K),E=P(lt("message",E),U),"strict"in I)throw Error("options.strict was renamed to lowS");const M=x===void 0?(function(Q){let R;const N=typeof Q=="string"||ei(Q),T=!N&&Q!==null&&typeof Q=="object"&&typeof Q.r=="bigint"&&typeof Q.s=="bigint";if(!N&&!T)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(T)R=new v(Q.r,Q.s);else if(N){try{R=v.fromBytes(lt("sig",Q),"der")}catch(F){if(!(F instanceof ze.Err))throw F}if(!R)try{R=v.fromBytes(lt("sig",Q),"compact")}catch{return!1}}return R||!1})(S):v.fromBytes(lt("sig",S),x);if(M===!1)return!1;try{const Q=n.fromBytes(K);if(B&&M.hasHighS())return!1;const{r:R,s:N}=M,T=m(E),F=a.inv(N),z=a.create(T*F),L=a.create(R*F),O=n.BASE.multiplyUnsafe(z).add(Q.multiplyUnsafe(L));return O.is0()?!1:a.create(O.x)===R}catch{return!1}},recoverPublicKey:function(S,E,K={}){const{prehash:I}=Os(K,p);return E=P(E,I),v.fromBytes(S,"recovered").recoverPublicKey(E).toBytes()},Signature:v,hash:t})}function sh(n){const{CURVE:t,curveOpts:r}=(function(i){const s={a:i.a,b:i.b,p:i.Fp.ORDER,n:i.n,h:i.h,Gx:i.Gx,Gy:i.Gy},a=i.Fp;let o=i.allowedPrivateKeyLengths?Array.from(new Set(i.allowedPrivateKeyLengths.map((c=>Math.ceil(c/2))))):void 0;return{CURVE:s,curveOpts:{Fp:a,Fn:Xt(s.n,{BITS:i.nBitLength,allowedLengths:o,modFromBytes:i.wrapPrivateKey}),allowInfinityPoint:i.allowInfinityPoint,endo:i.endo,isTorsionFree:i.isTorsionFree,clearCofactor:i.clearCofactor,fromBytes:i.fromBytes,toBytes:i.toBytes}}})(n),e={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:r,hash:n.hash,ecdsaOpts:e}}function ah(n){const{CURVE:t,curveOpts:r,hash:e,ecdsaOpts:i}=sh(n);return(function(s,a){const o=a.Point;return Object.assign({},a,{ProjectivePoint:o,CURVE:Object.assign({},s,a0(o.Fn.ORDER,o.Fn.BITS))})})(n,ih(rh(t,r),e,i))}function Nr(n,t){const r=e=>ah({...n,hash:e});return{...r(t),create:r}}const B0={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},K0={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},C0={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},oh=Xt(B0.p),ch=Xt(K0.p),uh=Xt(C0.p),hh=Nr({...B0,Fp:oh,lowS:!1},no),fh=Nr({...K0,Fp:ch,lowS:!1},p0),lh=Nr({...C0,Fp:uh,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},g0),yh=BigInt(0),Sn=BigInt(1),gh=BigInt(2),ph=BigInt(7),dh=BigInt(256),Ah=BigInt(113),U0=[],P0=[],D0=[];for(let n=0,t=Sn,r=1,e=0;n<24;n++){[r,e]=[e,(2*r+3*e)%5],U0.push(2*(5*e+r)),P0.push((n+1)*(n+2)/2%64);let i=yh;for(let s=0;s<7;s++)t=(t<<Sn^(t>>ph)*Ah)%dh,t&gh&&(i^=Sn<<(Sn<<BigInt(s))-Sn);D0.push(i)}const x0=h0(D0,!0),wh=x0[0],mh=x0[1],hc=(n,t,r)=>r>32?((e,i,s)=>i<<s-32|e>>>64-s)(n,t,r):((e,i,s)=>e<<s|i>>>32-s)(n,t,r),fc=(n,t,r)=>r>32?((e,i,s)=>e<<s-32|i>>>64-s)(n,t,r):((e,i,s)=>i<<s|e>>>32-s)(n,t,r);class ms extends _a{constructor(t,r,e,i=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=r,this.outputLen=e,this.enableXOF=i,this.rounds=s,Zn(e),!(0<t&&t<200))throw Error("only keccak-f1600 function is supported");var a;this.state=new Uint8Array(200),this.state32=(a=this.state,new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4)))}clone(){return this._cloneInto()}keccak(){qo(this.state32),(function(t,r=24){const e=new Uint32Array(10);for(let i=24-r;i<24;i++){for(let o=0;o<10;o++)e[o]=t[o]^t[o+10]^t[o+20]^t[o+30]^t[o+40];for(let o=0;o<10;o+=2){const c=(o+8)%10,u=(o+2)%10,h=e[u],l=e[u+1],y=hc(h,l,1)^e[c],g=fc(h,l,1)^e[c+1];for(let p=0;p<50;p+=10)t[o+p]^=y,t[o+p+1]^=g}let s=t[2],a=t[3];for(let o=0;o<24;o++){const c=P0[o],u=hc(s,a,c),h=fc(s,a,c),l=U0[o];s=t[l],a=t[l+1],t[l]=u,t[l+1]=h}for(let o=0;o<50;o+=10){for(let c=0;c<10;c++)e[c]=t[o+c];for(let c=0;c<10;c++)t[o+c]^=~e[(c+2)%10]&e[(c+4)%10]}t[0]^=wh[i],t[1]^=mh[i]}ce(e)})(this.state32,this.rounds),qo(this.state32),this.posOut=0,this.pos=0}update(t){ln(this),Me(t=ri(t));const{blockLen:r,state:e}=this,i=t.length;for(let s=0;s<i;){const a=Math.min(r-this.pos,i-s);for(let o=0;o<a;o++)e[this.pos++]^=t[s++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:r,pos:e,blockLen:i}=this;t[e]^=r,128&r&&e===i-1&&this.keccak(),t[i-1]^=128,this.keccak()}writeInto(t){ln(this,!1),Me(t),this.finish();const r=this.state,{blockLen:e}=this;for(let i=0,s=t.length;i<s;){this.posOut>=e&&this.keccak();const a=Math.min(e-this.posOut,s-i);t.set(r.subarray(this.posOut,this.posOut+a),i),this.posOut+=a,i+=a}return t}xofInto(t){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Zn(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(X1(t,this),this.finished)throw Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,ce(this.state)}_cloneInto(t){const{blockLen:r,suffix:e,outputLen:i,rounds:s,enableXOF:a}=this;return t||(t=new ms(r,e,i,a,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=e,t.outputLen=i,t.enableXOF=a,t.destroyed=this.destroyed,t}}const Q0=(n,t,r)=>We((()=>new ms(t,n,r))),bh=Q0(6,136,32),kh=Q0(6,72,64),Eh=(n,t,r)=>(function(e){const i=(a,o)=>e(o).update(ri(a)).digest(),s=e({});return i.outputLen=s.outputLen,i.blockLen=s.blockLen,i.create=a=>e(a),i})(((e={})=>new ms(t,n,e.dkLen===void 0?r:e.dkLen,!0))),vh=Eh(31,136,32),nr=BigInt(0),Kt=BigInt(1),Hs=BigInt(2),Ih=BigInt(8);function M0(n,t={}){const r=E0("edwards",n,t,t.FpFnLE),{Fp:e,Fn:i}=r;let s=r.CURVE;const{h:a}=s;dn(t,{},{uvRatio:"function"});const o=Hs<<BigInt(8*i.BYTES)-Kt,c=w=>e.create(w),u=t.uvRatio||((w,b)=>{try{return{isValid:!0,value:e.sqrt(e.div(w,b))}}catch{return{isValid:!1,value:nr}}});if(!(function(w,b,v,k){const m=w.sqr(v),C=w.sqr(k),D=w.add(w.mul(b.a,m),C),P=w.add(w.ONE,w.mul(b.d,w.mul(m,C)));return w.eql(D,P)})(e,s,s.Gx,s.Gy))throw Error("bad curve params: generator point");function h(w,b,v=!1){return Jn("coordinate "+w,b,v?Kt:nr,o),b}function l(w){if(!(w instanceof p))throw Error("ExtendedPoint expected")}const y=Yi(((w,b)=>{const{X:v,Y:k,Z:m}=w,C=w.is0();b==null&&(b=C?Ih:e.inv(m));const D=c(v*b),P=c(k*b),S=e.mul(m,b);if(C)return{x:nr,y:Kt};if(S!==Kt)throw Error("invZ was invalid");return{x:D,y:P}})),g=Yi((w=>{const{a:b,d:v}=s;if(w.is0())throw Error("bad point: ZERO");const{X:k,Y:m,Z:C,T:D}=w,P=c(k*k),S=c(m*m),E=c(C*C),K=c(E*E),I=c(P*b);if(c(E*c(I+S))!==c(K+c(v*c(P*S))))throw Error("bad point: equation left != right (1)");if(c(k*m)!==c(C*D))throw Error("bad point: equation left != right (2)");return!0}));class p{constructor(b,v,k,m){this.X=h("x",b),this.Y=h("y",v),this.Z=h("z",k,!0),this.T=h("t",m),Object.freeze(this)}static CURVE(){return s}static fromAffine(b){if(b instanceof p)throw Error("extended point not allowed");const{x:v,y:k}=b||{};return h("x",v),h("y",k),new p(v,k,Kt,c(v*k))}static fromBytes(b,v=!1){const k=e.BYTES,{a:m,d:C}=s;b=Wo(ge(b,k,"point")),Tr(v,"zip215");const D=Wo(b),P=b[k-1];D[k-1]=-129&P;const S=Fr(D),E=v?o:e.ORDER;Jn("point.y",S,nr,E);const K=c(S*S),I=c(K-Kt),B=c(C*K-m);let{isValid:U,value:x}=u(I,B);if(!U)throw Error("bad point: invalid y coordinate");const M=(x&Kt)===Kt,Q=!!(128&P);if(!v&&x===nr&&Q)throw Error("bad point: x=0 and x_0=1");return Q!==M&&(x=c(-x)),p.fromAffine({x,y:S})}static fromHex(b,v=!1){return p.fromBytes(lt("point",b),v)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(b=8,v=!0){return A.createCache(this,b),v||this.multiply(Hs),this}assertValidity(){g(this)}equals(b){l(b);const{X:v,Y:k,Z:m}=this,{X:C,Y:D,Z:P}=b,S=c(v*P),E=c(C*m),K=c(k*P),I=c(D*m);return S===E&&K===I}is0(){return this.equals(p.ZERO)}negate(){return new p(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:b}=s,{X:v,Y:k,Z:m}=this,C=c(v*v),D=c(k*k),P=c(Hs*c(m*m)),S=c(b*C),E=v+k,K=c(c(E*E)-C-D),I=S+D,B=I-P,U=S-D,x=c(K*B),M=c(I*U),Q=c(K*U),R=c(B*I);return new p(x,M,R,Q)}add(b){l(b);const{a:v,d:k}=s,{X:m,Y:C,Z:D,T:P}=this,{X:S,Y:E,Z:K,T:I}=b,B=c(m*S),U=c(C*E),x=c(P*k*I),M=c(D*K),Q=c((m+C)*(S+E)-B-U),R=M-x,N=M+x,T=c(U-v*B),F=c(Q*R),z=c(N*T),L=c(Q*T),O=c(R*N);return new p(F,z,O,L)}subtract(b){return this.add(b.negate())}multiply(b){if(!i.isValidNot0(b))throw Error("invalid scalar: expected 1 <= sc < curve.n");const{p:v,f:k}=A.cached(this,b,(m=>Kr(p,m)));return Kr(p,[v,k])[0]}multiplyUnsafe(b,v=p.ZERO){if(!i.isValid(b))throw Error("invalid scalar: expected 0 <= sc < curve.n");return b===nr?p.ZERO:this.is0()||b===Kt?this:A.unsafe(this,b,(k=>Kr(p,k)),v)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return A.unsafe(this,s.n).is0()}toAffine(b){return y(this,b)}clearCofactor(){return a===Kt?this:this.multiplyUnsafe(a)}toBytes(){const{x:b,y:v}=this.toAffine(),k=e.toBytes(v);return k[k.length-1]|=b&Kt?128:0,k}toHex(){return Dr(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(b){return Kr(p,b)}static msm(b,v){return k0(p,i,b,v)}_setWindowSize(b){this.precompute(b)}toRawBytes(){return this.toBytes()}}p.BASE=new p(s.Gx,s.Gy,Kt,c(s.Gx*s.Gy)),p.ZERO=new p(nr,Kt,Kt,nr),p.Fp=e,p.Fn=i;const A=new b0(p,i.BITS);return p.BASE.precompute(8),p}function Sh(n,t,r={}){if(typeof t!="function")throw Error('"hash" function param is required');dn(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:e}=r,{BASE:i,Fp:s,Fn:a}=n,o=r.randomBytes||As,c=r.adjustScalarBytes||(k=>k),u=r.domain||((k,m,C)=>{if(Tr(C,"phflag"),m.length||C)throw Error("Contexts/pre-hash are not supported");return k});function h(k){return a.create(Fr(k))}function l(k){const{head:m,prefix:C,scalar:D}=(function(E){const K=w.secretKey;E=lt("private key",E,K);const I=lt("hashed private key",t(E),2*K),B=c(I.slice(0,K));return{head:B,prefix:I.slice(K,2*K),scalar:h(B)}})(k),P=i.multiply(D),S=P.toBytes();return{head:m,prefix:C,scalar:D,point:P,pointBytes:S}}function y(k){return l(k).pointBytes}function g(k=Uint8Array.of(),...m){const C=le(...m);return h(t(u(C,lt("context",k),!!e)))}const p={zip215:!0},A=s.BYTES,w={secretKey:A,publicKey:A,signature:2*A,seed:A};function b(k=o(w.seed)){return ge(k,w.seed,"seed")}const v={getExtendedPublicKey:l,randomSecretKey:b,isValidSecretKey:function(k){return ei(k)&&k.length===a.BYTES},isValidPublicKey:function(k,m){try{return!!n.fromBytes(k,m)}catch{return!1}},toMontgomery(k){const{y:m}=n.fromBytes(k),C=w.publicKey,D=C===32;if(!D&&C!==57)throw Error("only defined for 25519 and 448");const P=D?s.div(Kt+m,Kt-m):s.div(m-Kt,m+Kt);return s.toBytes(P)},toMontgomerySecret(k){const m=w.secretKey;ge(k,m);const C=t(k.subarray(0,m));return c(C).subarray(0,m)},randomPrivateKey:b,precompute:(k=8,m=n.BASE)=>m.precompute(k,!1)};return Object.freeze({keygen:function(k){const m=v.randomSecretKey(k);return{secretKey:m,publicKey:y(m)}},getPublicKey:y,sign:function(k,m,C={}){k=lt("message",k),e&&(k=e(k));const{prefix:D,scalar:P,pointBytes:S}=l(m),E=g(C.context,D,k),K=i.multiply(E).toBytes(),I=g(C.context,K,S,k),B=a.create(E+I*P);if(!a.isValid(B))throw Error("sign failed: invalid s");return ge(le(K,a.toBytes(B)),w.signature,"result")},verify:function(k,m,C,D=p){const{context:P,zip215:S}=D,E=w.signature;k=lt("signature",k,E),m=lt("message",m),C=lt("publicKey",C,w.publicKey),S!==void 0&&Tr(S,"zip215"),e&&(m=e(m));const K=E/2,I=k.subarray(0,K),B=Fr(k.subarray(K,E));let U,x,M;try{U=n.fromBytes(C,S),x=n.fromBytes(I,S),M=i.multiplyUnsafe(B)}catch{return!1}if(!S&&U.isSmallOrder())return!1;const Q=g(P,x.toBytes(),U.toBytes(),m);return x.add(U.multiplyUnsafe(Q)).subtract(M).clearCofactor().is0()},utils:v,Point:n,lengths:w})}const Bn=BigInt(0),Vr=BigInt(1),pi=BigInt(2);function Bh(n){const t=(dn(r=n,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r}));var r;const{P:e,type:i,adjustScalarBytes:s,powPminus2:a,randomBytes:o}=t,c=i==="x25519";if(!c&&i!=="x448")throw Error("invalid type");const u=o||As,h=c?255:448,l=c?32:56,y=BigInt(c?9:5),g=BigInt(c?121665:39081),p=c?pi**BigInt(254):pi**BigInt(447),A=c?BigInt(8)*pi**BigInt(251)-Vr:BigInt(4)*pi**BigInt(445)-Vr,w=p+A+Vr,b=E=>St(E,e),v=k(y);function k(E){return eo(b(E),l)}function m(E,K){const I=(function(B,U){Jn("u",B,Bn,e),Jn("scalar",U,p,w);const x=U,M=B;let Q=Vr,R=Bn,N=B,T=Vr,F=Bn;for(let L=BigInt(h-1);L>=Bn;L--){const O=x>>L&Vr;F^=O,{x_2:Q,x_3:N}=D(F,Q,N),{x_2:R,x_3:T}=D(F,R,T),F=O;const H=Q+R,j=b(H*H),V=Q-R,J=b(V*V),q=j-J,$=N+T,_=b((N-T)*H),nt=b($*V),W=_+nt,pt=_-nt;N=b(W*W),T=b(M*b(pt*pt)),Q=b(j*J),R=b(q*(j+b(g*q)))}({x_2:Q,x_3:N}=D(F,Q,N)),{x_2:R,x_3:T}=D(F,R,T);const z=a(R);return b(Q*z)})((function(B){const U=lt("u coordinate",B,l);return c&&(U[31]&=127),b(Fr(U))})(K),(function(B){return Fr(s(lt("scalar",B,l)))})(E));if(I===Bn)throw Error("invalid private or public key received");return k(I)}function C(E){return m(E,v)}function D(E,K,I){const B=b(E*(K-I));return{x_2:K=b(K-B),x_3:I=b(I+B)}}const P={secretKey:l,publicKey:l,seed:l},S=(E=u(l))=>(Me(E,P.seed),E);return{keygen:function(E){const K=S(E);return{secretKey:K,publicKey:C(K)}},getSharedSecret:(E,K)=>m(E,K),getPublicKey:E=>C(E),scalarMult:m,scalarMultBase:C,utils:{randomSecretKey:S,randomPrivateKey:S},GuBytes:v.slice(),lengths:P}}const Or={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3"),h:BigInt(4),a:BigInt(1),d:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffff6756"),Gx:BigInt("0x4f1970c66bed0ded221d15a622bf36da9e146570470f1767ea6de324a3d3a46412ae1af72ab66511433b80e18b00938e2626a82bc70cc05e"),Gy:BigInt("0x693f46716eb6bc248876203756c9c7624bea73736ca3984087789c1e05a0c2d73ad3ff1ce67c39c4fdbd132c4ed7c8ad9808795bf230fa14")},Kh=Object.assign({},Or,{d:BigInt("0xd78b4bdc7f0daf19f24f38c29373a2ccad46157242a50f37809b1da3412a12e79ccc9c81264cfe9ad080997058fb61c4243cc32dbaa156b9"),Gx:BigInt("0x79a70b2b70400553ae7c9df416c792c61128751ac92969240c25a07d728bdc93e21f7787ed6972249de732f38496cd11698713093e9c04fc"),Gy:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000000000000000000000000000000000000000000001")}),Ch=We((()=>vh.create({dkLen:114}))),Uh=BigInt(1),Sa=BigInt(2),lc=BigInt(3);BigInt(4);const Ph=BigInt(11),Dh=BigInt(22),yc=BigInt(44),xh=BigInt(88),Qh=BigInt(223);function R0(n){const t=Or.p,r=n*n*n%t,e=r*r*n%t,i=ft(e,lc,t)*e%t,s=ft(i,lc,t)*e%t,a=ft(s,Sa,t)*r%t,o=ft(a,Ph,t)*a%t,c=ft(o,Dh,t)*o%t,u=ft(c,yc,t)*c%t,h=ft(u,xh,t)*u%t,l=ft(h,yc,t)*c%t,y=ft(l,Sa,t)*r%t,g=ft(y,Uh,t)*n%t;return ft(g,Qh,t)*y%t}function T0(n){return n[0]&=252,n[55]|=128,n[56]=0,n}function Mh(n,t){const r=Or.p,e=St(n*n*t,r),i=St(e*n,r),s=St(i*e*t,r),a=St(i*R0(s),r),o=St(a*a,r);return{isValid:St(o*t,r)===n,value:a}}const Rh=Xt(Or.p,{BITS:456,isLE:!0}),gc=Xt(Or.n,{BITS:456,isLE:!0});function Th(n,t,r){if(t.length>255)throw Error("context must be smaller than 255, got: "+t.length);return le((e="SigEd448",Uint8Array.from(e,((i,s)=>{const a=i.charCodeAt(0);if(i.length!==1||a>127)throw Error(`string contains non-ASCII character "${e[s]}" with code ${a} at position ${s}`);return a}))),new Uint8Array([r?1:0,t.length]),t,n);var e}const Fh=(function(n){const{CURVE:t,curveOpts:r,hash:e,eddsaOpts:i}=(function(s){const a={a:s.a,d:s.d,p:s.Fp.ORDER,n:s.n,h:s.h,Gx:s.Gx,Gy:s.Gy},o={Fp:s.Fp,Fn:Xt(a.n,s.nBitLength,!0),uvRatio:s.uvRatio},c={randomBytes:s.randomBytes,adjustScalarBytes:s.adjustScalarBytes,domain:s.domain,prehash:s.prehash,mapToCurve:s.mapToCurve};return{CURVE:a,curveOpts:o,hash:s.hash,eddsaOpts:c}})(n);return(function(s,a){const o=a.Point;return Object.assign({},a,{ExtendedPoint:o,CURVE:s,nBitLength:o.Fn.BITS,nByteLength:o.Fn.BYTES})})(n,Sh(M0(t,r),e,i))})({...Or,Fp:Rh,Fn:gc,nBitLength:gc.BITS,hash:Ch,adjustScalarBytes:T0,domain:Th,uvRatio:Mh});M0(Kh);const Lh=(()=>{const n=Or.p;return Bh({P:n,type:"x448",powPminus2:t=>St(ft(R0(t),Sa,n)*t,n),adjustScalarBytes:T0})})(),Ba={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Nh={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},pc=BigInt(2);const Ka=Xt(Ba.p,{sqrt:function(n){const t=Ba.p,r=BigInt(3),e=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),o=BigInt(44),c=BigInt(88),u=n*n*n%t,h=u*u*n%t,l=ft(h,r,t)*h%t,y=ft(l,r,t)*h%t,g=ft(y,pc,t)*u%t,p=ft(g,i,t)*g%t,A=ft(p,s,t)*p%t,w=ft(A,o,t)*A%t,b=ft(w,c,t)*w%t,v=ft(b,o,t)*A%t,k=ft(v,r,t)*h%t,m=ft(k,a,t)*p%t,C=ft(m,e,t)*u%t,D=ft(C,pc,t);if(!Ka.eql(Ka.sqr(D),n))throw Error("Cannot find square root");return D}}),Oh=Nr({...Ba,Fp:Ka,lowS:!0,endo:Nh},no),F0=no,Hh=th,dc=Xt(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")),zh=Nr({a:dc.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")),b:BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"),Fp:dc,n:BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"),Gx:BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"),Gy:BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"),h:BigInt(1),lowS:!1},F0),L0=g0,N0=p0,Ac=Xt(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")),Gh=Nr({a:Ac.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")),b:BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"),Fp:Ac,n:BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"),Gx:BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"),Gy:BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"),h:BigInt(1),lowS:!1},N0),wc=Xt(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")),jh=Nr({a:wc.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")),b:BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"),Fp:wc,n:BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"),Gx:BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"),Gy:BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"),h:BigInt(1),lowS:!1},L0),Vh=new Map(Object.entries({nistP256:hh,nistP384:fh,nistP521:lh,brainpoolP256r1:zh,brainpoolP384r1:Gh,brainpoolP512r1:jh,secp256k1:Oh,x448:Lh,ed448:Fh}));var qh=Object.freeze({__proto__:null,nobleCurves:Vh});const Kn=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),ir=new Uint32Array(80);class Yh extends ii{constructor(){super(64,20,8,!1),this.A=0|Kn[0],this.B=0|Kn[1],this.C=0|Kn[2],this.D=0|Kn[3],this.E=0|Kn[4]}get(){const{A:t,B:r,C:e,D:i,E:s}=this;return[t,r,e,i,s]}set(t,r,e,i,s){this.A=0|t,this.B=0|r,this.C=0|e,this.D=0|i,this.E=0|s}process(t,r){for(let c=0;c<16;c++,r+=4)ir[c]=t.getUint32(r,!1);for(let c=16;c<80;c++)ir[c]=hr(ir[c-3]^ir[c-8]^ir[c-14]^ir[c-16],1);let{A:e,B:i,C:s,D:a,E:o}=this;for(let c=0;c<80;c++){let u,h;c<20?(u=c0(i,s,a),h=1518500249):c<40?(u=i^s^a,h=1859775393):c<60?(u=u0(i,s,a),h=2400959708):(u=i^s^a,h=3395469782);const l=hr(e,5)+u+o+h+ir[c]|0;o=a,a=s,s=hr(i,30),i=e,e=l}e=e+this.A|0,i=i+this.B|0,s=s+this.C|0,a=a+this.D|0,o=o+this.E|0,this.set(e,i,s,a,o)}roundClean(){ce(ir)}destroy(){this.set(0,0,0,0,0),ce(this.buffer)}}const Zh=We((()=>new Yh)),Jh=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),O0=Uint8Array.from(Array(16).fill(0).map(((n,t)=>t))),Xh=O0.map((n=>(9*n+5)%16)),H0=(()=>{const n=[[O0],[Xh]];for(let t=0;t<4;t++)for(let r of n)r.push(r[t].map((e=>Jh[e])));return n})(),z0=H0[0],G0=H0[1],j0=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((n=>Uint8Array.from(n))),Wh=z0.map(((n,t)=>n.map((r=>j0[t][r])))),_h=G0.map(((n,t)=>n.map((r=>j0[t][r])))),$h=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),t5=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function mc(n,t,r,e){return n===0?t^r^e:n===1?t&r|~t&e:n===2?(t|~r)^e:n===3?t&e|r&~e:t^(r|~e)}const di=new Uint32Array(16);class e5 extends ii{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:r,h2:e,h3:i,h4:s}=this;return[t,r,e,i,s]}set(t,r,e,i,s){this.h0=0|t,this.h1=0|r,this.h2=0|e,this.h3=0|i,this.h4=0|s}process(t,r){for(let g=0;g<16;g++,r+=4)di[g]=t.getUint32(r,!0);let e=0|this.h0,i=e,s=0|this.h1,a=s,o=0|this.h2,c=o,u=0|this.h3,h=u,l=0|this.h4,y=l;for(let g=0;g<5;g++){const p=4-g,A=$h[g],w=t5[g],b=z0[g],v=G0[g],k=Wh[g],m=_h[g];for(let C=0;C<16;C++){const D=hr(e+mc(g,s,o,u)+di[b[C]]+A,k[C])+l|0;e=l,l=u,u=0|hr(o,10),o=s,s=D}for(let C=0;C<16;C++){const D=hr(i+mc(p,a,c,h)+di[v[C]]+w,m[C])+y|0;i=y,y=h,h=0|hr(c,10),c=a,a=D}}this.set(this.h1+o+h|0,this.h2+u+y|0,this.h3+l+i|0,this.h4+e+a|0,this.h0+s+c|0)}roundClean(){ce(di)}destroy(){this.destroyed=!0,ce(this.buffer),this.set(0,0,0,0,0)}}const r5=Zh,n5=We((()=>new e5)),i5=Array.from({length:64},((n,t)=>Math.floor(2**32*Math.abs(Math.sin(t+1))))),bc=(n,t,r)=>n&t^~n&r,Ai=new Uint32Array([1732584193,4023233417,2562383102,271733878]),zs=new Uint32Array(16);class s5 extends ii{constructor(){super(64,16,8,!0),this.A=0|Ai[0],this.B=0|Ai[1],this.C=0|Ai[2],this.D=0|Ai[3]}get(){const{A:t,B:r,C:e,D:i}=this;return[t,r,e,i]}set(t,r,e,i){this.A=0|t,this.B=0|r,this.C=0|e,this.D=0|i}process(t,r){for(let o=0;o<16;o++,r+=4)zs[o]=t.getUint32(r,!0);let{A:e,B:i,C:s,D:a}=this;for(let o=0;o<64;o++){let c,u,h;o<16?(c=bc(i,s,a),u=o,h=[7,12,17,22]):o<32?(c=bc(a,i,s),u=(5*o+1)%16,h=[5,9,14,20]):o<48?(c=i^s^a,u=(3*o+5)%16,h=[4,11,16,23]):(c=s^(i|~a),u=7*o%16,h=[6,10,15,21]),c=c+e+i5[o]+zs[u],e=a,a=s,s=i,i+=hr(c,h[o%4])}e=e+this.A|0,i=i+this.B|0,s=s+this.C|0,a=a+this.D|0,this.set(e,i,s,a)}roundClean(){zs.fill(0)}destroy(){this.set(0,0,0,0),this.buffer.fill(0)}}const a5=new Map(Object.entries({md5:Tu((()=>new s5)),sha1:r5,sha224:Hh,sha256:F0,sha384:N0,sha512:L0,sha3_256:bh,sha3_512:kh,ripemd160:n5}));var o5=Object.freeze({__proto__:null,nobleHashes:a5});const Gs=typeof Lt=="object"&&"crypto"in Lt?Lt.crypto:void 0,Gt={};var Y=function(n){var t,r=new Float64Array(16);if(n)for(t=0;t<n.length;t++)r[t]=n[t];return r},Ca=function(){throw Error("no PRNG")},V0=new Uint8Array(32);V0[0]=9;var Ua=Y(),Ji=Y([1]),c5=Y([56129,1]),u5=Y([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),h5=Y([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),kc=Y([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),Ec=Y([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),f5=Y([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function vc(n,t,r,e){n[t]=r>>24&255,n[t+1]=r>>16&255,n[t+2]=r>>8&255,n[t+3]=255&r,n[t+4]=e>>24&255,n[t+5]=e>>16&255,n[t+6]=e>>8&255,n[t+7]=255&e}function q0(n,t,r,e){return(function(i,s,a,o,c){var u,h=0;for(u=0;u<c;u++)h|=i[s+u]^a[o+u];return(1&h-1>>>8)-1})(n,t,r,e,32)}function fr(n,t){var r;for(r=0;r<16;r++)n[r]=0|t[r]}function js(n){var t,r,e=1;for(t=0;t<16;t++)r=n[t]+e+65535,e=Math.floor(r/65536),n[t]=r-65536*e;n[0]+=e-1+37*(e-1)}function tn(n,t,r){for(var e,i=~(r-1),s=0;s<16;s++)e=i&(n[s]^t[s]),n[s]^=e,t[s]^=e}function Xn(n,t){var r,e,i,s=Y(),a=Y();for(r=0;r<16;r++)a[r]=t[r];for(js(a),js(a),js(a),e=0;e<2;e++){for(s[0]=a[0]-65517,r=1;r<15;r++)s[r]=a[r]-65535-(s[r-1]>>16&1),s[r-1]&=65535;s[15]=a[15]-32767-(s[14]>>16&1),i=s[15]>>16&1,s[14]&=65535,tn(a,s,1-i)}for(r=0;r<16;r++)n[2*r]=255&a[r],n[2*r+1]=a[r]>>8}function Ic(n,t){var r=new Uint8Array(32),e=new Uint8Array(32);return Xn(r,n),Xn(e,t),q0(r,0,e,0)}function Y0(n){var t=new Uint8Array(32);return Xn(t,n),1&t[0]}function Z0(n,t){var r;for(r=0;r<16;r++)n[r]=t[2*r]+(t[2*r+1]<<8);n[15]&=32767}function Se(n,t,r){for(var e=0;e<16;e++)n[e]=t[e]+r[e]}function Ce(n,t,r){for(var e=0;e<16;e++)n[e]=t[e]-r[e]}function et(n,t,r){var e,i,s=0,a=0,o=0,c=0,u=0,h=0,l=0,y=0,g=0,p=0,A=0,w=0,b=0,v=0,k=0,m=0,C=0,D=0,P=0,S=0,E=0,K=0,I=0,B=0,U=0,x=0,M=0,Q=0,R=0,N=0,T=0,F=r[0],z=r[1],L=r[2],O=r[3],H=r[4],j=r[5],V=r[6],J=r[7],q=r[8],$=r[9],_=r[10],nt=r[11],W=r[12],pt=r[13],At=r[14],dt=r[15];s+=(e=t[0])*F,a+=e*z,o+=e*L,c+=e*O,u+=e*H,h+=e*j,l+=e*V,y+=e*J,g+=e*q,p+=e*$,A+=e*_,w+=e*nt,b+=e*W,v+=e*pt,k+=e*At,m+=e*dt,a+=(e=t[1])*F,o+=e*z,c+=e*L,u+=e*O,h+=e*H,l+=e*j,y+=e*V,g+=e*J,p+=e*q,A+=e*$,w+=e*_,b+=e*nt,v+=e*W,k+=e*pt,m+=e*At,C+=e*dt,o+=(e=t[2])*F,c+=e*z,u+=e*L,h+=e*O,l+=e*H,y+=e*j,g+=e*V,p+=e*J,A+=e*q,w+=e*$,b+=e*_,v+=e*nt,k+=e*W,m+=e*pt,C+=e*At,D+=e*dt,c+=(e=t[3])*F,u+=e*z,h+=e*L,l+=e*O,y+=e*H,g+=e*j,p+=e*V,A+=e*J,w+=e*q,b+=e*$,v+=e*_,k+=e*nt,m+=e*W,C+=e*pt,D+=e*At,P+=e*dt,u+=(e=t[4])*F,h+=e*z,l+=e*L,y+=e*O,g+=e*H,p+=e*j,A+=e*V,w+=e*J,b+=e*q,v+=e*$,k+=e*_,m+=e*nt,C+=e*W,D+=e*pt,P+=e*At,S+=e*dt,h+=(e=t[5])*F,l+=e*z,y+=e*L,g+=e*O,p+=e*H,A+=e*j,w+=e*V,b+=e*J,v+=e*q,k+=e*$,m+=e*_,C+=e*nt,D+=e*W,P+=e*pt,S+=e*At,E+=e*dt,l+=(e=t[6])*F,y+=e*z,g+=e*L,p+=e*O,A+=e*H,w+=e*j,b+=e*V,v+=e*J,k+=e*q,m+=e*$,C+=e*_,D+=e*nt,P+=e*W,S+=e*pt,E+=e*At,K+=e*dt,y+=(e=t[7])*F,g+=e*z,p+=e*L,A+=e*O,w+=e*H,b+=e*j,v+=e*V,k+=e*J,m+=e*q,C+=e*$,D+=e*_,P+=e*nt,S+=e*W,E+=e*pt,K+=e*At,I+=e*dt,g+=(e=t[8])*F,p+=e*z,A+=e*L,w+=e*O,b+=e*H,v+=e*j,k+=e*V,m+=e*J,C+=e*q,D+=e*$,P+=e*_,S+=e*nt,E+=e*W,K+=e*pt,I+=e*At,B+=e*dt,p+=(e=t[9])*F,A+=e*z,w+=e*L,b+=e*O,v+=e*H,k+=e*j,m+=e*V,C+=e*J,D+=e*q,P+=e*$,S+=e*_,E+=e*nt,K+=e*W,I+=e*pt,B+=e*At,U+=e*dt,A+=(e=t[10])*F,w+=e*z,b+=e*L,v+=e*O,k+=e*H,m+=e*j,C+=e*V,D+=e*J,P+=e*q,S+=e*$,E+=e*_,K+=e*nt,I+=e*W,B+=e*pt,U+=e*At,x+=e*dt,w+=(e=t[11])*F,b+=e*z,v+=e*L,k+=e*O,m+=e*H,C+=e*j,D+=e*V,P+=e*J,S+=e*q,E+=e*$,K+=e*_,I+=e*nt,B+=e*W,U+=e*pt,x+=e*At,M+=e*dt,b+=(e=t[12])*F,v+=e*z,k+=e*L,m+=e*O,C+=e*H,D+=e*j,P+=e*V,S+=e*J,E+=e*q,K+=e*$,I+=e*_,B+=e*nt,U+=e*W,x+=e*pt,M+=e*At,Q+=e*dt,v+=(e=t[13])*F,k+=e*z,m+=e*L,C+=e*O,D+=e*H,P+=e*j,S+=e*V,E+=e*J,K+=e*q,I+=e*$,B+=e*_,U+=e*nt,x+=e*W,M+=e*pt,Q+=e*At,R+=e*dt,k+=(e=t[14])*F,m+=e*z,C+=e*L,D+=e*O,P+=e*H,S+=e*j,E+=e*V,K+=e*J,I+=e*q,B+=e*$,U+=e*_,x+=e*nt,M+=e*W,Q+=e*pt,R+=e*At,N+=e*dt,m+=(e=t[15])*F,a+=38*(D+=e*L),o+=38*(P+=e*O),c+=38*(S+=e*H),u+=38*(E+=e*j),h+=38*(K+=e*V),l+=38*(I+=e*J),y+=38*(B+=e*q),g+=38*(U+=e*$),p+=38*(x+=e*_),A+=38*(M+=e*nt),w+=38*(Q+=e*W),b+=38*(R+=e*pt),v+=38*(N+=e*At),k+=38*(T+=e*dt),s=(e=(s+=38*(C+=e*z))+(i=1)+65535)-65536*(i=Math.floor(e/65536)),a=(e=a+i+65535)-65536*(i=Math.floor(e/65536)),o=(e=o+i+65535)-65536*(i=Math.floor(e/65536)),c=(e=c+i+65535)-65536*(i=Math.floor(e/65536)),u=(e=u+i+65535)-65536*(i=Math.floor(e/65536)),h=(e=h+i+65535)-65536*(i=Math.floor(e/65536)),l=(e=l+i+65535)-65536*(i=Math.floor(e/65536)),y=(e=y+i+65535)-65536*(i=Math.floor(e/65536)),g=(e=g+i+65535)-65536*(i=Math.floor(e/65536)),p=(e=p+i+65535)-65536*(i=Math.floor(e/65536)),A=(e=A+i+65535)-65536*(i=Math.floor(e/65536)),w=(e=w+i+65535)-65536*(i=Math.floor(e/65536)),b=(e=b+i+65535)-65536*(i=Math.floor(e/65536)),v=(e=v+i+65535)-65536*(i=Math.floor(e/65536)),k=(e=k+i+65535)-65536*(i=Math.floor(e/65536)),m=(e=m+i+65535)-65536*(i=Math.floor(e/65536)),s=(e=(s+=i-1+37*(i-1))+(i=1)+65535)-65536*(i=Math.floor(e/65536)),a=(e=a+i+65535)-65536*(i=Math.floor(e/65536)),o=(e=o+i+65535)-65536*(i=Math.floor(e/65536)),c=(e=c+i+65535)-65536*(i=Math.floor(e/65536)),u=(e=u+i+65535)-65536*(i=Math.floor(e/65536)),h=(e=h+i+65535)-65536*(i=Math.floor(e/65536)),l=(e=l+i+65535)-65536*(i=Math.floor(e/65536)),y=(e=y+i+65535)-65536*(i=Math.floor(e/65536)),g=(e=g+i+65535)-65536*(i=Math.floor(e/65536)),p=(e=p+i+65535)-65536*(i=Math.floor(e/65536)),A=(e=A+i+65535)-65536*(i=Math.floor(e/65536)),w=(e=w+i+65535)-65536*(i=Math.floor(e/65536)),b=(e=b+i+65535)-65536*(i=Math.floor(e/65536)),v=(e=v+i+65535)-65536*(i=Math.floor(e/65536)),k=(e=k+i+65535)-65536*(i=Math.floor(e/65536)),m=(e=m+i+65535)-65536*(i=Math.floor(e/65536)),s+=i-1+37*(i-1),n[0]=s,n[1]=a,n[2]=o,n[3]=c,n[4]=u,n[5]=h,n[6]=l,n[7]=y,n[8]=g,n[9]=p,n[10]=A,n[11]=w,n[12]=b,n[13]=v,n[14]=k,n[15]=m}function ye(n,t){et(n,t,t)}function J0(n,t){var r,e=Y();for(r=0;r<16;r++)e[r]=t[r];for(r=253;r>=0;r--)ye(e,e),r!==2&&r!==4&&et(e,e,t);for(r=0;r<16;r++)n[r]=e[r]}function X0(n,t,r){var e,i,s=new Uint8Array(32),a=new Float64Array(80),o=Y(),c=Y(),u=Y(),h=Y(),l=Y(),y=Y();for(i=0;i<31;i++)s[i]=t[i];for(s[31]=127&t[31]|64,s[0]&=248,Z0(a,r),i=0;i<16;i++)c[i]=a[i],h[i]=o[i]=u[i]=0;for(o[0]=h[0]=1,i=254;i>=0;--i)tn(o,c,e=s[i>>>3]>>>(7&i)&1),tn(u,h,e),Se(l,o,u),Ce(o,o,u),Se(u,c,h),Ce(c,c,h),ye(h,l),ye(y,o),et(o,u,o),et(u,c,l),Se(l,o,u),Ce(o,o,u),ye(c,o),Ce(u,h,y),et(o,u,c5),Se(o,o,h),et(u,u,o),et(o,h,y),et(h,c,a),ye(c,l),tn(o,c,e),tn(u,h,e);for(i=0;i<16;i++)a[i+16]=o[i],a[i+32]=u[i],a[i+48]=c[i],a[i+64]=h[i];var g=a.subarray(32),p=a.subarray(16);return J0(g,g),et(p,p,g),Xn(n,p),0}function Sc(n,t){return X0(n,t,V0)}var Bc=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function Kc(n,t,r,e){for(var i,s,a,o,c,u,h,l,y,g,p,A,w,b,v,k,m,C,D,P,S,E,K,I,B,U,x=new Int32Array(16),M=new Int32Array(16),Q=n[0],R=n[1],N=n[2],T=n[3],F=n[4],z=n[5],L=n[6],O=n[7],H=t[0],j=t[1],V=t[2],J=t[3],q=t[4],$=t[5],_=t[6],nt=t[7],W=0;e>=128;){for(D=0;D<16;D++)P=8*D+W,x[D]=r[P+0]<<24|r[P+1]<<16|r[P+2]<<8|r[P+3],M[D]=r[P+4]<<24|r[P+5]<<16|r[P+6]<<8|r[P+7];for(D=0;D<80;D++)if(i=Q,s=R,a=N,o=T,c=F,u=z,h=L,y=H,g=j,p=V,A=J,w=q,b=$,v=_,K=65535&(E=nt),I=E>>>16,B=65535&(S=O),U=S>>>16,K+=65535&(E=(q>>>14|F<<18)^(q>>>18|F<<14)^(F>>>9|q<<23)),I+=E>>>16,B+=65535&(S=(F>>>14|q<<18)^(F>>>18|q<<14)^(q>>>9|F<<23)),U+=S>>>16,K+=65535&(E=q&$^~q&_),I+=E>>>16,B+=65535&(S=F&z^~F&L),U+=S>>>16,K+=65535&(E=Bc[2*D+1]),I+=E>>>16,B+=65535&(S=Bc[2*D]),U+=S>>>16,S=x[D%16],I+=(E=M[D%16])>>>16,B+=65535&S,U+=S>>>16,B+=(I+=(K+=65535&E)>>>16)>>>16,K=65535&(E=C=65535&K|I<<16),I=E>>>16,B=65535&(S=m=65535&B|(U+=B>>>16)<<16),U=S>>>16,K+=65535&(E=(H>>>28|Q<<4)^(Q>>>2|H<<30)^(Q>>>7|H<<25)),I+=E>>>16,B+=65535&(S=(Q>>>28|H<<4)^(H>>>2|Q<<30)^(H>>>7|Q<<25)),U+=S>>>16,I+=(E=H&j^H&V^j&V)>>>16,B+=65535&(S=Q&R^Q&N^R&N),U+=S>>>16,l=65535&(B+=(I+=(K+=65535&E)>>>16)>>>16)|(U+=B>>>16)<<16,k=65535&K|I<<16,K=65535&(E=A),I=E>>>16,B=65535&(S=o),U=S>>>16,I+=(E=C)>>>16,B+=65535&(S=m),U+=S>>>16,R=i,N=s,T=a,F=o=65535&(B+=(I+=(K+=65535&E)>>>16)>>>16)|(U+=B>>>16)<<16,z=c,L=u,O=h,Q=l,j=y,V=g,J=p,q=A=65535&K|I<<16,$=w,_=b,nt=v,H=k,D%16==15)for(P=0;P<16;P++)S=x[P],K=65535&(E=M[P]),I=E>>>16,B=65535&S,U=S>>>16,S=x[(P+9)%16],K+=65535&(E=M[(P+9)%16]),I+=E>>>16,B+=65535&S,U+=S>>>16,m=x[(P+1)%16],K+=65535&(E=((C=M[(P+1)%16])>>>1|m<<31)^(C>>>8|m<<24)^(C>>>7|m<<25)),I+=E>>>16,B+=65535&(S=(m>>>1|C<<31)^(m>>>8|C<<24)^m>>>7),U+=S>>>16,m=x[(P+14)%16],I+=(E=((C=M[(P+14)%16])>>>19|m<<13)^(m>>>29|C<<3)^(C>>>6|m<<26))>>>16,B+=65535&(S=(m>>>19|C<<13)^(C>>>29|m<<3)^m>>>6),U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,x[P]=65535&B|U<<16,M[P]=65535&K|I<<16;K=65535&(E=H),I=E>>>16,B=65535&(S=Q),U=S>>>16,S=n[0],I+=(E=t[0])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[0]=Q=65535&B|U<<16,t[0]=H=65535&K|I<<16,K=65535&(E=j),I=E>>>16,B=65535&(S=R),U=S>>>16,S=n[1],I+=(E=t[1])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[1]=R=65535&B|U<<16,t[1]=j=65535&K|I<<16,K=65535&(E=V),I=E>>>16,B=65535&(S=N),U=S>>>16,S=n[2],I+=(E=t[2])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[2]=N=65535&B|U<<16,t[2]=V=65535&K|I<<16,K=65535&(E=J),I=E>>>16,B=65535&(S=T),U=S>>>16,S=n[3],I+=(E=t[3])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[3]=T=65535&B|U<<16,t[3]=J=65535&K|I<<16,K=65535&(E=q),I=E>>>16,B=65535&(S=F),U=S>>>16,S=n[4],I+=(E=t[4])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[4]=F=65535&B|U<<16,t[4]=q=65535&K|I<<16,K=65535&(E=$),I=E>>>16,B=65535&(S=z),U=S>>>16,S=n[5],I+=(E=t[5])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[5]=z=65535&B|U<<16,t[5]=$=65535&K|I<<16,K=65535&(E=_),I=E>>>16,B=65535&(S=L),U=S>>>16,S=n[6],I+=(E=t[6])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[6]=L=65535&B|U<<16,t[6]=_=65535&K|I<<16,K=65535&(E=nt),I=E>>>16,B=65535&(S=O),U=S>>>16,S=n[7],I+=(E=t[7])>>>16,B+=65535&S,U+=S>>>16,U+=(B+=(I+=(K+=65535&E)>>>16)>>>16)>>>16,n[7]=O=65535&B|U<<16,t[7]=nt=65535&K|I<<16,W+=128,e-=128}return e}function Rn(n,t,r){var e,i=new Int32Array(8),s=new Int32Array(8),a=new Uint8Array(256),o=r;for(i[0]=1779033703,i[1]=3144134277,i[2]=1013904242,i[3]=2773480762,i[4]=1359893119,i[5]=2600822924,i[6]=528734635,i[7]=1541459225,s[0]=4089235720,s[1]=2227873595,s[2]=4271175723,s[3]=1595750129,s[4]=2917565137,s[5]=725511199,s[6]=4215389547,s[7]=327033209,Kc(i,s,t,r),r%=128,e=0;e<r;e++)a[e]=t[o-r+e];for(a[r]=128,a[(r=256-128*(r<112?1:0))-9]=0,vc(a,r-8,o/536870912|0,o<<3),Kc(i,s,a,r),e=0;e<8;e++)vc(n,8*e,i[e],s[e]);return 0}function Pa(n,t){var r=Y(),e=Y(),i=Y(),s=Y(),a=Y(),o=Y(),c=Y(),u=Y(),h=Y();Ce(r,n[1],n[0]),Ce(h,t[1],t[0]),et(r,r,h),Se(e,n[0],n[1]),Se(h,t[0],t[1]),et(e,e,h),et(i,n[3],t[3]),et(i,i,h5),et(s,n[2],t[2]),Se(s,s,s),Ce(a,e,r),Ce(o,s,i),Se(c,s,i),Se(u,e,r),et(n[0],a,o),et(n[1],u,c),et(n[2],c,o),et(n[3],a,u)}function Cc(n,t,r){var e;for(e=0;e<4;e++)tn(n[e],t[e],r)}function Da(n,t){var r=Y(),e=Y(),i=Y();J0(i,t[2]),et(r,t[0],i),et(e,t[1],i),Xn(n,e),n[31]^=Y0(r)<<7}function W0(n,t,r){var e,i;for(fr(n[0],Ua),fr(n[1],Ji),fr(n[2],Ji),fr(n[3],Ua),i=255;i>=0;--i)Cc(n,t,e=r[i/8|0]>>(7&i)&1),Pa(t,n),Pa(n,n),Cc(n,t,e)}function xa(n,t){var r=[Y(),Y(),Y(),Y()];fr(r[0],kc),fr(r[1],Ec),fr(r[2],Ji),et(r[3],kc,Ec),W0(n,r,t)}function Uc(n,t,r){var e,i=new Uint8Array(64),s=[Y(),Y(),Y(),Y()];for(r||Ca(t,32),Rn(i,t,32),i[0]&=248,i[31]&=127,i[31]|=64,xa(s,i),Da(n,s),e=0;e<32;e++)t[e+32]=n[e];return 0}var Vs=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function _0(n,t){var r,e,i,s;for(e=63;e>=32;--e){for(r=0,i=e-32,s=e-12;i<s;++i)t[i]+=r-16*t[e]*Vs[i-(e-32)],r=Math.floor((t[i]+128)/256),t[i]-=256*r;t[i]+=r,t[e]=0}for(r=0,i=0;i<32;i++)t[i]+=r-(t[31]>>4)*Vs[i],r=t[i]>>8,t[i]&=255;for(i=0;i<32;i++)t[i]-=r*Vs[i];for(e=0;e<32;e++)t[e+1]+=t[e]>>8,n[e]=255&t[e]}function qs(n){var t,r=new Float64Array(64);for(t=0;t<64;t++)r[t]=n[t];for(t=0;t<64;t++)n[t]=0;_0(n,r)}function l5(n,t){var r=Y(),e=Y(),i=Y(),s=Y(),a=Y(),o=Y(),c=Y();return fr(n[2],Ji),Z0(n[1],t),ye(i,n[1]),et(s,i,u5),Ce(i,i,n[2]),Se(s,n[2],s),ye(a,s),ye(o,a),et(c,o,a),et(r,c,i),et(r,r,s),(function(u,h){var l,y=Y();for(l=0;l<16;l++)y[l]=h[l];for(l=250;l>=0;l--)ye(y,y),l!==1&&et(y,y,h);for(l=0;l<16;l++)u[l]=y[l]})(r,r),et(r,r,i),et(r,r,s),et(r,r,s),et(n[0],r,s),ye(e,n[0]),et(e,e,s),Ic(e,i)&&et(n[0],n[0],f5),ye(e,n[0]),et(e,e,s),Ic(e,i)?-1:(Y0(n[0])===t[31]>>7&&Ce(n[0],Ua,n[0]),et(n[3],n[0],n[1]),0)}var vr=64;function qr(){for(var n=0;n<arguments.length;n++)if(!(arguments[n]instanceof Uint8Array))throw new TypeError("unexpected type, use Uint8Array")}Gt.scalarMult=function(n,t){if(qr(n,t),n.length!==32)throw Error("bad n size");if(t.length!==32)throw Error("bad p size");var r=new Uint8Array(32);return X0(r,n,t),r},Gt.box={},Gt.box.keyPair=function(){var n=new Uint8Array(32),t=new Uint8Array(32);return(function(r,e){Ca(e,32),Sc(r,e)})(n,t),{publicKey:n,secretKey:t}},Gt.box.keyPair.fromSecretKey=function(n){if(qr(n),n.length!==32)throw Error("bad secret key size");var t=new Uint8Array(32);return Sc(t,n),{publicKey:t,secretKey:new Uint8Array(n)}},Gt.sign=function(n,t){if(qr(n,t),t.length!==64)throw Error("bad secret key size");var r=new Uint8Array(vr+n.length);return(function(e,i,s,a){var o,c,u=new Uint8Array(64),h=new Uint8Array(64),l=new Uint8Array(64),y=new Float64Array(64),g=[Y(),Y(),Y(),Y()];for(Rn(u,a,32),u[0]&=248,u[31]&=127,u[31]|=64,o=0;o<s;o++)e[64+o]=i[o];for(o=0;o<32;o++)e[32+o]=u[32+o];for(Rn(l,e.subarray(32),s+32),qs(l),xa(g,l),Da(e,g),o=32;o<64;o++)e[o]=a[o];for(Rn(h,e,s+64),qs(h),o=0;o<64;o++)y[o]=0;for(o=0;o<32;o++)y[o]=l[o];for(o=0;o<32;o++)for(c=0;c<32;c++)y[o+c]+=h[o]*u[c];_0(e.subarray(32),y)})(r,n,n.length,t),r},Gt.sign.detached=function(n,t){for(var r=Gt.sign(n,t),e=new Uint8Array(vr),i=0;i<e.length;i++)e[i]=r[i];return e},Gt.sign.detached.verify=function(n,t,r){if(qr(n,t,r),t.length!==vr)throw Error("bad signature size");if(r.length!==32)throw Error("bad public key size");var e,i=new Uint8Array(vr+n.length),s=new Uint8Array(vr+n.length);for(e=0;e<vr;e++)i[e]=t[e];for(e=0;e<n.length;e++)i[e+vr]=n[e];return(function(a,o,c,u){var h,l=new Uint8Array(32),y=new Uint8Array(64),g=[Y(),Y(),Y(),Y()],p=[Y(),Y(),Y(),Y()];if(c<64||l5(p,u))return-1;for(h=0;h<c;h++)a[h]=o[h];for(h=0;h<32;h++)a[h+32]=u[h];if(Rn(y,a,c),qs(y),W0(g,p,y),xa(p,o.subarray(32)),Pa(g,p),Da(l,g),c-=64,q0(o,0,l,0)){for(h=0;h<c;h++)a[h]=0;return-1}for(h=0;h<c;h++)a[h]=o[h+64];return c})(s,i,i.length,r)>=0},Gt.sign.keyPair=function(){var n=new Uint8Array(32),t=new Uint8Array(64);return Uc(n,t),{publicKey:n,secretKey:t}},Gt.sign.keyPair.fromSecretKey=function(n){if(qr(n),n.length!==64)throw Error("bad secret key size");for(var t=new Uint8Array(32),r=0;r<t.length;r++)t[r]=n[32+r];return{publicKey:t,secretKey:new Uint8Array(n)}},Gt.sign.keyPair.fromSeed=function(n){if(qr(n),n.length!==32)throw Error("bad seed size");for(var t=new Uint8Array(32),r=new Uint8Array(64),e=0;e<32;e++)r[e]=n[e];return Uc(t,r,!0),{publicKey:t,secretKey:r}},Gt.setPRNG=function(n){Ca=n},(function(){Gs&&Gs.getRandomValues&&Gt.setPRNG((function(n,t){var r,e=new Uint8Array(t);for(r=0;r<t;r+=65536)Gs.getRandomValues(e.subarray(r,r+Math.min(t-r,65536)));for(r=0;r<t;r++)n[r]=e[r];(function(i){for(var s=0;s<i.length;s++)i[s]=0})(e)}))})();var Hr=Object.freeze({__proto__:null,default:Gt});function Ys(n,t,r,e,i,s){const a=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],o=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],c=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],u=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],h=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],l=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],y=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],g=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696];let p,A,w,b,v,k,m,C,D,P,S=0,E=t.length;const K=n.length===32?3:9;C=K===3?r?[0,32,2]:[30,-2,-2]:r?[0,32,2,62,30,-2,64,96,2]:[94,62,-2,32,64,2,30,-2,-2],r&&(t=(function(U){const x=8-U.length%8;let M;if(!(x<8)){if(x===8)return U;throw Error("des: invalid padding")}M=0;const Q=new Uint8Array(U.length+x);for(let R=0;R<U.length;R++)Q[R]=U[R];for(let R=0;R<x;R++)Q[U.length+R]=M;return Q})(t),E=t.length);let I=new Uint8Array(E),B=0;for(;S<E;){for(k=t[S++]<<24|t[S++]<<16|t[S++]<<8|t[S++],m=t[S++]<<24|t[S++]<<16|t[S++]<<8|t[S++],w=252645135&(k>>>4^m),m^=w,k^=w<<4,w=65535&(k>>>16^m),m^=w,k^=w<<16,w=858993459&(m>>>2^k),k^=w,m^=w<<2,w=16711935&(m>>>8^k),k^=w,m^=w<<8,w=1431655765&(k>>>1^m),m^=w,k^=w<<1,k=k<<1|k>>>31,m=m<<1|m>>>31,A=0;A<K;A+=3){for(D=C[A+1],P=C[A+2],p=C[A];p!==D;p+=P)b=m^n[p],v=(m>>>4|m<<28)^n[p+1],w=k,k=m,m=w^(o[b>>>24&63]|u[b>>>16&63]|l[b>>>8&63]|g[63&b]|a[v>>>24&63]|c[v>>>16&63]|h[v>>>8&63]|y[63&v]);w=k,k=m,m=w}k=k>>>1|k<<31,m=m>>>1|m<<31,w=1431655765&(k>>>1^m),m^=w,k^=w<<1,w=16711935&(m>>>8^k),k^=w,m^=w<<8,w=858993459&(m>>>2^k),k^=w,m^=w<<2,w=65535&(k>>>16^m),m^=w,k^=w<<16,w=252645135&(k>>>4^m),m^=w,k^=w<<4,I[B++]=k>>>24,I[B++]=k>>>16&255,I[B++]=k>>>8&255,I[B++]=255&k,I[B++]=m>>>24,I[B++]=m>>>16&255,I[B++]=m>>>8&255,I[B++]=255&m}return r||(I=(function(U){let x,M=null;if(x=0,!M){for(M=1;U[U.length-M]===x;)M++;M--}return U.subarray(0,U.length-M)})(I)),I}function Zs(n){const t=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],r=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],e=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],i=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],s=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],a=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],o=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],c=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],u=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],h=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],l=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],y=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],g=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],p=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],A=n.length>8?3:1,w=Array(32*A),b=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0];let v,k,m,C=0,D=0;for(let P=0;P<A;P++){let S=n[C++]<<24|n[C++]<<16|n[C++]<<8|n[C++],E=n[C++]<<24|n[C++]<<16|n[C++]<<8|n[C++];m=252645135&(S>>>4^E),E^=m,S^=m<<4,m=65535&(E>>>-16^S),S^=m,E^=m<<-16,m=858993459&(S>>>2^E),E^=m,S^=m<<2,m=65535&(E>>>-16^S),S^=m,E^=m<<-16,m=1431655765&(S>>>1^E),E^=m,S^=m<<1,m=16711935&(E>>>8^S),S^=m,E^=m<<8,m=1431655765&(S>>>1^E),E^=m,S^=m<<1,m=S<<8|E>>>20&240,S=E<<24|E<<8&16711680|E>>>8&65280|E>>>24&240,E=m;for(let K=0;K<16;K++)b[K]?(S=S<<2|S>>>26,E=E<<2|E>>>26):(S=S<<1|S>>>27,E=E<<1|E>>>27),S&=-15,E&=-15,v=t[S>>>28]|r[S>>>24&15]|e[S>>>20&15]|i[S>>>16&15]|s[S>>>12&15]|a[S>>>8&15]|o[S>>>4&15],k=c[E>>>28]|u[E>>>24&15]|h[E>>>20&15]|l[E>>>16&15]|y[E>>>12&15]|g[E>>>8&15]|p[E>>>4&15],m=65535&(k>>>16^v),w[D++]=v^m,w[D++]=k^m<<16}return w}function Tn(n){this.key=[];for(let t=0;t<3;t++)this.key.push(new Uint8Array(n.subarray(8*t,8*t+8)));this.encrypt=function(t){return Ys(Zs(this.key[2]),Ys(Zs(this.key[1]),Ys(Zs(this.key[0]),t,!0),!1),!0)}}function y5(){this.BlockSize=8,this.KeySize=16,this.setKey=function(a){if(this.masking=Array(16),this.rotate=Array(16),this.reset(),a.length!==this.KeySize)throw Error("CAST-128: keys must be 16 bytes");return this.keySchedule(a),!0},this.reset=function(){for(let a=0;a<16;a++)this.masking[a]=0,this.rotate[a]=0},this.getBlockSize=function(){return this.BlockSize},this.encrypt=function(a){const o=Array(a.length);for(let c=0;c<a.length;c+=8){let u,h=a[c]<<24|a[c+1]<<16|a[c+2]<<8|a[c+3],l=a[c+4]<<24|a[c+5]<<16|a[c+6]<<8|a[c+7];u=l,l=h^r(l,this.masking[0],this.rotate[0]),h=u,u=l,l=h^e(l,this.masking[1],this.rotate[1]),h=u,u=l,l=h^i(l,this.masking[2],this.rotate[2]),h=u,u=l,l=h^r(l,this.masking[3],this.rotate[3]),h=u,u=l,l=h^e(l,this.masking[4],this.rotate[4]),h=u,u=l,l=h^i(l,this.masking[5],this.rotate[5]),h=u,u=l,l=h^r(l,this.masking[6],this.rotate[6]),h=u,u=l,l=h^e(l,this.masking[7],this.rotate[7]),h=u,u=l,l=h^i(l,this.masking[8],this.rotate[8]),h=u,u=l,l=h^r(l,this.masking[9],this.rotate[9]),h=u,u=l,l=h^e(l,this.masking[10],this.rotate[10]),h=u,u=l,l=h^i(l,this.masking[11],this.rotate[11]),h=u,u=l,l=h^r(l,this.masking[12],this.rotate[12]),h=u,u=l,l=h^e(l,this.masking[13],this.rotate[13]),h=u,u=l,l=h^i(l,this.masking[14],this.rotate[14]),h=u,u=l,l=h^r(l,this.masking[15],this.rotate[15]),h=u,o[c]=l>>>24&255,o[c+1]=l>>>16&255,o[c+2]=l>>>8&255,o[c+3]=255&l,o[c+4]=h>>>24&255,o[c+5]=h>>>16&255,o[c+6]=h>>>8&255,o[c+7]=255&h}return o},this.decrypt=function(a){const o=Array(a.length);for(let c=0;c<a.length;c+=8){let u,h=a[c]<<24|a[c+1]<<16|a[c+2]<<8|a[c+3],l=a[c+4]<<24|a[c+5]<<16|a[c+6]<<8|a[c+7];u=l,l=h^r(l,this.masking[15],this.rotate[15]),h=u,u=l,l=h^i(l,this.masking[14],this.rotate[14]),h=u,u=l,l=h^e(l,this.masking[13],this.rotate[13]),h=u,u=l,l=h^r(l,this.masking[12],this.rotate[12]),h=u,u=l,l=h^i(l,this.masking[11],this.rotate[11]),h=u,u=l,l=h^e(l,this.masking[10],this.rotate[10]),h=u,u=l,l=h^r(l,this.masking[9],this.rotate[9]),h=u,u=l,l=h^i(l,this.masking[8],this.rotate[8]),h=u,u=l,l=h^e(l,this.masking[7],this.rotate[7]),h=u,u=l,l=h^r(l,this.masking[6],this.rotate[6]),h=u,u=l,l=h^i(l,this.masking[5],this.rotate[5]),h=u,u=l,l=h^e(l,this.masking[4],this.rotate[4]),h=u,u=l,l=h^r(l,this.masking[3],this.rotate[3]),h=u,u=l,l=h^i(l,this.masking[2],this.rotate[2]),h=u,u=l,l=h^e(l,this.masking[1],this.rotate[1]),h=u,u=l,l=h^r(l,this.masking[0],this.rotate[0]),h=u,o[c]=l>>>24&255,o[c+1]=l>>>16&255,o[c+2]=l>>>8&255,o[c+3]=255&l,o[c+4]=h>>>24&255,o[c+5]=h>>16&255,o[c+6]=h>>8&255,o[c+7]=255&h}return o};const n=[,,,,];n[0]=[,,,,],n[0][0]=[4,0,13,15,12,14,8],n[0][1]=[5,2,16,18,17,19,10],n[0][2]=[6,3,23,22,21,20,9],n[0][3]=[7,1,26,25,27,24,11],n[1]=[,,,,],n[1][0]=[0,6,21,23,20,22,16],n[1][1]=[1,4,0,2,1,3,18],n[1][2]=[2,5,7,6,5,4,17],n[1][3]=[3,7,10,9,11,8,19],n[2]=[,,,,],n[2][0]=[4,0,13,15,12,14,8],n[2][1]=[5,2,16,18,17,19,10],n[2][2]=[6,3,23,22,21,20,9],n[2][3]=[7,1,26,25,27,24,11],n[3]=[,,,,],n[3][0]=[0,6,21,23,20,22,16],n[3][1]=[1,4,0,2,1,3,18],n[3][2]=[2,5,7,6,5,4,17],n[3][3]=[3,7,10,9,11,8,19];const t=[,,,,];function r(a,o,c){const u=o+a,h=u<<c|u>>>32-c;return(s[0][h>>>24]^s[1][h>>>16&255])-s[2][h>>>8&255]+s[3][255&h]}function e(a,o,c){const u=o^a,h=u<<c|u>>>32-c;return s[0][h>>>24]-s[1][h>>>16&255]+s[2][h>>>8&255]^s[3][255&h]}function i(a,o,c){const u=o-a,h=u<<c|u>>>32-c;return(s[0][h>>>24]+s[1][h>>>16&255]^s[2][h>>>8&255])-s[3][255&h]}t[0]=[,,,,],t[0][0]=[24,25,23,22,18],t[0][1]=[26,27,21,20,22],t[0][2]=[28,29,19,18,25],t[0][3]=[30,31,17,16,28],t[1]=[,,,,],t[1][0]=[3,2,12,13,8],t[1][1]=[1,0,14,15,13],t[1][2]=[7,6,8,9,3],t[1][3]=[5,4,10,11,7],t[2]=[,,,,],t[2][0]=[19,18,28,29,25],t[2][1]=[17,16,30,31,28],t[2][2]=[23,22,24,25,18],t[2][3]=[21,20,26,27,22],t[3]=[,,,,],t[3][0]=[8,9,7,6,3],t[3][1]=[10,11,5,4,7],t[3][2]=[12,13,3,2,8],t[3][3]=[14,15,1,0,13],this.keySchedule=function(a){const o=[,,,,,,,,],c=Array(32);let u;for(let g=0;g<4;g++)u=4*g,o[g]=a[u]<<24|a[u+1]<<16|a[u+2]<<8|a[u+3];const h=[6,7,4,5];let l,y=0;for(let g=0;g<2;g++)for(let p=0;p<4;p++){for(u=0;u<4;u++){const A=n[p][u];l=o[A[1]],l^=s[4][o[A[2]>>>2]>>>24-8*(3&A[2])&255],l^=s[5][o[A[3]>>>2]>>>24-8*(3&A[3])&255],l^=s[6][o[A[4]>>>2]>>>24-8*(3&A[4])&255],l^=s[7][o[A[5]>>>2]>>>24-8*(3&A[5])&255],l^=s[h[u]][o[A[6]>>>2]>>>24-8*(3&A[6])&255],o[A[0]]=l}for(u=0;u<4;u++){const A=t[p][u];l=s[4][o[A[0]>>>2]>>>24-8*(3&A[0])&255],l^=s[5][o[A[1]>>>2]>>>24-8*(3&A[1])&255],l^=s[6][o[A[2]>>>2]>>>24-8*(3&A[2])&255],l^=s[7][o[A[3]>>>2]>>>24-8*(3&A[3])&255],l^=s[4+u][o[A[4]>>>2]>>>24-8*(3&A[4])&255],c[y]=l,y++}}for(let g=0;g<16;g++)this.masking[g]=c[g],this.rotate[g]=31&c[16+g]};const s=[,,,,,,,,];s[0]=[821772500,2678128395,1810681135,1059425402,505495343,2617265619,1610868032,3483355465,3218386727,2294005173,3791863952,2563806837,1852023008,365126098,3269944861,584384398,677919599,3229601881,4280515016,2002735330,1136869587,3744433750,2289869850,2731719981,2714362070,879511577,1639411079,575934255,717107937,2857637483,576097850,2731753936,1725645e3,2810460463,5111599,767152862,2543075244,1251459544,1383482551,3052681127,3089939183,3612463449,1878520045,1510570527,2189125840,2431448366,582008916,3163445557,1265446783,1354458274,3529918736,3202711853,3073581712,3912963487,3029263377,1275016285,4249207360,2905708351,3304509486,1442611557,3585198765,2712415662,2731849581,3248163920,2283946226,208555832,2766454743,1331405426,1447828783,3315356441,3108627284,2957404670,2981538698,3339933917,1669711173,286233437,1465092821,1782121619,3862771680,710211251,980974943,1651941557,430374111,2051154026,704238805,4128970897,3144820574,2857402727,948965521,3333752299,2227686284,718756367,2269778983,2731643755,718440111,2857816721,3616097120,1113355533,2478022182,410092745,1811985197,1944238868,2696854588,1415722873,1682284203,1060277122,1998114690,1503841958,82706478,2315155686,1068173648,845149890,2167947013,1768146376,1993038550,3566826697,3390574031,940016341,3355073782,2328040721,904371731,1205506512,4094660742,2816623006,825647681,85914773,2857843460,1249926541,1417871568,3287612,3211054559,3126306446,1975924523,1353700161,2814456437,2438597621,1800716203,722146342,2873936343,1151126914,4160483941,2877670899,458611604,2866078500,3483680063,770352098,2652916994,3367839148,3940505011,3585973912,3809620402,718646636,2504206814,2914927912,3631288169,2857486607,2860018678,575749918,2857478043,718488780,2069512688,3548183469,453416197,1106044049,3032691430,52586708,3378514636,3459808877,3211506028,1785789304,218356169,3571399134,3759170522,1194783844,1523787992,3007827094,1975193539,2555452411,1341901877,3045838698,3776907964,3217423946,2802510864,2889438986,1057244207,1636348243,3761863214,1462225785,2632663439,481089165,718503062,24497053,3332243209,3344655856,3655024856,3960371065,1195698900,2971415156,3710176158,2115785917,4027663609,3525578417,2524296189,2745972565,3564906415,1372086093,1452307862,2780501478,1476592880,3389271281,18495466,2378148571,901398090,891748256,3279637769,3157290713,2560960102,1447622437,4284372637,216884176,2086908623,1879786977,3588903153,2242455666,2938092967,3559082096,2810645491,758861177,1121993112,215018983,642190776,4169236812,1196255959,2081185372,3508738393,941322904,4124243163,2877523539,1848581667,2205260958,3180453958,2589345134,3694731276,550028657,2519456284,3789985535,2973870856,2093648313,443148163,46942275,2734146937,1117713533,1115362972,1523183689,3717140224,1551984063],s[1]=[522195092,4010518363,1776537470,960447360,4267822970,4005896314,1435016340,1929119313,2913464185,1310552629,3579470798,3724818106,2579771631,1594623892,417127293,2715217907,2696228731,1508390405,3994398868,3925858569,3695444102,4019471449,3129199795,3770928635,3520741761,990456497,4187484609,2783367035,21106139,3840405339,631373633,3783325702,532942976,396095098,3548038825,4267192484,2564721535,2011709262,2039648873,620404603,3776170075,2898526339,3612357925,4159332703,1645490516,223693667,1567101217,3362177881,1029951347,3470931136,3570957959,1550265121,119497089,972513919,907948164,3840628539,1613718692,3594177948,465323573,2659255085,654439692,2575596212,2699288441,3127702412,277098644,624404830,4100943870,2717858591,546110314,2403699828,3655377447,1321679412,4236791657,1045293279,4010672264,895050893,2319792268,494945126,1914543101,2777056443,3894764339,2219737618,311263384,4275257268,3458730721,669096869,3584475730,3835122877,3319158237,3949359204,2005142349,2713102337,2228954793,3769984788,569394103,3855636576,1425027204,108000370,2736431443,3671869269,3043122623,1750473702,2211081108,762237499,3972989403,2798899386,3061857628,2943854345,867476300,964413654,1591880597,1594774276,2179821409,552026980,3026064248,3726140315,2283577634,3110545105,2152310760,582474363,1582640421,1383256631,2043843868,3322775884,1217180674,463797851,2763038571,480777679,2718707717,2289164131,3118346187,214354409,200212307,3810608407,3025414197,2674075964,3997296425,1847405948,1342460550,510035443,4080271814,815934613,833030224,1620250387,1945732119,2703661145,3966000196,1388869545,3456054182,2687178561,2092620194,562037615,1356438536,3409922145,3261847397,1688467115,2150901366,631725691,3840332284,549916902,3455104640,394546491,837744717,2114462948,751520235,2221554606,2415360136,3999097078,2063029875,803036379,2702586305,821456707,3019566164,360699898,4018502092,3511869016,3677355358,2402471449,812317050,49299192,2570164949,3259169295,2816732080,3331213574,3101303564,2156015656,3705598920,3546263921,143268808,3200304480,1638124008,3165189453,3341807610,578956953,2193977524,3638120073,2333881532,807278310,658237817,2969561766,1641658566,11683945,3086995007,148645947,1138423386,4158756760,1981396783,2401016740,3699783584,380097457,2680394679,2803068651,3334260286,441530178,4016580796,1375954390,761952171,891809099,2183123478,157052462,3683840763,1592404427,341349109,2438483839,1417898363,644327628,2233032776,2353769706,2201510100,220455161,1815641738,182899273,2995019788,3627381533,3702638151,2890684138,1052606899,588164016,1681439879,4038439418,2405343923,4229449282,167996282,1336969661,1688053129,2739224926,1543734051,1046297529,1138201970,2121126012,115334942,1819067631,1902159161,1941945968,2206692869,1159982321],s[2]=[2381300288,637164959,3952098751,3893414151,1197506559,916448331,2350892612,2932787856,3199334847,4009478890,3905886544,1373570990,2450425862,4037870920,3778841987,2456817877,286293407,124026297,3001279700,1028597854,3115296800,4208886496,2691114635,2188540206,1430237888,1218109995,3572471700,308166588,570424558,2187009021,2455094765,307733056,1310360322,3135275007,1384269543,2388071438,863238079,2359263624,2801553128,3380786597,2831162807,1470087780,1728663345,4072488799,1090516929,532123132,2389430977,1132193179,2578464191,3051079243,1670234342,1434557849,2711078940,1241591150,3314043432,3435360113,3091448339,1812415473,2198440252,267246943,796911696,3619716990,38830015,1526438404,2806502096,374413614,2943401790,1489179520,1603809326,1920779204,168801282,260042626,2358705581,1563175598,2397674057,1356499128,2217211040,514611088,2037363785,2186468373,4022173083,2792511869,2913485016,1173701892,4200428547,3896427269,1334932762,2455136706,602925377,2835607854,1613172210,41346230,2499634548,2457437618,2188827595,41386358,4172255629,1313404830,2405527007,3801973774,2217704835,873260488,2528884354,2478092616,4012915883,2555359016,2006953883,2463913485,575479328,2218240648,2099895446,660001756,2341502190,3038761536,3888151779,3848713377,3286851934,1022894237,1620365795,3449594689,1551255054,15374395,3570825345,4249311020,4151111129,3181912732,310226346,1133119310,530038928,136043402,2476768958,3107506709,2544909567,1036173560,2367337196,1681395281,1758231547,3641649032,306774401,1575354324,3716085866,1990386196,3114533736,2455606671,1262092282,3124342505,2768229131,4210529083,1833535011,423410938,660763973,2187129978,1639812e3,3508421329,3467445492,310289298,272797111,2188552562,2456863912,310240523,677093832,1013118031,901835429,3892695601,1116285435,3036471170,1337354835,243122523,520626091,277223598,4244441197,4194248841,1766575121,594173102,316590669,742362309,3536858622,4176435350,3838792410,2501204839,1229605004,3115755532,1552908988,2312334149,979407927,3959474601,1148277331,176638793,3614686272,2083809052,40992502,1340822838,2731552767,3535757508,3560899520,1354035053,122129617,7215240,2732932949,3118912700,2718203926,2539075635,3609230695,3725561661,1928887091,2882293555,1988674909,2063640240,2491088897,1459647954,4189817080,2302804382,1113892351,2237858528,1927010603,4002880361,1856122846,1594404395,2944033133,3855189863,3474975698,1643104450,4054590833,3431086530,1730235576,2984608721,3084664418,2131803598,4178205752,267404349,1617849798,1616132681,1462223176,736725533,2327058232,551665188,2945899023,1749386277,2575514597,1611482493,674206544,2201269090,3642560800,728599968,1680547377,2620414464,1388111496,453204106,4156223445,1094905244,2754698257,2201108165,3757000246,2704524545,3922940700,3996465027],s[3]=[2645754912,532081118,2814278639,3530793624,1246723035,1689095255,2236679235,4194438865,2116582143,3859789411,157234593,2045505824,4245003587,1687664561,4083425123,605965023,672431967,1336064205,3376611392,214114848,4258466608,3232053071,489488601,605322005,3998028058,264917351,1912574028,756637694,436560991,202637054,135989450,85393697,2152923392,3896401662,2895836408,2145855233,3535335007,115294817,3147733898,1922296357,3464822751,4117858305,1037454084,2725193275,2127856640,1417604070,1148013728,1827919605,642362335,2929772533,909348033,1346338451,3547799649,297154785,1917849091,4161712827,2883604526,3968694238,1469521537,3780077382,3375584256,1763717519,136166297,4290970789,1295325189,2134727907,2798151366,1566297257,3672928234,2677174161,2672173615,965822077,2780786062,289653839,1133871874,3491843819,35685304,1068898316,418943774,672553190,642281022,2346158704,1954014401,3037126780,4079815205,2030668546,3840588673,672283427,1776201016,359975446,3750173538,555499703,2769985273,1324923,69110472,152125443,3176785106,3822147285,1340634837,798073664,1434183902,15393959,216384236,1303690150,3881221631,3711134124,3960975413,106373927,2578434224,1455997841,1801814300,1578393881,1854262133,3188178946,3258078583,2302670060,1539295533,3505142565,3078625975,2372746020,549938159,3278284284,2620926080,181285381,2865321098,3970029511,68876850,488006234,1728155692,2608167508,836007927,2435231793,919367643,3339422534,3655756360,1457871481,40520939,1380155135,797931188,234455205,2255801827,3990488299,397000196,739833055,3077865373,2871719860,4022553888,772369276,390177364,3853951029,557662966,740064294,1640166671,1699928825,3535942136,622006121,3625353122,68743880,1742502,219489963,1664179233,1577743084,1236991741,410585305,2366487942,823226535,1050371084,3426619607,3586839478,212779912,4147118561,1819446015,1911218849,530248558,3486241071,3252585495,2886188651,3410272728,2342195030,20547779,2982490058,3032363469,3631753222,312714466,1870521650,1493008054,3491686656,615382978,4103671749,2534517445,1932181,2196105170,278426614,6369430,3274544417,2913018367,697336853,2143000447,2946413531,701099306,1558357093,2805003052,3500818408,2321334417,3567135975,216290473,3591032198,23009561,1996984579,3735042806,2024298078,3739440863,569400510,2339758983,3016033873,3097871343,3639523026,3844324983,3256173865,795471839,2951117563,4101031090,4091603803,3603732598,971261452,534414648,428311343,3389027175,2844869880,694888862,1227866773,2456207019,3043454569,2614353370,3749578031,3676663836,459166190,4132644070,1794958188,51825668,2252611902,3084671440,2036672799,3436641603,1099053433,2469121526,3059204941,1323291266,2061838604,1018778475,2233344254,2553501054,334295216,3556750194,1065731521,183467730],s[4]=[2127105028,745436345,2601412319,2788391185,3093987327,500390133,1155374404,389092991,150729210,3891597772,3523549952,1935325696,716645080,946045387,2901812282,1774124410,3869435775,4039581901,3293136918,3438657920,948246080,363898952,3867875531,1286266623,1598556673,68334250,630723836,1104211938,1312863373,613332731,2377784574,1101634306,441780740,3129959883,1917973735,2510624549,3238456535,2544211978,3308894634,1299840618,4076074851,1756332096,3977027158,297047435,3790297736,2265573040,3621810518,1311375015,1667687725,47300608,3299642885,2474112369,201668394,1468347890,576830978,3594690761,3742605952,1958042578,1747032512,3558991340,1408974056,3366841779,682131401,1033214337,1545599232,4265137049,206503691,103024618,2855227313,1337551222,2428998917,2963842932,4015366655,3852247746,2796956967,3865723491,3747938335,247794022,3755824572,702416469,2434691994,397379957,851939612,2314769512,218229120,1380406772,62274761,214451378,3170103466,2276210409,3845813286,28563499,446592073,1693330814,3453727194,29968656,3093872512,220656637,2470637031,77972100,1667708854,1358280214,4064765667,2395616961,325977563,4277240721,4220025399,3605526484,3355147721,811859167,3069544926,3962126810,652502677,3075892249,4132761541,3498924215,1217549313,3250244479,3858715919,3053989961,1538642152,2279026266,2875879137,574252750,3324769229,2651358713,1758150215,141295887,2719868960,3515574750,4093007735,4194485238,1082055363,3417560400,395511885,2966884026,179534037,3646028556,3738688086,1092926436,2496269142,257381841,3772900718,1636087230,1477059743,2499234752,3811018894,2675660129,3285975680,90732309,1684827095,1150307763,1723134115,3237045386,1769919919,1240018934,815675215,750138730,2239792499,1234303040,1995484674,138143821,675421338,1145607174,1936608440,3238603024,2345230278,2105974004,323969391,779555213,3004902369,2861610098,1017501463,2098600890,2628620304,2940611490,2682542546,1171473753,3656571411,3687208071,4091869518,393037935,159126506,1662887367,1147106178,391545844,3452332695,1891500680,3016609650,1851642611,546529401,1167818917,3194020571,2848076033,3953471836,575554290,475796850,4134673196,450035699,2351251534,844027695,1080539133,86184846,1554234488,3692025454,1972511363,2018339607,1491841390,1141460869,1061690759,4244549243,2008416118,2351104703,2868147542,1598468138,722020353,1027143159,212344630,1387219594,1725294528,3745187956,2500153616,458938280,4129215917,1828119673,544571780,3503225445,2297937496,1241802790,267843827,2694610800,1397140384,1558801448,3782667683,1806446719,929573330,2234912681,400817706,616011623,4121520928,3603768725,1761550015,1968522284,4053731006,4192232858,4005120285,872482584,3140537016,3894607381,2287405443,1963876937,3663887957,1584857e3,2975024454,1833426440,4025083860],s[5]=[4143615901,749497569,1285769319,3795025788,2514159847,23610292,3974978748,844452780,3214870880,3751928557,2213566365,1676510905,448177848,3730751033,4086298418,2307502392,871450977,3222878141,4110862042,3831651966,2735270553,1310974780,2043402188,1218528103,2736035353,4274605013,2702448458,3936360550,2693061421,162023535,2827510090,687910808,23484817,3784910947,3371371616,779677500,3503626546,3473927188,4157212626,3500679282,4248902014,2466621104,3899384794,1958663117,925738300,1283408968,3669349440,1840910019,137959847,2679828185,1239142320,1315376211,1547541505,1690155329,739140458,3128809933,3933172616,3876308834,905091803,1548541325,4040461708,3095483362,144808038,451078856,676114313,2861728291,2469707347,993665471,373509091,2599041286,4025009006,4170239449,2149739950,3275793571,3749616649,2794760199,1534877388,572371878,2590613551,1753320020,3467782511,1405125690,4270405205,633333386,3026356924,3475123903,632057672,2846462855,1404951397,3882875879,3915906424,195638627,2385783745,3902872553,1233155085,3355999740,2380578713,2702246304,2144565621,3663341248,3894384975,2502479241,4248018925,3094885567,1594115437,572884632,3385116731,767645374,1331858858,1475698373,3793881790,3532746431,1321687957,619889600,1121017241,3440213920,2070816767,2833025776,1933951238,4095615791,890643334,3874130214,859025556,360630002,925594799,1764062180,3920222280,4078305929,979562269,2810700344,4087740022,1949714515,546639971,1165388173,3069891591,1495988560,922170659,1291546247,2107952832,1813327274,3406010024,3306028637,4241950635,153207855,2313154747,1608695416,1150242611,1967526857,721801357,1220138373,3691287617,3356069787,2112743302,3281662835,1111556101,1778980689,250857638,2298507990,673216130,2846488510,3207751581,3562756981,3008625920,3417367384,2198807050,529510932,3547516680,3426503187,2364944742,102533054,2294910856,1617093527,1204784762,3066581635,1019391227,1069574518,1317995090,1691889997,3661132003,510022745,3238594800,1362108837,1817929911,2184153760,805817662,1953603311,3699844737,120799444,2118332377,207536705,2282301548,4120041617,145305846,2508124933,3086745533,3261524335,1877257368,2977164480,3160454186,2503252186,4221677074,759945014,254147243,2767453419,3801518371,629083197,2471014217,907280572,3900796746,940896768,2751021123,2625262786,3161476951,3661752313,3260732218,1425318020,2977912069,1496677566,3988592072,2140652971,3126511541,3069632175,977771578,1392695845,1698528874,1411812681,1369733098,1343739227,3620887944,1142123638,67414216,3102056737,3088749194,1626167401,2546293654,3941374235,697522451,33404913,143560186,2595682037,994885535,1247667115,3859094837,2699155541,3547024625,4114935275,2968073508,3199963069,2732024527,1237921620,951448369,1898488916,1211705605,2790989240,2233243581,3598044975],s[6]=[2246066201,858518887,1714274303,3485882003,713916271,2879113490,3730835617,539548191,36158695,1298409750,419087104,1358007170,749914897,2989680476,1261868530,2995193822,2690628854,3443622377,3780124940,3796824509,2976433025,4259637129,1551479e3,512490819,1296650241,951993153,2436689437,2460458047,144139966,3136204276,310820559,3068840729,643875328,1969602020,1680088954,2185813161,3283332454,672358534,198762408,896343282,276269502,3014846926,84060815,197145886,376173866,3943890818,3813173521,3545068822,1316698879,1598252827,2633424951,1233235075,859989710,2358460855,3503838400,3409603720,1203513385,1193654839,2792018475,2060853022,207403770,1144516871,3068631394,1121114134,177607304,3785736302,326409831,1929119770,2983279095,4183308101,3474579288,3200513878,3228482096,119610148,1170376745,3378393471,3163473169,951863017,3337026068,3135789130,2907618374,1183797387,2015970143,4045674555,2182986399,2952138740,3928772205,384012900,2454997643,10178499,2879818989,2596892536,111523738,2995089006,451689641,3196290696,235406569,1441906262,3890558523,3013735005,4158569349,1644036924,376726067,1006849064,3664579700,2041234796,1021632941,1374734338,2566452058,371631263,4007144233,490221539,206551450,3140638584,1053219195,1853335209,3412429660,3562156231,735133835,1623211703,3104214392,2738312436,4096837757,3366392578,3110964274,3956598718,3196820781,2038037254,3877786376,2339753847,300912036,3766732888,2372630639,1516443558,4200396704,1574567987,4069441456,4122592016,2699739776,146372218,2748961456,2043888151,35287437,2596680554,655490400,1132482787,110692520,1031794116,2188192751,1324057718,1217253157,919197030,686247489,3261139658,1028237775,3135486431,3059715558,2460921700,986174950,2661811465,4062904701,2752986992,3709736643,367056889,1353824391,731860949,1650113154,1778481506,784341916,357075625,3608602432,1074092588,2480052770,3811426202,92751289,877911070,3600361838,1231880047,480201094,3756190983,3094495953,434011822,87971354,363687820,1717726236,1901380172,3926403882,2481662265,400339184,1490350766,2661455099,1389319756,2558787174,784598401,1983468483,30828846,3550527752,2716276238,3841122214,1765724805,1955612312,1277890269,1333098070,1564029816,2704417615,1026694237,3287671188,1260819201,3349086767,1016692350,1582273796,1073413053,1995943182,694588404,1025494639,3323872702,3551898420,4146854327,453260480,1316140391,1435673405,3038941953,3486689407,1622062951,403978347,817677117,950059133,4246079218,3278066075,1486738320,1417279718,481875527,2549965225,3933690356,760697757,1452955855,3897451437,1177426808,1702951038,4085348628,2447005172,1084371187,3516436277,3068336338,1073369276,1027665953,3284188590,1230553676,1368340146,2226246512,267243139,2274220762,4070734279,2497715176,2423353163,2504755875],s[7]=[3793104909,3151888380,2817252029,895778965,2005530807,3871412763,237245952,86829237,296341424,3851759377,3974600970,2475086196,709006108,1994621201,2972577594,937287164,3734691505,168608556,3189338153,2225080640,3139713551,3033610191,3025041904,77524477,185966941,1208824168,2344345178,1721625922,3354191921,1066374631,1927223579,1971335949,2483503697,1551748602,2881383779,2856329572,3003241482,48746954,1398218158,2050065058,313056748,4255789917,393167848,1912293076,940740642,3465845460,3091687853,2522601570,2197016661,1727764327,364383054,492521376,1291706479,3264136376,1474851438,1685747964,2575719748,1619776915,1814040067,970743798,1561002147,2925768690,2123093554,1880132620,3151188041,697884420,2550985770,2607674513,2659114323,110200136,1489731079,997519150,1378877361,3527870668,478029773,2766872923,1022481122,431258168,1112503832,897933369,2635587303,669726182,3383752315,918222264,163866573,3246985393,3776823163,114105080,1903216136,761148244,3571337562,1690750982,3166750252,1037045171,1888456500,2010454850,642736655,616092351,365016990,1185228132,4174898510,1043824992,2023083429,2241598885,3863320456,3279669087,3674716684,108438443,2132974366,830746235,606445527,4173263986,2204105912,1844756978,2532684181,4245352700,2969441100,3796921661,1335562986,4061524517,2720232303,2679424040,634407289,885462008,3294724487,3933892248,2094100220,339117932,4048830727,3202280980,1458155303,2689246273,1022871705,2464987878,3714515309,353796843,2822958815,4256850100,4052777845,551748367,618185374,3778635579,4020649912,1904685140,3069366075,2670879810,3407193292,2954511620,4058283405,2219449317,3135758300,1120655984,3447565834,1474845562,3577699062,550456716,3466908712,2043752612,881257467,869518812,2005220179,938474677,3305539448,3850417126,1315485940,3318264702,226533026,965733244,321539988,1136104718,804158748,573969341,3708209826,937399083,3290727049,2901666755,1461057207,4013193437,4066861423,3242773476,2421326174,1581322155,3028952165,786071460,3900391652,3918438532,1485433313,4023619836,3708277595,3678951060,953673138,1467089153,1930354364,1533292819,2492563023,1346121658,1685000834,1965281866,3765933717,4190206607,2052792609,3515332758,690371149,3125873887,2180283551,2903598061,3933952357,436236910,289419410,14314871,1242357089,2904507907,1616633776,2666382180,585885352,3471299210,2699507360,1432659641,277164553,3354103607,770115018,2303809295,3741942315,3177781868,2853364978,2269453327,3774259834,987383833,1290892879,225909803,1741533526,890078084,1496906255,1111072499,916028167,243534141,1252605537,2204162171,531204876,290011180,3916834213,102027703,237315147,209093447,1486785922,220223953,2758195998,4175039106,82940208,3127791296,2569425252,518464269,1353887104,3941492737,2377294467,3935040926]}function Fn(n){this.cast5=new y5,this.cast5.setKey(n),this.encrypt=function(t){return this.cast5.encrypt(t)}}Tn.keySize=Tn.prototype.keySize=24,Tn.blockSize=Tn.prototype.blockSize=8,Fn.blockSize=Fn.prototype.blockSize=8,Fn.keySize=Fn.prototype.keySize=16;const ee=4294967295;function we(n,t){return(n<<t|n>>>32-t)&ee}function Le(n,t){return n[t]|n[t+1]<<8|n[t+2]<<16|n[t+3]<<24}function sr(n,t,r){n.splice(t,4,255&r,r>>>8&255,r>>>16&255,r>>>24&255)}function X(n,t){return n>>>8*t&255}function Ln(n){this.tf=(function(){let t=null,r=null,e=-1,i=[],s=[[],[],[],[]];function a(h){return s[0][X(h,0)]^s[1][X(h,1)]^s[2][X(h,2)]^s[3][X(h,3)]}function o(h){return s[0][X(h,3)]^s[1][X(h,0)]^s[2][X(h,1)]^s[3][X(h,2)]}function c(h,l){let y=a(l[0]),g=o(l[1]);l[2]=we(l[2]^y+g+i[4*h+8]&ee,31),l[3]=we(l[3],1)^y+2*g+i[4*h+9]&ee,y=a(l[2]),g=o(l[3]),l[0]=we(l[0]^y+g+i[4*h+10]&ee,31),l[1]=we(l[1],1)^y+2*g+i[4*h+11]&ee}function u(h,l){let y=a(l[0]),g=o(l[1]);l[2]=we(l[2],1)^y+g+i[4*h+10]&ee,l[3]=we(l[3]^y+2*g+i[4*h+11]&ee,31),y=a(l[2]),g=o(l[3]),l[0]=we(l[0],1)^y+g+i[4*h+8]&ee,l[1]=we(l[1]^y+2*g+i[4*h+9]&ee,31)}return{name:"twofish",blocksize:16,open:function(h){let l,y,g,p,A;t=h;const w=[],b=[],v=[];let k;const m=[];let C,D,P;const S=[[8,1,7,13,6,15,3,2,0,11,5,9,14,12,10,4],[2,8,11,13,15,7,6,14,3,1,9,4,0,10,12,5]],E=[[14,12,11,8,1,2,3,5,15,4,10,6,7,0,9,13],[1,14,2,11,4,12,3,7,6,13,10,5,15,9,0,8]],K=[[11,10,5,14,6,13,9,0,12,8,15,3,2,4,7,1],[4,12,7,5,1,6,9,10,0,14,13,8,2,11,3,15]],I=[[13,7,15,4,1,2,6,14,9,11,3,0,8,5,12,10],[11,9,5,1,12,3,13,14,6,4,7,15,2,0,8,10]],B=[0,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15],U=[0,9,2,11,4,13,6,15,8,1,10,3,12,5,14,7],x=[[],[]],M=[[],[],[],[]];function Q(z){return z^z>>2^[0,90,180,238][3&z]}function R(z){return z^z>>1^z>>2^[0,238,180,90][3&z]}function N(z,L){let O,H,j;for(O=0;O<8;O++)H=L>>>24,L=L<<8&ee|z>>>24,z=z<<8&ee,j=H<<1,128&H&&(j^=333),L^=H^j<<16,j^=H>>>1,1&H&&(j^=166),L^=j<<24|j<<8;return L}function T(z,L){const O=L>>4,H=15&L,j=S[z][O^H],V=E[z][B[H]^U[O]];return I[z][B[V]^U[j]]<<4|K[z][j^V]}function F(z,L){let O=X(z,0),H=X(z,1),j=X(z,2),V=X(z,3);switch(k){case 4:O=x[1][O]^X(L[3],0),H=x[0][H]^X(L[3],1),j=x[0][j]^X(L[3],2),V=x[1][V]^X(L[3],3);case 3:O=x[1][O]^X(L[2],0),H=x[1][H]^X(L[2],1),j=x[0][j]^X(L[2],2),V=x[0][V]^X(L[2],3);case 2:O=x[0][x[0][O]^X(L[1],0)]^X(L[0],0),H=x[0][x[1][H]^X(L[1],1)]^X(L[0],1),j=x[1][x[0][j]^X(L[1],2)]^X(L[0],2),V=x[1][x[1][V]^X(L[1],3)]^X(L[0],3)}return M[0][O]^M[1][H]^M[2][j]^M[3][V]}for(t=t.slice(0,32),l=t.length;l!==16&&l!==24&&l!==32;)t[l++]=0;for(l=0;l<t.length;l+=4)v[l>>2]=Le(t,l);for(l=0;l<256;l++)x[0][l]=T(0,l),x[1][l]=T(1,l);for(l=0;l<256;l++)C=x[1][l],D=Q(C),P=R(C),M[0][l]=C+(D<<8)+(P<<16)+(P<<24),M[2][l]=D+(P<<8)+(C<<16)+(P<<24),C=x[0][l],D=Q(C),P=R(C),M[1][l]=P+(P<<8)+(D<<16)+(C<<24),M[3][l]=D+(C<<8)+(P<<16)+(D<<24);for(k=v.length/2,l=0;l<k;l++)y=v[l+l],w[l]=y,g=v[l+l+1],b[l]=g,m[k-l-1]=N(y,g);for(l=0;l<40;l+=2)y=16843009*l,g=y+16843009,y=F(y,w),g=we(F(g,b),8),i[l]=y+g&ee,i[l+1]=we(y+2*g,9);for(l=0;l<256;l++)switch(y=g=p=A=l,k){case 4:y=x[1][y]^X(m[3],0),g=x[0][g]^X(m[3],1),p=x[0][p]^X(m[3],2),A=x[1][A]^X(m[3],3);case 3:y=x[1][y]^X(m[2],0),g=x[1][g]^X(m[2],1),p=x[0][p]^X(m[2],2),A=x[0][A]^X(m[2],3);case 2:s[0][l]=M[0][x[0][x[0][y]^X(m[1],0)]^X(m[0],0)],s[1][l]=M[1][x[0][x[1][g]^X(m[1],1)]^X(m[0],1)],s[2][l]=M[2][x[1][x[0][p]^X(m[1],2)]^X(m[0],2)],s[3][l]=M[3][x[1][x[1][A]^X(m[1],3)]^X(m[0],3)]}},close:function(){i=[],s=[[],[],[],[]]},encrypt:function(h,l){r=h,e=l;const y=[Le(r,e)^i[0],Le(r,e+4)^i[1],Le(r,e+8)^i[2],Le(r,e+12)^i[3]];for(let g=0;g<8;g++)c(g,y);return sr(r,e,y[2]^i[4]),sr(r,e+4,y[3]^i[5]),sr(r,e+8,y[0]^i[6]),sr(r,e+12,y[1]^i[7]),e+=16,r},decrypt:function(h,l){r=h,e=l;const y=[Le(r,e)^i[4],Le(r,e+4)^i[5],Le(r,e+8)^i[6],Le(r,e+12)^i[7]];for(let g=7;g>=0;g--)u(g,y);sr(r,e,y[2]^i[0]),sr(r,e+4,y[3]^i[1]),sr(r,e+8,y[0]^i[2]),sr(r,e+12,y[1]^i[3]),e+=16},finalize:function(){return r}}})(),this.tf.open(Array.from(n),0),this.encrypt=function(t){return this.tf.encrypt(Array.from(t),0)}}function fe(){}function Nn(n){this.bf=new fe,this.bf.init(n),this.encrypt=function(t){return this.bf.encryptBlock(t)}}Ln.keySize=Ln.prototype.keySize=32,Ln.blockSize=Ln.prototype.blockSize=16,fe.prototype.BLOCKSIZE=8,fe.prototype.SBOXES=[[3509652390,2564797868,805139163,3491422135,3101798381,1780907670,3128725573,4046225305,614570311,3012652279,134345442,2240740374,1667834072,1901547113,2757295779,4103290238,227898511,1921955416,1904987480,2182433518,2069144605,3260701109,2620446009,720527379,3318853667,677414384,3393288472,3101374703,2390351024,1614419982,1822297739,2954791486,3608508353,3174124327,2024746970,1432378464,3864339955,2857741204,1464375394,1676153920,1439316330,715854006,3033291828,289532110,2706671279,2087905683,3018724369,1668267050,732546397,1947742710,3462151702,2609353502,2950085171,1814351708,2050118529,680887927,999245976,1800124847,3300911131,1713906067,1641548236,4213287313,1216130144,1575780402,4018429277,3917837745,3693486850,3949271944,596196993,3549867205,258830323,2213823033,772490370,2760122372,1774776394,2652871518,566650946,4142492826,1728879713,2882767088,1783734482,3629395816,2517608232,2874225571,1861159788,326777828,3124490320,2130389656,2716951837,967770486,1724537150,2185432712,2364442137,1164943284,2105845187,998989502,3765401048,2244026483,1075463327,1455516326,1322494562,910128902,469688178,1117454909,936433444,3490320968,3675253459,1240580251,122909385,2157517691,634681816,4142456567,3825094682,3061402683,2540495037,79693498,3249098678,1084186820,1583128258,426386531,1761308591,1047286709,322548459,995290223,1845252383,2603652396,3431023940,2942221577,3202600964,3727903485,1712269319,422464435,3234572375,1170764815,3523960633,3117677531,1434042557,442511882,3600875718,1076654713,1738483198,4213154764,2393238008,3677496056,1014306527,4251020053,793779912,2902807211,842905082,4246964064,1395751752,1040244610,2656851899,3396308128,445077038,3742853595,3577915638,679411651,2892444358,2354009459,1767581616,3150600392,3791627101,3102740896,284835224,4246832056,1258075500,768725851,2589189241,3069724005,3532540348,1274779536,3789419226,2764799539,1660621633,3471099624,4011903706,913787905,3497959166,737222580,2514213453,2928710040,3937242737,1804850592,3499020752,2949064160,2386320175,2390070455,2415321851,4061277028,2290661394,2416832540,1336762016,1754252060,3520065937,3014181293,791618072,3188594551,3933548030,2332172193,3852520463,3043980520,413987798,3465142937,3030929376,4245938359,2093235073,3534596313,375366246,2157278981,2479649556,555357303,3870105701,2008414854,3344188149,4221384143,3956125452,2067696032,3594591187,2921233993,2428461,544322398,577241275,1471733935,610547355,4027169054,1432588573,1507829418,2025931657,3646575487,545086370,48609733,2200306550,1653985193,298326376,1316178497,3007786442,2064951626,458293330,2589141269,3591329599,3164325604,727753846,2179363840,146436021,1461446943,4069977195,705550613,3059967265,3887724982,4281599278,3313849956,1404054877,2845806497,146425753,1854211946],[1266315497,3048417604,3681880366,3289982499,290971e4,1235738493,2632868024,2414719590,3970600049,1771706367,1449415276,3266420449,422970021,1963543593,2690192192,3826793022,1062508698,1531092325,1804592342,2583117782,2714934279,4024971509,1294809318,4028980673,1289560198,2221992742,1669523910,35572830,157838143,1052438473,1016535060,1802137761,1753167236,1386275462,3080475397,2857371447,1040679964,2145300060,2390574316,1461121720,2956646967,4031777805,4028374788,33600511,2920084762,1018524850,629373528,3691585981,3515945977,2091462646,2486323059,586499841,988145025,935516892,3367335476,2599673255,2839830854,265290510,3972581182,2759138881,3795373465,1005194799,847297441,406762289,1314163512,1332590856,1866599683,4127851711,750260880,613907577,1450815602,3165620655,3734664991,3650291728,3012275730,3704569646,1427272223,778793252,1343938022,2676280711,2052605720,1946737175,3164576444,3914038668,3967478842,3682934266,1661551462,3294938066,4011595847,840292616,3712170807,616741398,312560963,711312465,1351876610,322626781,1910503582,271666773,2175563734,1594956187,70604529,3617834859,1007753275,1495573769,4069517037,2549218298,2663038764,504708206,2263041392,3941167025,2249088522,1514023603,1998579484,1312622330,694541497,2582060303,2151582166,1382467621,776784248,2618340202,3323268794,2497899128,2784771155,503983604,4076293799,907881277,423175695,432175456,1378068232,4145222326,3954048622,3938656102,3820766613,2793130115,2977904593,26017576,3274890735,3194772133,1700274565,1756076034,4006520079,3677328699,720338349,1533947780,354530856,688349552,3973924725,1637815568,332179504,3949051286,53804574,2852348879,3044236432,1282449977,3583942155,3416972820,4006381244,1617046695,2628476075,3002303598,1686838959,431878346,2686675385,1700445008,1080580658,1009431731,832498133,3223435511,2605976345,2271191193,2516031870,1648197032,4164389018,2548247927,300782431,375919233,238389289,3353747414,2531188641,2019080857,1475708069,455242339,2609103871,448939670,3451063019,1395535956,2413381860,1841049896,1491858159,885456874,4264095073,4001119347,1565136089,3898914787,1108368660,540939232,1173283510,2745871338,3681308437,4207628240,3343053890,4016749493,1699691293,1103962373,3625875870,2256883143,3830138730,1031889488,3479347698,1535977030,4236805024,3251091107,2132092099,1774941330,1199868427,1452454533,157007616,2904115357,342012276,595725824,1480756522,206960106,497939518,591360097,863170706,2375253569,3596610801,1814182875,2094937945,3421402208,1082520231,3463918190,2785509508,435703966,3908032597,1641649973,2842273706,3305899714,1510255612,2148256476,2655287854,3276092548,4258621189,236887753,3681803219,274041037,1734335097,3815195456,3317970021,1899903192,1026095262,4050517792,356393447,2410691914,3873677099,3682840055],[3913112168,2491498743,4132185628,2489919796,1091903735,1979897079,3170134830,3567386728,3557303409,857797738,1136121015,1342202287,507115054,2535736646,337727348,3213592640,1301675037,2528481711,1895095763,1721773893,3216771564,62756741,2142006736,835421444,2531993523,1442658625,3659876326,2882144922,676362277,1392781812,170690266,3921047035,1759253602,3611846912,1745797284,664899054,1329594018,3901205900,3045908486,2062866102,2865634940,3543621612,3464012697,1080764994,553557557,3656615353,3996768171,991055499,499776247,1265440854,648242737,3940784050,980351604,3713745714,1749149687,3396870395,4211799374,3640570775,1161844396,3125318951,1431517754,545492359,4268468663,3499529547,1437099964,2702547544,3433638243,2581715763,2787789398,1060185593,1593081372,2418618748,4260947970,69676912,2159744348,86519011,2512459080,3838209314,1220612927,3339683548,133810670,1090789135,1078426020,1569222167,845107691,3583754449,4072456591,1091646820,628848692,1613405280,3757631651,526609435,236106946,48312990,2942717905,3402727701,1797494240,859738849,992217954,4005476642,2243076622,3870952857,3732016268,765654824,3490871365,2511836413,1685915746,3888969200,1414112111,2273134842,3281911079,4080962846,172450625,2569994100,980381355,4109958455,2819808352,2716589560,2568741196,3681446669,3329971472,1835478071,660984891,3704678404,4045999559,3422617507,3040415634,1762651403,1719377915,3470491036,2693910283,3642056355,3138596744,1364962596,2073328063,1983633131,926494387,3423689081,2150032023,4096667949,1749200295,3328846651,309677260,2016342300,1779581495,3079819751,111262694,1274766160,443224088,298511866,1025883608,3806446537,1145181785,168956806,3641502830,3584813610,1689216846,3666258015,3200248200,1692713982,2646376535,4042768518,1618508792,1610833997,3523052358,4130873264,2001055236,3610705100,2202168115,4028541809,2961195399,1006657119,2006996926,3186142756,1430667929,3210227297,1314452623,4074634658,4101304120,2273951170,1399257539,3367210612,3027628629,1190975929,2062231137,2333990788,2221543033,2438960610,1181637006,548689776,2362791313,3372408396,3104550113,3145860560,296247880,1970579870,3078560182,3769228297,1714227617,3291629107,3898220290,166772364,1251581989,493813264,448347421,195405023,2709975567,677966185,3703036547,1463355134,2715995803,1338867538,1343315457,2802222074,2684532164,233230375,2599980071,2000651841,3277868038,1638401717,4028070440,3237316320,6314154,819756386,300326615,590932579,1405279636,3267499572,3150704214,2428286686,3959192993,3461946742,1862657033,1266418056,963775037,2089974820,2263052895,1917689273,448879540,3550394620,3981727096,150775221,3627908307,1303187396,508620638,2975983352,2726630617,1817252668,1876281319,1457606340,908771278,3720792119,3617206836,2455994898,1729034894,1080033504],[976866871,3556439503,2881648439,1522871579,1555064734,1336096578,3548522304,2579274686,3574697629,3205460757,3593280638,3338716283,3079412587,564236357,2993598910,1781952180,1464380207,3163844217,3332601554,1699332808,1393555694,1183702653,3581086237,1288719814,691649499,2847557200,2895455976,3193889540,2717570544,1781354906,1676643554,2592534050,3230253752,1126444790,2770207658,2633158820,2210423226,2615765581,2414155088,3127139286,673620729,2805611233,1269405062,4015350505,3341807571,4149409754,1057255273,2012875353,2162469141,2276492801,2601117357,993977747,3918593370,2654263191,753973209,36408145,2530585658,25011837,3520020182,2088578344,530523599,2918365339,1524020338,1518925132,3760827505,3759777254,1202760957,3985898139,3906192525,674977740,4174734889,2031300136,2019492241,3983892565,4153806404,3822280332,352677332,2297720250,60907813,90501309,3286998549,1016092578,2535922412,2839152426,457141659,509813237,4120667899,652014361,1966332200,2975202805,55981186,2327461051,676427537,3255491064,2882294119,3433927263,1307055953,942726286,933058658,2468411793,3933900994,4215176142,1361170020,2001714738,2830558078,3274259782,1222529897,1679025792,2729314320,3714953764,1770335741,151462246,3013232138,1682292957,1483529935,471910574,1539241949,458788160,3436315007,1807016891,3718408830,978976581,1043663428,3165965781,1927990952,4200891579,2372276910,3208408903,3533431907,1412390302,2931980059,4132332400,1947078029,3881505623,4168226417,2941484381,1077988104,1320477388,886195818,18198404,3786409e3,2509781533,112762804,3463356488,1866414978,891333506,18488651,661792760,1628790961,3885187036,3141171499,876946877,2693282273,1372485963,791857591,2686433993,3759982718,3167212022,3472953795,2716379847,445679433,3561995674,3504004811,3574258232,54117162,3331405415,2381918588,3769707343,4154350007,1140177722,4074052095,668550556,3214352940,367459370,261225585,2610173221,4209349473,3468074219,3265815641,314222801,3066103646,3808782860,282218597,3406013506,3773591054,379116347,1285071038,846784868,2669647154,3771962079,3550491691,2305946142,453669953,1268987020,3317592352,3279303384,3744833421,2610507566,3859509063,266596637,3847019092,517658769,3462560207,3443424879,370717030,4247526661,2224018117,4143653529,4112773975,2788324899,2477274417,1456262402,2901442914,1517677493,1846949527,2295493580,3734397586,2176403920,1280348187,1908823572,3871786941,846861322,1172426758,3287448474,3383383037,1655181056,3139813346,901632758,1897031941,2986607138,3066810236,3447102507,1393639104,373351379,950779232,625454576,3124240540,4148612726,2007998917,544563296,2244738638,2330496472,2058025392,1291430526,424198748,50039436,29584100,3605783033,2429876329,2791104160,1057563949,3255363231,3075367218,3463963227,1469046755,985887462]],fe.prototype.PARRAY=[608135816,2242054355,320440878,57701188,2752067618,698298832,137296536,3964562569,1160258022,953160567,3193202383,887688300,3232508343,3380367581,1065670069,3041331479,2450970073,2306472731],fe.prototype.NN=16,fe.prototype._clean=function(n){return n<0&&(n=(2147483647&n)+2147483648),n},fe.prototype._F=function(n){let t;const r=255&n,e=255&(n>>>=8),i=255&(n>>>=8),s=255&(n>>>=8);return t=this.sboxes[0][s]+this.sboxes[1][i],t^=this.sboxes[2][e],t+=this.sboxes[3][r],t},fe.prototype._encryptBlock=function(n){let t,r=n[0],e=n[1];for(t=0;t<this.NN;++t){r^=this.parray[t],e=this._F(r)^e;const i=r;r=e,e=i}r^=this.parray[this.NN+0],e^=this.parray[this.NN+1],n[0]=this._clean(e),n[1]=this._clean(r)},fe.prototype.encryptBlock=function(n){let t;const r=[0,0],e=this.BLOCKSIZE/2;for(t=0;t<this.BLOCKSIZE/2;++t)r[0]=r[0]<<8|255&n[t+0],r[1]=r[1]<<8|255&n[t+e];this._encryptBlock(r);const i=[];for(t=0;t<this.BLOCKSIZE/2;++t)i[t+0]=r[0]>>>24-8*t&255,i[t+e]=r[1]>>>24-8*t&255;return i},fe.prototype._decryptBlock=function(n){let t,r=n[0],e=n[1];for(t=this.NN+1;t>1;--t){r^=this.parray[t],e=this._F(r)^e;const i=r;r=e,e=i}r^=this.parray[1],e^=this.parray[0],n[0]=this._clean(e),n[1]=this._clean(r)},fe.prototype.init=function(n){let t,r=0;for(this.parray=[],t=0;t<this.NN+2;++t){let i=0;for(let s=0;s<4;++s)i=i<<8|255&n[r],++r>=n.length&&(r=0);this.parray[t]=this.PARRAY[t]^i}for(this.sboxes=[],t=0;t<4;++t)for(this.sboxes[t]=[],r=0;r<256;++r)this.sboxes[t][r]=this.SBOXES[t][r];const e=[0,0];for(t=0;t<this.NN+2;t+=2)this._encryptBlock(e),this.parray[t+0]=e[0],this.parray[t+1]=e[1];for(t=0;t<4;++t)for(r=0;r<256;r+=2)this._encryptBlock(e),this.sboxes[t][r+0]=e[0],this.sboxes[t][r+1]=e[1]},Nn.keySize=Nn.prototype.keySize=16,Nn.blockSize=Nn.prototype.blockSize=8;const g5=new Map(Object.entries({tripledes:Tn,cast5:Fn,twofish:Ln,blowfish:Nn}));var p5=Object.freeze({__proto__:null,legacyCiphers:g5});function Yr(n,t,r,e){n[t]+=r[e],n[t+1]+=r[e+1]+(n[t]<r[e])}function Pc(n,t){n[0]+=t,n[1]+=n[0]<t}function ar(n,t,r,e,i,s,a,o){Yr(n,r,n,e),Yr(n,r,t,a);let c=n[s]^n[r],u=n[s+1]^n[r+1];n[s]=u,n[s+1]=c,Yr(n,i,n,s),c=n[e]^n[i],u=n[e+1]^n[i+1],n[e]=c>>>24^u<<8,n[e+1]=u>>>24^c<<8,Yr(n,r,n,e),Yr(n,r,t,o),c=n[s]^n[r],u=n[s+1]^n[r+1],n[s]=c>>>16^u<<16,n[s+1]=u>>>16^c<<16,Yr(n,i,n,s),c=n[e]^n[i],u=n[e+1]^n[i+1],n[e]=u>>>31^c<<1,n[e+1]=c>>>31^u<<1}const $0=new Uint32Array([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),Tt=new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3].map((n=>2*n)));function Dc(n,t){const r=new Uint32Array(32),e=new Uint32Array(n.b.buffer,n.b.byteOffset,32);for(let s=0;s<16;s++)r[s]=n.h[s],r[s+16]=$0[s];r[24]^=n.t0[0],r[25]^=n.t0[1];const i=t?4294967295:0;r[28]^=i,r[29]^=i;for(let s=0;s<12;s++){const a=s<<4;ar(r,e,0,8,16,24,Tt[a+0],Tt[a+1]),ar(r,e,2,10,18,26,Tt[a+2],Tt[a+3]),ar(r,e,4,12,20,28,Tt[a+4],Tt[a+5]),ar(r,e,6,14,22,30,Tt[a+6],Tt[a+7]),ar(r,e,0,10,20,30,Tt[a+8],Tt[a+9]),ar(r,e,2,12,22,24,Tt[a+10],Tt[a+11]),ar(r,e,4,14,16,26,Tt[a+12],Tt[a+13]),ar(r,e,6,8,18,28,Tt[a+14],Tt[a+15])}for(let s=0;s<16;s++)n.h[s]^=r[s]^r[s+16]}class d5{constructor(t,r,e,i){const s=new Uint8Array(64);this.S={b:new Uint8Array(Cn),h:new Uint32Array(Qa/4),t0:new Uint32Array(2),c:0,outlen:t},s[0]=t,r&&(s[1]=r.length),s[2]=1,s[3]=1,e&&s.set(e,32),i&&s.set(i,48);const a=new Uint32Array(s.buffer,s.byteOffset,s.length/Uint32Array.BYTES_PER_ELEMENT);for(let o=0;o<16;o++)this.S.h[o]=$0[o]^a[o];if(r){const o=new Uint8Array(Cn);o.set(r),this.update(o)}}update(t){if(!(t instanceof Uint8Array))throw Error("Input must be Uint8Array or Buffer");let r=0;for(;r<t.length;){this.S.c===Cn&&(Pc(this.S.t0,this.S.c),Dc(this.S,!1),this.S.c=0);let e=Cn-this.S.c;this.S.b.set(t.subarray(r,r+e),this.S.c);const i=Math.min(e,t.length-r);this.S.c+=i,r+=i}return this}digest(t){Pc(this.S.t0,this.S.c),this.S.b.fill(0,this.S.c),this.S.c=Cn,Dc(this.S,!0);const r=t||new Uint8Array(this.S.outlen);for(let e=0;e<this.S.outlen;e++)r[e]=this.S.h[e>>2]>>8*(3&e);return this.S.h=null,r.buffer}}function Pi(n,t,r,e){if(n>Qa)throw Error(`outlen must be at most ${Qa} (given: ${n})`);return new d5(n,t,r,e)}const Qa=64,Cn=128,Ne=1024,A5=new Uint8Array(new Uint16Array([43981]).buffer)[0]===205;function jt(n,t,r){return n[r+0]=t,n[r+1]=t>>8,n[r+2]=t>>16,n[r+3]=t>>24,n}function Ir(n,t,r){if(t>Number.MAX_SAFE_INTEGER)throw Error("LE64: large numbers unsupported");let e=t;for(let i=r;i<r+7;i++)n[i]=e,e=(e-n[i])/256;return n}function Js(n,t,r){const e=new Uint8Array(64),i=new Uint8Array(4+t.length);if(jt(i,n,0),i.set(t,4),n<=64)return Pi(n).update(i).digest(r),r;const s=Math.ceil(n/32)-2;for(let o=0;o<s;o++)Pi(64).update(o===0?i:e).digest(e),r.set(e.subarray(0,32),32*o);const a=new Uint8Array(Pi(n-32*s).update(e).digest());return r.set(a,32*s),r}function xc(n,t,r,e){return n.fn.XOR(t.byteOffset,r.byteOffset,e.byteOffset),t}function w5(n,t,r,e){return n.fn.G(t.byteOffset,r.byteOffset,e.byteOffset,n.refs.gZ.byteOffset),e}function m5(n,t,r,e){return n.fn.G2(t.byteOffset,r.byteOffset,e.byteOffset,n.refs.gZ.byteOffset),e}function*b5(n,t,r,e,i,s,a,o){n.refs.prngTmp.fill(0);const c=n.refs.prngTmp.subarray(0,48);Ir(c,t,0),Ir(c,r,8),Ir(c,e,16),Ir(c,i,24),Ir(c,s,32),Ir(c,2,40);for(let u=1;u<=a;u++){Ir(n.refs.prngTmp,u,c.length);const h=m5(n,n.refs.ZERO1024,n.refs.prngTmp,n.refs.prngR);for(let l=u===1?8*o:0;l<h.length;l+=8)yield h.subarray(l,l+8)}return[]}function k5(n,{memory:t,instance:r}){if(!A5)throw Error("BigEndian system not supported");const e=(function({type:E,version:K,tagLength:I,password:B,salt:U,ad:x,secret:M,parallelism:Q,memorySize:R,passes:N}){const T=(F,z,L,O)=>{if(z<L||z>O)throw Error(`${F} size should be between ${L} and ${O} bytes`)};if(E!==2||K!==19)throw Error("Unsupported type or version");return T("password",B,8,4294967295),T("salt",U,8,4294967295),T("tag",I,4,4294967295),T("memory",R,8*Q,4294967295),x&&T("associated data",x,0,4294967295),M&&T("secret",M,0,32),{type:E,version:K,tagLength:I,password:B,salt:U,ad:x,secret:M,lanes:Q,memorySize:R,passes:N}})({type:2,version:19,...n}),{G:i,G2:s,xor:a,getLZ:o}=r.exports,c={},u={};u.G=i,u.G2=s,u.XOR=a;const h=4*e.lanes*Math.floor(e.memorySize/(4*e.lanes)),l=h*Ne+10240;if(t.buffer.byteLength<l){const E=Math.ceil((l-t.buffer.byteLength)/65536);t.grow(E)}let y=0;c.gZ=new Uint8Array(t.buffer,y,Ne),y+=c.gZ.length,c.prngR=new Uint8Array(t.buffer,y,Ne),y+=c.prngR.length,c.prngTmp=new Uint8Array(t.buffer,y,Ne),y+=c.prngTmp.length,c.ZERO1024=new Uint8Array(t.buffer,y,1024),y+=c.ZERO1024.length;const g=new Uint32Array(t.buffer,y,2);y+=g.length*Uint32Array.BYTES_PER_ELEMENT;const p={fn:u,refs:c},A=new Uint8Array(t.buffer,y,Ne);y+=A.length;const w=new Uint8Array(t.buffer,y,e.memorySize*Ne),b=new Uint8Array(t.buffer,0,y),v=(function(E){const K=Pi(64),I=new Uint8Array(4),B=new Uint8Array(24);jt(B,E.lanes,0),jt(B,E.tagLength,4),jt(B,E.memorySize,8),jt(B,E.passes,12),jt(B,E.version,16),jt(B,E.type,20);const U=[B];E.password?(U.push(jt(new Uint8Array(4),E.password.length,0)),U.push(E.password)):U.push(I),E.salt?(U.push(jt(new Uint8Array(4),E.salt.length,0)),U.push(E.salt)):U.push(I),E.secret?(U.push(jt(new Uint8Array(4),E.secret.length,0)),U.push(E.secret)):U.push(I),E.ad?(U.push(jt(new Uint8Array(4),E.ad.length,0)),U.push(E.ad)):U.push(I),K.update((function(M){if(M.length===1)return M[0];let Q=0;for(let T=0;T<M.length;T++){if(!(M[T]instanceof Uint8Array))throw Error("concatArrays: Data must be in the form of a Uint8Array");Q+=M[T].length}const R=new Uint8Array(Q);let N=0;return M.forEach((T=>{R.set(T,N),N+=T.length})),R})(U));const x=K.digest();return new Uint8Array(x)})(e),k=h/e.lanes,m=Array(e.lanes).fill(null).map((()=>Array(k))),C=(E,K)=>(m[E][K]=w.subarray(E*k*1024+1024*K,E*k*1024+1024*K+Ne),m[E][K]);for(let E=0;E<e.lanes;E++){const K=new Uint8Array(v.length+8);K.set(v),jt(K,0,v.length),jt(K,E,v.length+4),Js(Ne,K,C(E,0)),jt(K,1,v.length),Js(Ne,K,C(E,1))}const D=k/4;for(let E=0;E<e.passes;E++)for(let K=0;K<4;K++){const I=E===0&&K<=1;for(let B=0;B<e.lanes;B++){let U=K===0&&E===0?2:0;const x=I?b5(p,E,B,K,h,e.passes,D,U):null;for(;U<D;U++){const M=K*D+U,Q=M>0?m[B][M-1]:m[B][k-1],R=I?x.next().value:Q;o(g.byteOffset,R.byteOffset,B,e.lanes,E,K,U,4,D);const N=g[0],T=g[1];E===0&&C(B,M),w5(p,Q,m[N][T],E>0?A:m[B][M]),E>0&&xc(p,m[B][M],A,m[B][M])}}}const P=m[0][k-1];for(let E=1;E<e.lanes;E++)xc(p,P,P,m[E][k-1]);const S=Js(e.tagLength,P,new Uint8Array(e.tagLength));return b.fill(0),t.grow(0),S}let wi;async function E5(n,t){const r=new WebAssembly.Memory({initial:1040,maximum:65536}),e=await(async function(i,s,a){const o={env:{memory:i}};if(wi===void 0)try{const c=await s(o);return wi=!0,c}catch{wi=!1}return(wi?s:a)(o)})(r,n,t);return i=>k5(i,{instance:e.instance,memory:r})}function Qc(n,t,r,e){var i=null,s=Lt.atob(r),a=s.length;i=new Uint8Array(new ArrayBuffer(a));for(var o=0;o<a;o++)i[o]=s.charCodeAt(o);return(function(c,u,h){var l=h?WebAssembly.instantiateStreaming:WebAssembly.instantiate,y=h?WebAssembly.compileStreaming:WebAssembly.compile;return u?l(c,u):y(c)})(i,e,!1)}var Mc,Rc,Tc,Fc,Lc,Nc,v5=Object.freeze({__proto__:null,default:async()=>E5((n=>Qc(0,0,"AGFzbQEAAAABKwdgBH9/f38AYAABf2AAAGADf39/AGAJf39/f39/f39/AX9gAX8AYAF/AX8CEwEDZW52Bm1lbW9yeQIBkAiAgAQDCgkCAwAABAEFBgEEBQFwAQICBgkBfwFBkIjAAgsHfQoDeG9yAAEBRwACAkcyAAMFZ2V0TFoABBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALX2luaXRpYWxpemUAABBfX2Vycm5vX2xvY2F0aW9uAAgJc3RhY2tTYXZlAAUMc3RhY2tSZXN0b3JlAAYKc3RhY2tBbGxvYwAHCQcBAEEBCwEACs0gCQMAAQtYAQJ/A0AgACAEQQR0IgNqIAIgA2r9AAQAIAEgA2r9AAQA/VH9CwQAIAAgA0EQciIDaiACIANq/QAEACABIANq/QAEAP1R/QsEACAEQQJqIgRBwABHDQALC7ceAgt7A38DQCADIBFBBHQiD2ogASAPav0ABAAgACAPav0ABAD9USIF/QsEACACIA9qIAX9CwQAIAMgD0EQciIPaiABIA9q/QAEACAAIA9q/QAEAP1RIgX9CwQAIAIgD2ogBf0LBAAgEUECaiIRQcAARw0ACwNAIAMgEEEHdGoiAEEQaiAA/QAEcCAA/QAEMCIFIAD9AAQQIgT9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAQgBP0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9USIJQSD9ywEgCUEg/c0B/VAiCSAA/QAEUCIG/c4BIAkgCf0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIGIAX9USIFQSj9ywEgBUEY/c0B/VAiCCAE/c4BIAggCP0NAAECAwgJCgsAAQIDCAkKCyAEIAT9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIKIAogCf1RIgVBMP3LASAFQRD9zQH9UCIFIAb9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgkgCP1RIgRBAf3LASAEQT/9zQH9UCIMIAD9AARgIAD9AAQgIgQgAP0ABAAiBv3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBv1RIghBIP3LASAIQSD9zQH9UCIIIABBQGsiAf0ABAAiB/3OASAIIAj9DQABAgMICQoLAAECAwgJCgsgByAH/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiByAE/VEiBEEo/csBIARBGP3NAf1QIgsgBv3OASALIAv9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAI/VEiBEEw/csBIARBEP3NAf1QIgQgB/3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgByAH/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCCAL/VEiB0EB/csBIAdBP/3NAf1QIg0gDf0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eHyIH/c4BIAcgB/0NAAECAwgJCgsAAQIDCAkKCyAKIAr9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIKIAQgBSAF/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/VEiC0Eg/csBIAtBIP3NAf1QIgsgCP3OASALIAv9DQABAgMICQoLAAECAwgJCgsgCCAI/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCCAH/VEiB0Eo/csBIAdBGP3NAf1QIgcgCv3OASAHIAf9DQABAgMICQoLAAECAwgJCgsgCiAK/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiDv0LBAAgACAGIA0gDCAM/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4fIgr9zgEgCiAK/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgYgBSAEIAT9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9USIFQSD9ywEgBUEg/c0B/VAiBSAJ/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAJIAn9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJIAr9USIEQSj9ywEgBEEY/c0B/VAiCiAG/c4BIAogCv0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIE/QsEACAAIAQgBf1RIgVBMP3LASAFQRD9zQH9UCIFIA4gC/1RIgRBMP3LASAEQRD9zQH9UCIEIAT9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwRgIAAgBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwRwIAEgBCAI/c4BIAQgBP0NAAECAwgJCgsAAQIDCAkKCyAIIAj9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIE/QsEACAAIAUgCf3OASAFIAX9DQABAgMICQoLAAECAwgJCgsgCSAJ/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCf0LBFAgACAEIAf9USIFQQH9ywEgBUE//c0B/VAiBSAJIAr9USIEQQH9ywEgBEE//c0B/VAiBCAE/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEICAAIAQgBSAF/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEMCAQQQFqIhBBCEcNAAtBACEQA0AgAyAQQQR0aiIAQYABaiAA/QAEgAcgAP0ABIADIgUgAP0ABIABIgT9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAQgBP0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9USIJQSD9ywEgCUEg/c0B/VAiCSAA/QAEgAUiBv3OASAJIAn9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAF/VEiBUEo/csBIAVBGP3NAf1QIgggBP3OASAIIAj9DQABAgMICQoLAAECAwgJCgsgBCAE/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCiAKIAn9USIFQTD9ywEgBUEQ/c0B/VAiBSAG/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJIAj9USIEQQH9ywEgBEE//c0B/VAiDCAA/QAEgAYgAP0ABIACIgQgAP0ABAAiBv3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBv1RIghBIP3LASAIQSD9zQH9UCIIIAD9AASABCIH/c4BIAggCP0NAAECAwgJCgsAAQIDCAkKCyAHIAf9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIHIAT9USIEQSj9ywEgBEEY/c0B/VAiCyAG/c4BIAsgC/0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIGIAj9USIEQTD9ywEgBEEQ/c0B/VAiBCAH/c4BIAQgBP0NAAECAwgJCgsAAQIDCAkKCyAHIAf9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIIIAv9USIHQQH9ywEgB0E//c0B/VAiDSAN/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4fIgf9zgEgByAH/Q0AAQIDCAkKCwABAgMICQoLIAogCv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgogBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9USILQSD9ywEgC0Eg/c0B/VAiCyAI/c4BIAsgC/0NAAECAwgJCgsAAQIDCAkKCyAIIAj9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIIIAf9USIHQSj9ywEgB0EY/c0B/VAiByAK/c4BIAcgB/0NAAECAwgJCgsAAQIDCAkKCyAKIAr9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIO/QsEACAAIAYgDSAMIAz9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh8iCv3OASAKIAr9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAFIAQgBP0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/1RIgVBIP3LASAFQSD9zQH9UCIFIAn9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAkgCf0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgkgCv1RIgRBKP3LASAEQRj9zQH9UCIKIAb9zgEgCiAK/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9CwQAIAAgBCAF/VEiBUEw/csBIAVBEP3NAf1QIgUgDiAL/VEiBEEw/csBIARBEP3NAf1QIgQgBP0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/0LBIAGIAAgBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwSAByAAIAQgCP3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgCCAI/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBP0LBIAEIAAgBSAJ/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAJIAn9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJ/QsEgAUgACAEIAf9USIFQQH9ywEgBUE//c0B/VAiBSAJIAr9USIEQQH9ywEgBEE//c0B/VAiBCAE/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEgAIgACAEIAUgBf0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/0LBIADIBBBAWoiEEEIRw0AC0EAIRADQCACIBBBBHQiAGoiASAAIANq/QAEACAB/QAEAP1R/QsEACACIABBEHIiAWoiDyABIANq/QAEACAP/QAEAP1R/QsEACACIABBIHIiAWoiDyABIANq/QAEACAP/QAEAP1R/QsEACACIABBMHIiAGoiASAAIANq/QAEACAB/QAEAP1R/QsEACAQQQRqIhBBwABHDQALCxYAIAAgASACIAMQAiAAIAIgAiADEAILewIBfwF+IAIhCSABNQIAIQogBCAFcgRAIAEoAgQgA3AhCQsgACAJNgIAIAAgB0EBayAFIAQbIAhsIAZBAWtBAEF/IAYbIAIgCUYbaiIBIAVBAWogCGxBACAEG2ogAa0gCiAKfkIgiH5CIIinQX9zaiAHIAhscDYCBCAACwQAIwALBgAgACQACxAAIwAgAGtBcHEiACQAIAALBQBBgAgL",n)),(n=>Qc(0,0,"AGFzbQEAAAABPwhgBH9/f38AYAABf2AAAGADf39/AGARf39/f39/f39/f39/f39/f38AYAl/f39/f39/f38Bf2ABfwBgAX8BfwITAQNlbnYGbWVtb3J5AgGQCICABAMLCgIDBAAABQEGBwEEBQFwAQICBgkBfwFBkIjAAgsHfQoDeG9yAAEBRwADAkcyAAQFZ2V0TFoABRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALX2luaXRpYWxpemUAABBfX2Vycm5vX2xvY2F0aW9uAAkJc3RhY2tTYXZlAAYMc3RhY2tSZXN0b3JlAAcKc3RhY2tBbGxvYwAICQcBAEEBCwEACssaCgMAAQtQAQJ/A0AgACAEQQN0IgNqIAIgA2opAwAgASADaikDAIU3AwAgACADQQhyIgNqIAIgA2opAwAgASADaikDAIU3AwAgBEECaiIEQYABRw0ACwveDwICfgF/IAAgAUEDdGoiEyATKQMAIhEgACAFQQN0aiIBKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA1BA3RqIgUgESAFKQMAhUIgiSIRNwMAIAAgCUEDdGoiCSARIAkpAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAEgESABKQMAhUIoiSIRNwMAIBMgESATKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAFIBEgBSkDAIVCMIkiETcDACAJIBEgCSkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgASARIAEpAwCFQgGJNwMAIAAgAkEDdGoiDSANKQMAIhEgACAGQQN0aiICKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA5BA3RqIgYgESAGKQMAhUIgiSIRNwMAIAAgCkEDdGoiCiARIAopAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAIgESACKQMAhUIoiSIRNwMAIA0gESANKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAGIBEgBikDAIVCMIkiETcDACAKIBEgCikDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAiARIAIpAwCFQgGJNwMAIAAgA0EDdGoiDiAOKQMAIhEgACAHQQN0aiIDKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA9BA3RqIgcgESAHKQMAhUIgiSIRNwMAIAAgC0EDdGoiCyARIAspAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAMgESADKQMAhUIoiSIRNwMAIA4gESAOKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAHIBEgBykDAIVCMIkiETcDACALIBEgCykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAyARIAMpAwCFQgGJNwMAIAAgBEEDdGoiDyAPKQMAIhEgACAIQQN0aiIEKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIBBBA3RqIgggESAIKQMAhUIgiSIRNwMAIAAgDEEDdGoiACARIAApAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAQgESAEKQMAhUIoiSIRNwMAIA8gESAPKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAIIBEgCCkDAIVCMIkiETcDACAAIBEgACkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgBCARIAQpAwCFQgGJNwMAIBMgEykDACIRIAIpAwAiEnwgEUIBhkL+////H4MgEkL/////D4N+fCIRNwMAIAggESAIKQMAhUIgiSIRNwMAIAsgESALKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACACIBEgAikDAIVCKIkiETcDACATIBEgEykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgCCARIAgpAwCFQjCJIhE3AwAgCyARIAspAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAIgESACKQMAhUIBiTcDACANIA0pAwAiESADKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAFIBEgBSkDAIVCIIkiETcDACAAIBEgACkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAyARIAMpAwCFQiiJIhE3AwAgDSARIA0pAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAUgESAFKQMAhUIwiSIRNwMAIAAgESAAKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACADIBEgAykDAIVCAYk3AwAgDiAOKQMAIhEgBCkDACISfCARQgGGQv7///8fgyASQv////8Pg358IhE3AwAgBiARIAYpAwCFQiCJIhE3AwAgCSARIAkpAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAQgESAEKQMAhUIoiSIRNwMAIA4gESAOKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAGIBEgBikDAIVCMIkiETcDACAJIBEgCSkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgBCARIAQpAwCFQgGJNwMAIA8gDykDACIRIAEpAwAiEnwgEUIBhkL+////H4MgEkL/////D4N+fCIRNwMAIAcgESAHKQMAhUIgiSIRNwMAIAogESAKKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACABIBEgASkDAIVCKIkiETcDACAPIBEgDykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgByARIAcpAwCFQjCJIhE3AwAgCiARIAopAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAEgESABKQMAhUIBiTcDAAvdCAEPfwNAIAIgBUEDdCIGaiABIAZqKQMAIAAgBmopAwCFNwMAIAIgBkEIciIGaiABIAZqKQMAIAAgBmopAwCFNwMAIAVBAmoiBUGAAUcNAAsDQCADIARBA3QiAGogACACaikDADcDACADIARBAXIiAEEDdCIBaiABIAJqKQMANwMAIAMgBEECciIBQQN0IgVqIAIgBWopAwA3AwAgAyAEQQNyIgVBA3QiBmogAiAGaikDADcDACADIARBBHIiBkEDdCIHaiACIAdqKQMANwMAIAMgBEEFciIHQQN0IghqIAIgCGopAwA3AwAgAyAEQQZyIghBA3QiCWogAiAJaikDADcDACADIARBB3IiCUEDdCIKaiACIApqKQMANwMAIAMgBEEIciIKQQN0IgtqIAIgC2opAwA3AwAgAyAEQQlyIgtBA3QiDGogAiAMaikDADcDACADIARBCnIiDEEDdCINaiACIA1qKQMANwMAIAMgBEELciINQQN0Ig5qIAIgDmopAwA3AwAgAyAEQQxyIg5BA3QiD2ogAiAPaikDADcDACADIARBDXIiD0EDdCIQaiACIBBqKQMANwMAIAMgBEEOciIQQQN0IhFqIAIgEWopAwA3AwAgAyAEQQ9yIhFBA3QiEmogAiASaikDADcDACADIARB//8DcSAAQf//A3EgAUH//wNxIAVB//8DcSAGQf//A3EgB0H//wNxIAhB//8DcSAJQf//A3EgCkH//wNxIAtB//8DcSAMQf//A3EgDUH//wNxIA5B//8DcSAPQf//A3EgEEH//wNxIBFB//8DcRACIARB8ABJIQAgBEEQaiEEIAANAAtBACEBIANBAEEBQRBBEUEgQSFBMEExQcAAQcEAQdAAQdEAQeAAQeEAQfAAQfEAEAIgA0ECQQNBEkETQSJBI0EyQTNBwgBBwwBB0gBB0wBB4gBB4wBB8gBB8wAQAiADQQRBBUEUQRVBJEElQTRBNUHEAEHFAEHUAEHVAEHkAEHlAEH0AEH1ABACIANBBkEHQRZBF0EmQSdBNkE3QcYAQccAQdYAQdcAQeYAQecAQfYAQfcAEAIgA0EIQQlBGEEZQShBKUE4QTlByABByQBB2ABB2QBB6ABB6QBB+ABB+QAQAiADQQpBC0EaQRtBKkErQTpBO0HKAEHLAEHaAEHbAEHqAEHrAEH6AEH7ABACIANBDEENQRxBHUEsQS1BPEE9QcwAQc0AQdwAQd0AQewAQe0AQfwAQf0AEAIgA0EOQQ9BHkEfQS5BL0E+QT9BzgBBzwBB3gBB3wBB7gBB7wBB/gBB/wAQAgNAIAIgAUEDdCIAaiIEIAAgA2opAwAgBCkDAIU3AwAgAiAAQQhyIgRqIgUgAyAEaikDACAFKQMAhTcDACACIABBEHIiBGoiBSADIARqKQMAIAUpAwCFNwMAIAIgAEEYciIAaiIEIAAgA2opAwAgBCkDAIU3AwAgAUEEaiIBQYABRw0ACwsWACAAIAEgAiADEAMgACACIAIgAxADC3sCAX8BfiACIQkgATUCACEKIAQgBXIEQCABKAIEIANwIQkLIAAgCTYCACAAIAdBAWsgBSAEGyAIbCAGQQFrQQBBfyAGGyACIAlGG2oiASAFQQFqIAhsQQAgBBtqIAGtIAogCn5CIIh+QiCIp0F/c2ogByAIbHA2AgQgAAsEACMACwYAIAAkAAsQACMAIABrQXBxIgAkACAACwUAQYAICw==",n)))});function I5(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var S5=(function(){if(Nc)return Lc;Nc=1;const n=(function(){if(Rc)return Mc;function r(s){this.name="Bzip2Error",this.message=s,this.stack=Error().stack}Rc=1,r.prototype=Error();var e=function(s){throw new r(s)},i={};return i.Bzip2Error=r,i.crcTable=[0,79764919,159529838,222504665,319059676,398814059,445009330,507990021,638119352,583659535,797628118,726387553,890018660,835552979,1015980042,944750013,1276238704,1221641927,1167319070,1095957929,1595256236,1540665371,1452775106,1381403509,1780037320,1859660671,1671105958,1733955601,2031960084,2111593891,1889500026,1952343757,2552477408,2632100695,2443283854,2506133561,2334638140,2414271883,2191915858,2254759653,3190512472,3135915759,3081330742,3009969537,2905550212,2850959411,2762807018,2691435357,3560074640,3505614887,3719321342,3648080713,3342211916,3287746299,3467911202,3396681109,4063920168,4143685023,4223187782,4286162673,3779000052,3858754371,3904687514,3967668269,881225847,809987520,1023691545,969234094,662832811,591600412,771767749,717299826,311336399,374308984,453813921,533576470,25881363,88864420,134795389,214552010,2023205639,2086057648,1897238633,1976864222,1804852699,1867694188,1645340341,1724971778,1587496639,1516133128,1461550545,1406951526,1302016099,1230646740,1142491917,1087903418,2896545431,2825181984,2770861561,2716262478,3215044683,3143675388,3055782693,3001194130,2326604591,2389456536,2200899649,2280525302,2578013683,2640855108,2418763421,2498394922,3769900519,3832873040,3912640137,3992402750,4088425275,4151408268,4197601365,4277358050,3334271071,3263032808,3476998961,3422541446,3585640067,3514407732,3694837229,3640369242,1762451694,1842216281,1619975040,1682949687,2047383090,2127137669,1938468188,2001449195,1325665622,1271206113,1183200824,1111960463,1543535498,1489069629,1434599652,1363369299,622672798,568075817,748617968,677256519,907627842,853037301,1067152940,995781531,51762726,131386257,177728840,240578815,269590778,349224269,429104020,491947555,4046411278,4126034873,4172115296,4234965207,3794477266,3874110821,3953728444,4016571915,3609705398,3555108353,3735388376,3664026991,3290680682,3236090077,3449943556,3378572211,3174993278,3120533705,3032266256,2961025959,2923101090,2868635157,2813903052,2742672763,2604032198,2683796849,2461293480,2524268063,2284983834,2364738477,2175806836,2238787779,1569362073,1498123566,1409854455,1355396672,1317987909,1246755826,1192025387,1137557660,2072149281,2135122070,1912620623,1992383480,1753615357,1816598090,1627664531,1707420964,295390185,358241886,404320391,483945776,43990325,106832002,186451547,266083308,932423249,861060070,1041341759,986742920,613929101,542559546,756411363,701822548,3316196985,3244833742,3425377559,3370778784,3601682597,3530312978,3744426955,3689838204,3819031489,3881883254,3928223919,4007849240,4037393693,4100235434,4180117107,4259748804,2310601993,2373574846,2151335527,2231098320,2596047829,2659030626,2470359227,2550115596,2947551409,2876312838,2788305887,2733848168,3165939309,3094707162,3040238851,2985771188],i.array=function(s){var a=0,o=0,c=[0,1,3,7,15,31,63,127,255];return function(u){for(var h=0;u>0;){var l=8-a;u>=l?(h<<=l,h|=c[l]&s[o++],a=0,u-=l):(h<<=u,h|=(s[o]&c[u]<<8-u-a)>>8-u-a,a+=u,u=0)}return h}},i.simple=function(s,a){var o=i.array(s),c=!1,u=1e5*i.header(o),h=new Int32Array(u);do c=i.decompress(o,a,h,u);while(!c)},i.header=function(s){this.byteCount=new Int32Array(256),this.symToByte=new Uint8Array(256),this.mtfSymbol=new Int32Array(256),this.selectors=new Uint8Array(32768),s(24)!=4348520&&e("No magic number found");var a=s(8)-48;return(a<1||a>9)&&e("Not a BZIP archive"),a},i.decompress=function(s,a,o,c,u){for(var h=-1,l="",y=0;y<6;y++)l+=s(8).toString(16);if(l=="177245385090")return(0|s(32))!==u&&e("Error in bzip2: crc32 do not match"),s(null),null;l!="314159265359"&&e("Invalid bzip data");var g=0|s(32);s(1)&&e("unsupported obsolete version");var p=s(24);p>c&&e("Initial position larger than buffer size");var A=s(16),w=0;for(y=0;y<16;y++)if(A&1<<15-y){var b=s(16);for(m=0;m<16;m++)b&1<<15-m&&(this.symToByte[w++]=16*y+m)}var v=s(3);(v<2||v>6)&&e("Invalid bzip data");var k=s(15);for(k==0&&e("Invalid bzip data"),y=0;y<v;y++)this.mtfSymbol[y]=y;for(y=0;y<k;y++){for(var m=0;s(1);m++)m>=v&&e("Invalid bzip data");var C=this.mtfSymbol[m];for(b=m-1;b>=0;b--)this.mtfSymbol[b+1]=this.mtfSymbol[b];this.mtfSymbol[0]=C,this.selectors[y]=C}var D,P,S,E,K=w+2,I=[],B=new Uint8Array(258),U=new Uint16Array(21);for(m=0;m<v;m++){for(A=s(5),y=0;y<K;y++){for(;(A<1||A>20)&&e("Invalid bzip data"),s(1);)s(1)?A--:A++;B[y]=A}var x,M;for(x=M=B[0],y=1;y<K;y++)B[y]>M?M=B[y]:B[y]<x&&(x=B[y]);(D=I[m]={}).permute=new Int32Array(258),D.limit=new Int32Array(21),D.base=new Int32Array(21),D.minLen=x,D.maxLen=M;var Q=D.base,R=D.limit,N=0;for(y=x;y<=M;y++)for(A=0;A<K;A++)B[A]==y&&(D.permute[N++]=A);for(y=x;y<=M;y++)U[y]=R[y]=0;for(y=0;y<K;y++)U[B[y]]++;for(N=A=0,y=x;y<M;y++)N+=U[y],R[y]=N-1,N<<=1,Q[y+1]=N-(A+=U[y]);R[M]=N+U[M]-1,Q[x]=0}for(y=0;y<256;y++)this.mtfSymbol[y]=y,this.byteCount[y]=0;for(P=S=K=E=0;;){for(K--||(K=49,E>=k&&e("Invalid bzip data"),Q=(D=I[this.selectors[E++]]).base,R=D.limit),m=s(y=D.minLen);y>D.maxLen&&e("Invalid bzip data"),!(m<=R[y]);)y++,m=m<<1|s(1);((m-=Q[y])<0||m>=258)&&e("Invalid bzip data");var T=D.permute[m];if(T!=0&&T!=1){if(P)for(P=0,S+A>c&&e("Invalid bzip data"),C=this.symToByte[this.mtfSymbol[0]],this.byteCount[C]+=A;A--;)o[S++]=C;if(T>w)break;for(S>=c&&e("Invalid bzip data"),y=T-1,C=this.mtfSymbol[y],b=y-1;b>=0;b--)this.mtfSymbol[b+1]=this.mtfSymbol[b];this.mtfSymbol[0]=C,C=this.symToByte[C],this.byteCount[C]++,o[S++]=C}else P||(P=1,A=0),A+=T==0?P:2*P,P<<=1}for((p<0||p>=S)&&e("Invalid bzip data"),m=0,y=0;y<256;y++)b=m+this.byteCount[y],this.byteCount[y]=m,m=b;for(y=0;y<S;y++)C=255&o[y],o[this.byteCount[C]]|=y<<8,this.byteCount[C]++;var F,z,L,O=0,H=0,j=0;for(S&&(H=255&(O=o[p]),O>>=8,j=-1);S;){for(S--,z=H,H=255&(O=o[O]),O>>=8,j++==3?(F=H,L=z,H=-1):(F=1,L=H);F--;)h=4294967295&(h<<8^this.crcTable[255&(h>>24^L)]),a(L);H!=z&&(j=0)}return(0|(h=~h>>>0))!=(0|g)&&e("Error in bzip2: crc32 do not match"),4294967295&(h^(u<<1|u>>>31))},Mc=i})(),t=(function(){if(Fc)return Tc;Fc=1;var r=[0,1,3,7,15,31,63,127,255];return Tc=function(e){var i=0,s=0,a=e(),o=function(c){if(c===null&&i!=0)return i=0,void s++;for(var u=0;c>0;){s>=a.length&&(s=0,a=e());var h=8-i;i===0&&c>0&&o.bytesRead++,c>=h?(u<<=h,u|=r[h]&a[s++],i=0,c-=h):(u<<=c,u|=(a[s]&r[c]<<8-c-i)>>8-c-i,i+=c,c=0)}return u};return o.bytesRead=0,o}})();return Lc=function(r){const e=[];let i=0,s=0,a=!1,o=!1,c=null,u=null,h,l=0;function y(g){if(!a)try{return(function(p){if(s){const A=1e5*s,w=new Int32Array(A),b=[],v=function(k){b.push(k)};return u=n.decompress(c,v,w,A,u),u===null?(s=0,!1):(p(new Uint8Array(b)),!0)}return s=n.header(c),u=0,!1})((function(p){g.enqueue(p),p!==null&&(l+=p.length)}))}catch(p){return g.error(p),a=!0,!0}}return new ReadableStream({start(){h=r.getReader()},async pull(g){try{for(;;){for(;!(o||c&&i-c.bytesRead+1>=25e3+1e5*(s||4));){const{value:p,done:A}=await h.read();A?o=!0:(e.push(p),i+=p.length,c===null&&(c=t((function(){return e.shift()}))))}for(;o?c&&i>c.bytesRead:c&&i-c.bytesRead+1>=25e3+1e5*(s||4);)if(y(g))return;if(o&&!a&&(!c||i<=c.bytesRead))return void(u===null?g.close():g.error(Error("input stream ended prematurely")))}}catch(p){g.error(p)}},async cancel(g){await h.abort(g)}},{highWaterMark:0})}})(),B5=Object.freeze({__proto__:null,default:I5(S5)});export{bu as AEADEncryptedDataPacket,qe as CleartextMessage,ti as CompressedDataPacket,be as GrammarError,Ar as LiteralDataPacket,K5 as MarkerPacket,Ot as Message,ae as OnePassSignaturePacket,rt as PacketList,U5 as PaddingPacket,pn as PrivateKey,ka as PublicKey,Yn as PublicKeyEncryptedSessionKeyPacket,Ke as PublicKeyPacket,ys as PublicSubkeyPacket,Ja as SecretKeyPacket,H1 as SecretSubkeyPacket,Ur as Signature,Bt as SignaturePacket,fn as Subkey,cn as SymEncryptedIntegrityProtectedDataPacket,un as SymEncryptedSessionKeyPacket,Eu as SymmetricallyEncryptedDataPacket,C5 as TrustPacket,ea as UnparseablePacket,Za as UserAttributePacket,gs as UserIDPacket,gn as armor,G as config,L5 as createCleartextMessage,T5 as createMessage,V5 as decrypt,z5 as decryptKey,X5 as decryptSessionKeys,j5 as encrypt,G5 as encryptKey,J5 as encryptSessionKey,f as enums,N5 as generateKey,Z5 as generateSessionKey,F5 as readCleartextMessage,D5 as readKey,Q5 as readKeys,R5 as readMessage,x5 as readPrivateKey,M5 as readPrivateKeys,P5 as readSignature,O5 as reformatKey,H5 as revokeKey,q5 as sign,Ze as unarmor,Y5 as verify};
